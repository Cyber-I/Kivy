{
  
    
        "post0": {
            "title": "Python数据科学分享——5.推荐系统",
            "content": ". # %matplotlib widget from matplotlib.font_manager import _rebuild _rebuild() import matplotlib.pyplot as plt import seaborn as sns sns.set_style(&quot;whitegrid&quot;, {&quot;font.sans-serif&quot;: [&quot;SimHei&quot;, &quot;Arial&quot;]}) import warnings warnings.filterwarnings(&quot;ignore&quot;) import time import numpy as np from scipy import stats import pandas as pd from sklearn.preprocessing import StandardScaler from mabwiser.mab import MAB, LearningPolicy, NeighborhoodPolicy . 时间 事件 . 1891 | 美国Sittman与Pitt发明老虎机 | . 1987 | 学者提出多臂老虎机问题(multi-armed bandit problem，MAB） | . 1997 | 使用Thompson采样(1933)解决MAB问题 | . 1998 | ϵ贪婪算法（epsilon-Greedy Algorithm) | . 2002 | UCB算法(Upper Confidence Bound，置信区间上界) | . 2010 | Yahoo!提出LinUCB算法 | . 2020年2月 | 美国康奈尔大学与阿里巴巴共同提出了PSLinUCB | . EE(Explore VS Exploit)&#38382;&#39064; . EE，Explore VS Exploit：一种运筹学概念，任何profit-seeking系统的基本条件，平衡探索新模型(exploration)与维护旧模型的收益最大化(exploitation) . 1. Explore：A/B实验，惊喜猎奇，新颖多样；强化学习（reinforcement learning） 1. Exploit：物以类聚、人以群分，尽力迎合用户，使收益最大化（profit maximization） . . A/B&#27979;&#35797; . A/B测试分两个阶段进行： . Explore阶段：用户分A/B组进行两个模型的对照实验，一段时间内检查两组实验效果 | Exploit阶段：假设A效果优于B，那么将A组模型覆盖所有用户，放弃B模型 | 问题： . 流量从Explore阶段直接切换到Exploit阶段，缺少平滑过渡，风险较大 | 在Explore阶段，为了收集足够多的对照数据在B组上浪费资源，在实验时间上没有弹性 | Bandit&#31639;&#27861; . 解决问题：在任意时间任意A/B配置空间做出至今最好的决策，使目标函数收敛 . 根据实验进展结果，平滑地减少实验数量，避免一刀切 | 尽可能将资源集中在效果好的实验A上，从而降低资源浪费 | 概率论的多臂老虎机问题(multi-armed bandit problem，MAB）。 . 假设有3个老虎机在你面前，每台老虎机中奖概率不同，玩哪个老虎机可以做到长期收益最大化？ . . . 摇臂（Arm）：一种选择对应一个摇臂。例如，用户点击哪个房屋？一个房屋是一个Arm | 收益（Reward）:选择结果的量化指标。例如，用户点击了3次房屋A，那么得到的收益+3，优于点击2次 | class Bandit(object): def __init__(self, n, probas=None): &quot;&quot;&quot; Parameters: n：老虎机arm的数量 probas：每个老虎机arm中奖概率列表 &quot;&quot;&quot; self.n = n if probas is None: np.random.seed(int(time.time())) self.probas = np.random.random(self.n) else: self.probas = probas self.best_proba = max(self.probas) def generate_reward(self, i): &quot;&quot;&quot; 选择第i台老虎机，计算收益 &quot;&quot;&quot; if np.random.random() &lt; self.probas[i]: return 1 else: return 0 . mab = Bandit(3) mab.probas . array([0.63347486, 0.14875777, 0.27710719]) . # 试验10次（10个时间步）的收益 for n in range(10): print([mab.generate_reward(i) for i in range(mab.n)]) . [0, 1, 1] [0, 0, 0] [1, 0, 0] [0, 0, 0] [1, 0, 1] [0, 0, 1] [0, 0, 0] [0, 1, 0] [1, 1, 1] [0, 0, 0] . &#32047;&#31215;&#36951;&#25022;&#65288;Cumulative regret&#65289; . 假设每个老虎机每次的收益的服从伯努利分布，取值1或0 . $ begin{aligned} R_{T} &amp;= sum_{i=1}^{T} left(w^{*}-w_{B(i)} right) &amp;=T w^{*}- sum_{i=1}^{T} w_{B(i)} end{aligned} $ . 其中， . T：表示尝试的次数 $w^{*}$：表示所有老虎机中的最大收益 $w_{B(i)}$：表示第 i 次试验时被选中老虎机的期望收益 . class Solver(object): def __init__(self, bandit): &quot;&quot;&quot; Parameters: bandit (Bandit): N个老虎机arm &quot;&quot;&quot; np.random.seed(int(time.time())) self.bandit = bandit self.counts = np.zeros(self.bandit.n) self.actions = [] # 选择结果列表 self.regret = 0 # 累积遗憾 self.regrets = [0] # 累积遗憾列表 def update_regret(self, i): self.regret += self.bandit.best_proba - self.bandit.probas[i] self.regrets.append(self.regret) @property def estimated_probas(self): raise NotImplementedError def run_one_step(self): &quot;&quot;&quot;返回当前进行试验老虎机arm索引&quot;&quot;&quot; raise NotImplementedError def run(self, num_steps): assert self.bandit is not None for _ in range(num_steps): i = self.run_one_step() self.counts[i] += 1 self.actions.append(i) self.update_regret(i) . &#1013;&#36138;&#23146;&#31639;&#27861; . ϵ贪婪算法（epsilon-Greedy Algorithm，1998年提出）是一种在当前作出利益最大化的选择（exploit）的贪婪算法，使用ϵ参数调节以实现探索（explore）的效果。概率分布如下： . 1 – ϵ：Exploit维持旧模型 | ϵ / 2：Explore尝试最好或最差实验 | ϵ=1：均匀探索所有arm，导致资源浪费 | ϵ=0：停止探索，仅仅维持旧模型 | . class EpsilonGreedy(Solver): def __init__(self, bandit, eps, init_proba=1): &quot;&quot;&quot; Parameters: eps (float): 每一步探索的概率 init_proba (float): 老虎机初始概率，默认为1 &quot;&quot;&quot; super(EpsilonGreedy, self).__init__(bandit) self.eps = eps self.estimates = init_proba * np.ones(self.bandit.n) @property def estimated_probas(self): return self.estimates def run_one_step(self): if np.random.random() &lt; self.eps: i = np.random.randint(0, self.bandit.n) else: i = np.argmax(self.estimates) r = self.bandit.generate_reward(i) self.estimates[i] += 1 / (self.counts[i] + 1) * (r - self.estimates[i]) return i . def plot_results(solvers, solver_names, figname): &quot;&quot;&quot; 绘制bandit算法效果图 Parameters: solvers (list&lt;Solver&gt;): 算法实例 solver_names (list&lt;str)：算法实例显示名称 figname (str)： &quot;&quot;&quot; b = solvers[0].bandit fig, ax = plt.subplots(1, 3, figsize=(14, 5)) fig.subplots_adjust(bottom=0.3, wspace=0.3) # 1. 遗憾随时间变化 for i, s in enumerate(solvers): ax[0].plot(range(len(s.regrets)), s.regrets, label=solver_names[i]) ax[0].set_xlabel(&quot;试验次数&quot;) ax[0].set_ylabel(&quot;累计遗憾&quot;) ax[0].legend(loc=9, bbox_to_anchor=(1.82, -0.25), ncol=5) ax[0].grid(&quot;k&quot;, ls=&quot;--&quot;, alpha=0.3) # 2. 算法参数估计 sorted_indices = sorted(range(b.n), key=lambda x: b.probas[x]) ax[1].plot(range(b.n), [b.probas[x] for x in sorted_indices], &quot;k--&quot;, markersize=12) for s in solvers: ax[1].plot( range(b.n), [s.estimated_probas[x] for x in sorted_indices], &quot;x&quot;, markeredgewidth=2, ) ax[1].set_xlabel(&quot;按收益率排序的老虎机&quot;) ax[1].set_ylabel(&quot;估计收益率&quot;) ax[1].grid(&quot;k&quot;, ls=&quot;--&quot;, alpha=0.3) # 3. for s in solvers: ax[2].plot( range(b.n), np.array(s.counts) / len(solvers[0].regrets), ls=&quot;steps&quot;, lw=2, ) ax[2].set_xlabel(&quot;老虎机&quot;) ax[2].set_ylabel(&quot;中奖占比&quot;) ax[2].grid(&quot;k&quot;, ls=&quot;--&quot;, alpha=0.3) plt.savefig(f&#39;5.data-recs/{figname}&#39;) def experiment(tag, b, K, N, test_solvers, names): &quot;&quot;&quot; 使用K个带随机收益率的老虎机进行N次试验 Parameters: K (int): 老虎机数量 N (int): 试验次数 &quot;&quot;&quot; print(f&quot;老虎机收益率: n{b.probas}&quot;) print(f&quot;最佳老虎机: {np.argmax(b.probas)} 收益率: {max(b.probas)}&quot;) for s in test_solvers: s.run(N) plot_results(test_solvers, names, f&quot;{tag}_K{K}_N{N}.png&quot;) . K = 10 b = Bandit(K) N = 20000 ids = [0, 0.02, 0.04, 0.06, 0.08, 1] test_solvers = [EpsilonGreedy(b, i) for i in ids] names = [f&quot;$ epsilon$-Greedy(b, {i})&quot; for i in ids] experiment(&quot;epsilon-Greedy&quot;, b, K, N, test_solvers, names) . 老虎机收益率: [0.63347486 0.14875777 0.27710719 0.95064444 0.01736183 0.08938155 0.95135302 0.85254521 0.68298702 0.50005527] 最佳老虎机: 6 收益率: 0.9513530154669764 . Thompson&#37319;&#26679; . Thompson采样（Thompson Sampling）1933提出，1997年学者开始使用它解决MAB问题。 . 由于Beta分布是伯努利分布的共轭先验分布，因此假设每个老虎机收益服从Beta(成功次数α, 失败次数β)先验分布，例如 . α = 1, β = 1：表示成功率50%，但不是很自信 | α = 1000, β = 9000：强烈认同成功率10% | 迭代步骤： . 每次从老虎机的Beta分布抽样，选择随机数最大的老虎机i计算收益， | 如果收益=1则，$ alpha_i= alpha_i+1$，否则收益=0, $ beta_i= beta_i+1$ | 缺点：计算后验分布困难，需要借助Gibbs采样、Laplace近似和bootstraps算法计算，参考教程 . class ThompsonSampling(Solver): def __init__(self, bandit, init_a=1, init_b=1): &quot;&quot;&quot; Parameters: init_a (int): Beta(a, b)初始参数a init_b (int): Beta(a, b)初始参数b &quot;&quot;&quot; super(ThompsonSampling, self).__init__(bandit) self._as = init_a * np.ones(self.bandit.n) self._bs = init_b * np.ones(self.bandit.n) @property def estimated_probas(self): return self._as / (self._as + self._bs) def run_one_step(self): i = np.argmax(np.random.beta(self._as, self._bs)) r = self.bandit.generate_reward(i) self._as[i] += r self._bs[i] += 1 - r return i . 随机探索让我们有机会探索未知arm。然而，这种肆意的随机性可能导致我们因为陷入一个收益差的老虎机而终止探索（陷入过拟合）。 . 因此，一种改进方法是随着时间增加而缩小ϵ，以降低随机性。另一种方式是优先探索不确定性高的老虎机（类似梯度下降法中使用Momentum摆脱局部最优解）， . UCB . UCB(Upper Confidence Bound，置信区间上界，2002年提出）算法持续跟踪每条臂试验累计的平均收益，并计算每条摇臂的UCB。UCB表明了我们对每条摇臂收益估计的不确定性。 . 如果有一个摇臂的上界非常高，那么说明这个摇臂潜力具有高度不确定性，因此选择手臂，也许说一个更佳的探索机会。 . . 虽然摇臂3取得的平均收益更高，但是UCB算法会选择摇臂2，因为它的潜力不确定性UCB更大。 . class UCB1(Solver): def __init__(self, bandit, init_proba=1): super(UCB1, self).__init__(bandit) self.t = 0 self.estimates = init_proba * np.ones(self.bandit.n) @property def estimated_probas(self): return self.estimates def run_one_step(self): self.t += 1 # 从置信区间上界选择最佳arm i = np.argmax(self.estimates + np.sqrt(2 * np.log(self.t) / (1 + self.counts))) r = self.bandit.generate_reward(i) self.estimates[i] += 1 / (self.counts[i] + 1) * (r - self.estimates[i]) return i . &#36125;&#21494;&#26031;UCB . class BayesianUCB(Solver): &quot;&quot;&quot;假设先验概率服从Beta分布&quot;&quot;&quot; def __init__(self, bandit, c=3, init_a=1, init_b=1): &quot;&quot;&quot; Parameters: c (float): 置信区间上界标准差扩展系数 init_a (int): Beta(a, b)参数a init_b (int): Beta(a, b)参数b &quot;&quot;&quot; super(BayesianUCB, self).__init__(bandit) self.c = c self._as = init_a * np.ones(self.bandit.n) self._bs = init_b * np.ones(self.bandit.n) @property def estimated_probas(self): return self._as / (self._as + self._bs) def run_one_step(self): i = np.argmax( self._as / (self._as + self._bs) + stats.beta.std(self._as, self._bs) * self.c ) r = self.bandit.generate_reward(i) # 更新后验分布 self._as[i] += r self._bs[i] += 1 - r return i . test_solvers = [ EpsilonGreedy(b, 0.01), UCB1(b), BayesianUCB(b, 3, 1, 1), ThompsonSampling(b, 1, 1), ] names = [ r&quot;$ epsilon$-Greedy&quot;, &quot;UCB1&quot;, &quot;贝叶斯UCB&quot;, &quot;Thompson采样&quot;, ] experiment(&quot;epsilon-Greedy&quot;, b, K, N, test_solvers, names) . 老虎机收益率: [0.63347486 0.14875777 0.27710719 0.95064444 0.01736183 0.08938155 0.95135302 0.85254521 0.68298702 0.50005527] 最佳老虎机: 6 收益率: 0.9513530154669764 . 然而，由于UCB算法未考虑用户关联特征(上下文)，包括用户的历史行为、人口统计信息等。因此， . 2010年，Yahoo!提出LinUCB，引入特征向量，对UCB进行改进，提升Yahoo!首页12.5%的点击量。github代码实现 | 2020年2月，美国康奈尔大学与阿里巴巴共同提出了PSLinUCB (Piecewise-Stationary LinUCB, AAAI20)，解决了LinUCB没有考虑用户兴趣会随着时间发生变化的问题。 | . LinUCB&#31034;&#20363; . MABWiser是一个MAB算法快速原型库。它支持上下文无关（context-free）、无参数上下文（non-parametric contextual，例如UCB1）、参数上下文（parametric contextual，例如LinUCB）bandit模型，支持训练和测试并行化、超参数调优、仿真等实用功能。 . . # Arms ads = [1, 2, 3, 4, 5] # 特征 train_df = pd.DataFrame({ &quot;ad&quot;: [1, 1, 1, 2, 4, 5, 3, 3, 2, 1, 4, 5, 3, 2, 5], &quot;revenues&quot;: [10, 17, 22, 9, 4, 20, 7, 8, 20, 9, 50, 5, 7, 12, 10], &quot;age&quot;: [22, 27, 39, 48, 21, 20, 19, 37, 52, 26, 18, 42, 55, 57, 38], &quot;click_rate&quot;: [0.2,0.6,0.99,0.68,0.15,0.23,0.75,0.17,0.33,0.65,0.56,0.22,0.19,0.11,0.83], &quot;subscriber&quot;: [1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0] }) train_df.head(7) . ad revenues age click_rate subscriber . 0 1 | 10 | 22 | 0.20 | 1 | . 1 1 | 17 | 27 | 0.60 | 0 | . 2 1 | 22 | 39 | 0.99 | 1 | . 3 2 | 9 | 48 | 0.68 | 0 | . 4 4 | 4 | 21 | 0.15 | 1 | . 5 5 | 20 | 20 | 0.23 | 0 | . 6 3 | 7 | 19 | 0.75 | 1 | . test_df = pd.DataFrame({&quot;age&quot;: [37, 52], &quot;click_rate&quot;: [0.5, 0.6], &quot;subscriber&quot;: [0, 1]}) test_df . age click_rate subscriber . 0 37 | 0.5 | 0 | . 1 52 | 0.6 | 1 | . # 标准化预处理 scaler = StandardScaler() train = scaler.fit_transform(train_df[[&quot;age&quot;, &quot;click_rate&quot;, &quot;subscriber&quot;]]) test = scaler.transform(test_df) . # LinUCB模型参数alpha=1.25 linucb = MAB(arms=ads, learning_policy=LearningPolicy.LinUCB(alpha=1.25)) # 基于历史广告点击和效益数据进行训练 linucb.fit(decisions=train_df[&quot;ad&quot;], rewards=train_df[&quot;revenues&quot;], contexts=train) # 预测展示的广告 prediction = linucb.predict(test) print(f&quot;LinUCB预测结果: {prediction}&quot;) . LinUCB预测结果: [5, 2] . # 每个arm的期望收益 pd.DataFrame.from_dict(linucb.predict_expectations(test)) . 1 2 3 4 5 . 0 -1.309401 | 0.105144 | -1.912977 | -10.291130 | 9.665161 | . 1 -4.524479 | 14.652897 | 4.524684 | -3.257354 | -8.684806 | . # 上一轮决策产生的真实收益 test_df_revenue = pd.Series([7, 13]) # 在线更新模型 linucb.partial_fit(decisions=prediction, rewards=test_df_revenue, contexts=test) # 增加arm linucb.add_arm(6) linucb.arms . [1, 2, 3, 4, 5, 6] . 参考资料: . 1.multi-armed bandit problem，MAB 2.The Multi-Armed Bandit Problem and Its Solutions 3.Bandit Algorithms for Website Optimization 4.Bandit 算法与推荐系统 5.Recommender systems using LinUCB: A contextual multi-armed bandit approach .",
            "url": "/Kivy/jupyter/python/data%20science/2020/07/08/data-recs.html",
            "relUrl": "/jupyter/python/data%20science/2020/07/08/data-recs.html",
            "date": " • Jul 8, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "Python数据科学分享——4.数理统计",
            "content": ". Probability theory is nothing but common sense reduced to calculation.——Pierre Laplace, 1812 . 概率论就是把（不确定性）常识精简成计算——皮埃尔·拉普拉斯 . 统计定义： . “A branch of mathematics dealing with the collection, analysis, interpretation, and presentation of masses of numerical data.”(Webster&#39;s International Dictionary) | “The science and art of collecting, summarizing, and analyzing data that are subject to random variation.” (A Dictionary of Epidemiology). | 处理数据中变异性的科学与艺术——方积乾（中国统计学学家、中山大学教授） | Python&#27010;&#29575;&#32534;&#31243; . (Probabilistic programming) . 首发年份 名称 简介 . scipy.stats | 2001 | Scipy概率与统计模块 | . PyMC | 2009 | 纯Python概率编程库(PyMC3基于Theano) | . emcee | 2010 | MCMC采样器库 | . pystan | 2013 | 基于Stan(C++)的概率编程库 | . pomegranate | 2014 | Cython实现的随机模型库 | . ArviZ | 2015 | 贝叶斯推断（模型无关）统一接口 | . edward | 2016 | 基于Tensorflow的概率编程语言(edward2, 2019) | . tf-probability | 2016 | 基于Tensorflow的概率编程库 | . pyro | 2017 | 基于PyTorch的概率编程库 | . numpyro | 2019 | 基于Nympy+JAX的概率编程库 | . 《统计计算》 李东风(北京大学数学科学学院 副教授) . # %matplotlib widget from matplotlib.font_manager import _rebuild _rebuild() import matplotlib.pyplot as plt import seaborn as sns sns.set_style(&quot;whitegrid&quot;, {&quot;font.sans-serif&quot;: [&quot;SimHei&quot;, &quot;Arial&quot;]}) import matplotlib as mpl mpl.rcParams[&quot;figure.max_open_warning&quot;] = 0 import warnings warnings.filterwarnings(&quot;ignore&quot;) import numpy as np import pandas as pd pd.set_option(&quot;display.max_rows&quot;, 100) import scipy from scipy import stats import pymc3 as pm import tensorflow as tf import tensorflow_probability as tfp from tensorflow_probability import edward2 as ed . &#27010;&#29575;&#22522;&#30784; . 以下介绍取自美国布朗大学《看见统计》，中文版bug多，而且前端资源网络问题，调整了一下放在服务器上运行 . 推荐视频教程浙江大学概率论与数理统计，概率论与数理统计--习题与案例分析 . &#22522;&#26412;&#27010;&#24565; . 随机事件 / 期望 / 方差 . &#21476;&#20856;&#27010;&#22411; . 集合论 / 古典概型 / 条件概率 . &#27010;&#29575;&#20998;&#24067; . 随机变量 / 离散型和连续型随机变量 / 中心极限定理 . &#32479;&#35745;&#25512;&#26029;&#65306;&#39057;&#29575;&#23398;&#27966; . 点估计理论 / 置信区间 / Bootstrap方法 . &#32479;&#35745;&#25512;&#26029;&#65306;&#36125;&#21494;&#26031;&#23398;&#27966; . 贝叶斯公式 / 似然函数 / 从先验概率到后验概率 . &#22238;&#24402;&#20998;&#26512; . 最小二乘法 / 相关性 / 方差分析 . &#25512;&#26029;(inference)&#19982;&#39044;&#27979;(prediction) . 对比 推断 预测 . 模型选择 | 对数据产生过程进行归因（Reason）,选择假设最合理的模型 | 对各种模型进行评估,选择性能最优的模型 | . 模型验证 | 拟合优度检验（goodneess-of-fit tests） | 通过测试集的损失表现验证 | . 模型应用 | 解释数据产生的过程 | 预测新特征的结果 | . 统计日常 | 咋了？啥样？为啥？ | 让我们期待明天会更好 | . scipy.stats . scipy统计学模块，包括常见统计分布、极大似然估计、置信区间、假设检验等统计方法 . numpy.random&#38543;&#26426;&#20998;&#24067; . &#22343;&#21248;&#20998;&#24067;&#65288;Standard uniform&#65289; . np.random.seed(1024) np.random.rand(3, 4) . array([[0.64769123, 0.99691358, 0.51880326, 0.65811273], [0.59906347, 0.75306733, 0.13624713, 0.00411712], [0.14950888, 0.698439 , 0.59335256, 0.89991535]]) . &#26631;&#20934;&#27491;&#24577;&#20998;&#24067;&#65288;Standard normal&#65289; . np.random.randn(3, 4) . array([[-1.87529904, -0.56850693, -0.06510141, 0.80681666], [-0.5778176 , 0.57306064, -0.33667496, 0.29700734], [-0.37480416, 0.15510474, 0.70485719, 0.8452178 ]]) . &#24102;&#37197;&#32622;&#21442;&#25968;&#30340;&#20998;&#24067; . &#31163;&#25955;&#22411;&#20998;&#24067; . np.random.poisson(lam=10, size=(10,)) . array([13, 8, 9, 7, 14, 9, 8, 11, 11, 9]) . np.random.binomial(n=10, p=0.6, size=(10,)) . array([5, 5, 8, 4, 6, 6, 6, 6, 8, 4]) . np.random.negative_binomial(n=10, p=0.6, size=(10,)) . array([ 5, 7, 9, 14, 15, 6, 14, 7, 9, 7]) . np.random.geometric(p=0.6, size=(10,)) . array([3, 3, 6, 1, 1, 3, 1, 2, 1, 1]) . &#36830;&#32493;&#20998;&#24067; . np.random.uniform(low=-1, high=1, size=(3, 4)) . array([[ 0.88169829, -0.97506843, -0.3934696 , 0.27655528], [ 0.60227603, -0.77024602, -0.40896008, 0.5647249 ], [ 0.95862598, -0.66679706, 0.77273023, 0.14810595]]) . np.random.normal(loc=100, scale=15, size=(3, 4)) . array([[113.23731981, 101.39008994, 87.03052898, 61.86347929], [111.61655881, 82.21339344, 102.73634972, 87.05919982], [107.51795522, 121.83893846, 94.13730255, 111.72173917]]) . np.random.standard_t(df=3, size=(3, 4)) . array([[-0.22458417, -0.72277945, 0.49479094, 4.08936976], [ 0.09470278, -0.42810122, 2.73248456, -0.27440016], [ 0.04688723, -1.85904818, -2.00913033, -1.51370431]]) . np.random.beta(a=0.5, b=0.5, size=(10,)) . array([0.67257261, 0.0744057 , 0.35638654, 0.37640555, 0.75432552, 0.25481084, 0.47389881, 0.99394393, 0.04577132, 0.15859972]) . &#22810;&#21464;&#37327;&#20998;&#24067; . np.random.multinomial(n=4, pvals=[0.1, 0.2, 0.3, 0.4], size=5) . array([[0, 0, 2, 2], [1, 1, 0, 2], [0, 0, 1, 3], [0, 0, 0, 4], [0, 2, 1, 1]]) . np.random.multivariate_normal(mean=[10, 10], cov=np.array([[3, 0.5], [0.5, 2]]), size=5) . array([[ 9.73763159, 9.49225394], [11.40208466, 10.01617814], [ 8.35730988, 11.13369124], [ 9.82584874, 10.64592839], [ 9.21820763, 9.10287525]]) . scipy.stats&#32479;&#35745;&#20989;&#25968; . 假设智商(IQ)服从均值为100、标准差为15的正态分布 . dist = stats.norm(loc=100, scale=15) dist . &lt;scipy.stats._distn_infrastructure.rv_frozen at 0x7f5a9232c510&gt; . &#29983;&#25104;&#38543;&#26426;&#21464;&#37327; . dist.rvs(10) . array([ 92.66369207, 75.57944739, 134.27787431, 101.97179807, 111.14296519, 120.19113585, 113.88208261, 116.91381411, 95.80518317, 110.87883135]) . xs = np.linspace(50, 150, 100) fig, ax = plt.subplots(2, 2, figsize=(12, 6)) fig.subplots_adjust(hspace=0.5, wspace=0.2) ax[0, 0].plot(xs, dist.pdf(xs)) # PDF ax[0, 0].set_title(&quot;PDF&quot;) ax[0, 1].plot(xs, dist.cdf(xs)) # CDF ax[0, 1].set_title(&quot;CDF&quot;) cdf = np.linspace(0, 1, 100) ax[1, 0].plot(cdf, dist.ppf(cdf)) # P-P图 ax[1, 0].set_title(&quot;P-P图&quot;) stats.probplot(dist.rvs(100_000), plot=ax[1, 1]) ax[1, 1].set_title(&quot;Q-Q图&quot;); . &#32479;&#35745;&#26085;&#24120; . 1. 姚明智商132分，有多少人智商比他高？ . . dist = stats.norm(loc=100, scale=15) . print(f&quot;超过姚明智商的人数为：{100 * (1 - dist.cdf(132)):.3f}%&quot;) . 超过姚明智商的人数为：1.645% . # 仿真方法：随机抽取1亿人，统计比姚明IQ高的人数占比 n = int(1e8) samples = dist.rvs(n) . print(f&quot;超过姚明智商的人数为：{100 * np.sum(samples &gt; 132) / n:.3f}%&quot;) . 超过姚明智商的人数为：1.646% . 2. 有人说爱因斯坦的IQ是千里挑一，那么他的IQ是多少? . . 推荐：《上帝掷骰子吗:量子物理史话》——像武侠小说一样精彩的量子力学科普 . dist.ppf(0.999) . 146.3534845925172 . # 仿真方法 samples = np.sort(samples) samples[int(0.999 * n)] . 146.3653368563009 . 3. IQ在(70, 90]区间的人有多少? . print(f&quot;IQ在(70, 90]区间的人数占比为：{100 * dist.cdf(90) - dist.cdf(70):.2f}%&quot;) . IQ在(70, 90]区间的人数占比为：25.23% . # 仿真方法 np.sum((samples &gt; 70) &amp; (samples &lt; 90)) / n . 0.22976765 . 4. 测试了100个用户的IQ样本，计算参数$ mu$和$ sigma$的极大似然估计（MLE），以及$ mu$的95%置信区间 . data = np.random.normal(110, 15, 100) . loc, scale = stats.norm.fit(data) loc, scale . (111.18547994292243, 15.446518813564095) . dist = stats.norm(loc, scale) . 95%置信区间 . itv95 = dist.interval(0.95) itv95 . (80.91085938181644, 141.46010050402842) . fig, ax = plt.subplots(figsize=(12,6)) xs = np.linspace(data.min(), data.max(), 100) ax.hist(data, 12, histtype=&quot;stepfilled&quot;, density=True, alpha=0.5) ax.plot(xs, dist.pdf(xs)) ax.plot(itv95, [0.001, 0.001], c=&quot;r&quot;, linewidth=3); . PyMC . Python的概率编程库，包括贝叶斯统计建模与概率模型，MCMC采样与变分推断。其中，pymc3基于Theano实现，pymc4(Pre-release)基于TensorFlow Probability实现，开源教程Python概率编程与贝叶斯方法 . pd.Series([d for d in dir(pm.distributions) if d[0].isupper()]) . 0 AR 1 AR1 2 Bernoulli 3 Beta 4 BetaBinomial 5 Binomial 6 Bound 7 Categorical 8 Cauchy 9 ChiSquared 10 Constant 11 ConstantDist 12 Continuous 13 DensityDist 14 Dirichlet 15 Discrete 16 DiscreteUniform 17 DiscreteWeibull 18 Distribution 19 ExGaussian 20 Exponential 21 Flat 22 GARCH11 23 Gamma 24 GaussianRandomWalk 25 Geometric 26 Gumbel 27 HalfCauchy 28 HalfFlat 29 HalfNormal 30 HalfStudentT 31 Interpolated 32 InverseGamma 33 KroneckerNormal 34 Kumaraswamy 35 LKJCholeskyCov 36 LKJCorr 37 Laplace 38 Logistic 39 LogitNormal 40 Lognormal 41 MatrixNormal 42 Mixture 43 Multinomial 44 MvGaussianRandomWalk 45 MvNormal 46 MvStudentT 47 MvStudentTRandomWalk 48 NegativeBinomial 49 NoDistribution 50 Normal 51 NormalMixture 52 OrderedLogistic 53 Pareto 54 Poisson 55 Rice 56 Simulator 57 SkewNormal 58 StudentT 59 TensorType 60 Triangular 61 TruncatedNormal 62 Uniform 63 VonMises 64 Wald 65 Weibull 66 Wishart 67 WishartBartlett 68 ZeroInflatedBinomial 69 ZeroInflatedNegativeBinomial 70 ZeroInflatedPoisson dtype: object . 分布函数 . d = pm.Normal.dist(mu=0, sd=1) . d.dist() . $ text{None} sim text{Normal}( mathit{mu}=0.0,~ mathit{sigma}=1.0)$ 随机采样 . d.random(size=5) . array([-0.33071042, -1.03612079, -0.34140955, -0.07609122, -0.74469107]) . 对数概率——适用于各种极大似然估计场景 . d.logp(0).eval() . array(-0.91893853) . A/B&#27979;&#35797; . 假设实验A点击率（点击用户数/总曝光用户数）是0-1均匀分布 . with pm.Model() as model: p = pm.Uniform(&#39;p&#39;, lower=0, upper=1) . p . $ text{p} sim text{Uniform}( mathit{lower}=0.0,~ mathit{upper}=1.0)$ 按照多重伯努利实验抽样$X sim text{Ber}(p)$ . p_true = 0.05 # 真实点击率 N = 1500 occurrences = stats.bernoulli.rvs(p_true, size=N) occurrences . array([1, 1, 1, ..., 0, 0, 0]) . np.sum(occurrences) . 81 . 实验A的点击率 . np.mean(occurrences) . 0.054 . np.mean(occurrences) == p_true . False . 将样本传入PyMC3的observed变量 . with model: obs = pm.Bernoulli(&quot;obs&quot;, p, observed=occurrences) step = pm.Metropolis() trace = pm.sample(18000, step=step) burned_trace = trace[1000:] . Multiprocess sampling (4 chains in 4 jobs) Metropolis: [p] Sampling 4 chains, 0 divergences: 100%|██████████| 74000/74000 [00:11&lt;00:00, 6576.51draws/s] The number of effective samples is smaller than 25% for some parameters. . $p_A$的后验分布如下： . fig = plt.figure(figsize=(12,6)) plt.title(&quot;$p_A$后验分布&quot;) plt.vlines(p_true, 0, 90, linestyle=&quot;--&quot;, label=&quot;$p_A$真实值&quot;) plt.hist(burned_trace[&quot;p&quot;], bins=25, histtype=&quot;stepfilled&quot;, density=True) plt.legend(); . &#23454;&#39564;A VS &#23454;&#39564;B . 我们需要对比实验A和实验B的差异，假设 . 实验A样本量1500，真实点击率$p_A=0.05$ | 实验B样本量750，真实点击率$p_B=0.04$ | 两组实验差异$ text{delta} = p_A - p_B = 0.01$ | 贝叶斯推断对样本量差异不敏感 . true_p_A = 0.05 true_p_B = 0.04 N_A = 1500 N_B = 750 observations_A = stats.bernoulli.rvs(true_p_A, size=N_A) observations_B = stats.bernoulli.rvs(true_p_B, size=N_B) print(f&quot;实验A: {observations_A[:30]}...&quot;) print(f&quot;实验B: {observations_B[:30]}...&quot;) . 实验A: [0 0 0 0 0 0 0 0 0 1 0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0]... 实验B: [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0]... . np.mean(observations_A), np.mean(observations_B) . (0.04933333333333333, 0.044) . with pm.Model() as model: p_A = pm.Uniform(&quot;p_A&quot;, 0, 1) p_B = pm.Uniform(&quot;p_B&quot;, 0, 1) delta = pm.Deterministic(&quot;delta&quot;, p_A - p_B) obs_A = pm.Bernoulli(&quot;obs_A&quot;, p_A, observed=observations_A) obs_B = pm.Bernoulli(&quot;obs_B&quot;, p_B, observed=observations_B) step = pm.Metropolis() trace = pm.sample(20000, step=step) burned_trace = trace[1000:] . Multiprocess sampling (4 chains in 4 jobs) CompoundStep &gt;Metropolis: [p_B] &gt;Metropolis: [p_A] Sampling 4 chains, 0 divergences: 100%|██████████| 82000/82000 [00:15&lt;00:00, 5137.09draws/s] The number of effective samples is smaller than 25% for some parameters. . 三个随机变量的后验分布: . p_A_samples = burned_trace[&quot;p_A&quot;] p_B_samples = burned_trace[&quot;p_B&quot;] delta_samples = burned_trace[&quot;delta&quot;] . fig = plt.figure(figsize=(15, 10)) fig.subplots_adjust(hspace=0.5) ax = plt.subplot(311) plt.xlim(0, 0.1) plt.hist( p_A_samples, histtype=&quot;stepfilled&quot;, bins=25, alpha=0.85, label=&quot;$p_A$后验&quot;, color=&quot;#A60628&quot;, density=True, ) plt.vlines(true_p_A, 0, 80, linestyle=&quot;--&quot;, label=&quot;$p_A$真实值&quot;) plt.legend(loc=&quot;upper right&quot;) plt.title(&quot;$p_A$, $p_B$和delta后验分布&quot;) ax = plt.subplot(312) plt.xlim(0, 0.1) plt.hist( p_B_samples, histtype=&quot;stepfilled&quot;, bins=25, alpha=0.85, label=&quot;$p_B$后验&quot;, color=&quot;#467821&quot;, density=True, ) plt.vlines(true_p_B, 0, 80, linestyle=&quot;--&quot;, label=&quot;$p_B$真实值&quot;) plt.legend(loc=&quot;upper right&quot;) ax = plt.subplot(313) plt.hist( delta_samples, histtype=&quot;stepfilled&quot;, bins=25, alpha=0.85, label=&quot;delta后验&quot;, color=&quot;#7A68A6&quot;, density=True, ) plt.vlines(true_p_A - true_p_B, 0, 60, linestyle=&quot;--&quot;, label=&quot;delta真实值&quot;) plt.vlines(0, 0, 60, color=&quot;black&quot;, alpha=0.2) plt.legend(loc=&quot;upper right&quot;); . fig.savefig(&quot;AB_test.png&quot;) . 实验A样本量N_A = 1500大于实验B样本量N_B = 750，因此$p_B$的后验分布比$p_A$的后验分布宽，说明$p_B$不确定性比$p_A$高。 . &#23454;&#39564;&#32467;&#35770; . $ text{delta}$的后验分布大多数&gt;0，因此可以推断实验A效果大概率比实验B效果好。 . 实验A比实验B效果差的概率： . np.mean(delta_samples &lt; 0) . 0.29823684210526313 . 实验A比实验B效果好的概率： . np.mean(delta_samples &gt; 0) . 0.7017631578947369 . &#39640;&#26031;&#36807;&#31243;&#22238;&#24402; . （Gaussian Process Regression，GPR） . 假设从正态分布抽样一组带噪声 $ epsilon$ 的样本 . $$ y sim mathcal{N}( mu = f(x), sigma= epsilon) $$对于线性回归问题 $f(x) = ax + b$ . 高斯过程可以给出先验分布 $f$ . $$ f(x) sim mathcal{GP}( mu_x, K(x, x^T, h)) $$其中，$ mu_x$是函数均值，$K(x, x^T)$是核函数的协方差矩阵，$h$是数据平滑参数 . 高斯过程可以生成任意曲线（曲面），必要条件是噪声能够近似成高斯分布，经典的线性回归模型都可以看作是高斯过程模型。 . &#29983;&#25104;&#27169;&#22411;&#31034;&#20363; . def gauss_kernel(x, knots, h): return np.array([np.exp(-((x - k) ** 2) / (2 * h ** 2)) for k in knots]) plt.figure(figsize=(16, 4)) hs = [0.05, 0.1, 0.5, 1] x = np.linspace(0, 1, 20) for i, h in enumerate(hs): plt.subplot(1, 4, i + 1) for j in range(3): plt.plot(x, stats.multivariate_normal.rvs(cov=gauss_kernel(x, x, h))) plt.title(&quot;h = %.2f&quot; % h) plt.tight_layout() . &#27169;&#22411;&#31034;&#20363; . n = 20 xs = np.r_[ np.linspace(0, 0.5 * np.pi, 8), np.linspace(0.5 * np.pi, 1.5 * np.pi, 4), np.linspace(1.5 * np.pi, 2 * np.pi, 8), ] ys = np.sin(xs) + np.random.normal(0, 0.2, n) xp = np.c_[np.linspace(0, 2 * np.pi, 100)] . fig = plt.figure(figsize=(12, 4)) ax = plt.axes() ax.scatter(xs, ys) ax.plot(xp, np.sin(xp)); . with pm.Model() as gp_context: h = pm.Gamma(&quot;h&quot;, 2, 0.5) c = pm.gp.cov.ExpQuad(1, ls=h) gp = pm.gp.Marginal(cov_func=c) ϵ = pm.HalfCauchy(&quot;e&quot;, 1) y_est = gp.marginal_likelihood(&quot;y_est&quot;, X=np.c_[xs], y=ys, noise=ϵ) . fig, ax = plt.subplots(2, 1, figsize=(12, 8)) xa = np.linspace(0, 20, 200) alphas = [1.0, 2.0, 3.0, 7.5] betas = [0.5, 0.5, 1.0, 1.0] for a, b in zip(alphas, betas): pdf = stats.gamma.pdf(xa, a, scale=1.0 / b) ax[0].plot(xa, pdf, label=r&quot;$ alpha$ = {}, $ beta$ = {}&quot;.format(a, b)) ax[0].set_xlabel(&quot;x&quot;, fontsize=12) ax[0].set_ylabel(&quot;f(x)&quot;, fontsize=12) ax[0].legend(loc=1) xa = np.linspace(0, 5, 200) for b in [0.5, 1.0, 2.0]: pdf = stats.cauchy.pdf(xa, scale=b) ax[1].plot(xa, pdf, label=r&quot;$ beta$ = {}&quot;.format(b)) ax[1].set_xlabel(&quot;x&quot;, fontsize=12) ax[1].set_ylabel(&quot;f(x)&quot;, fontsize=12) ax[1].legend(loc=1); . fig.show() . &lt;matplotlib.legend.Legend at 0x7f5a56da6350&gt; . with gp_context: trace = pm.sample(tune=1000) . Auto-assigning NUTS sampler... Initializing NUTS using jitter+adapt_diag... Multiprocess sampling (4 chains in 4 jobs) NUTS: [e, h] Sampling 4 chains, 0 divergences: 100%|██████████| 6000/6000 [00:04&lt;00:00, 1338.14draws/s] . pm.traceplot(trace,figsize=(16, 6)); . with gp_context: fp = gp.conditional(&quot;fp&quot;, xp) ppc = pm.sample_posterior_predictive(trace, vars=[fp], samples=100) . 100%|██████████| 100/100 [00:07&lt;00:00, 13.40it/s] . fig, ax = plt.subplots(2, 1, figsize=(12, 6)) ax[0].plot(xp, ppc[&quot;fp&quot;].T, c=&quot;grey&quot;, alpha=0.1) ax[0].scatter(xs, ys, c=&quot;red&quot;) pm.gp.util.plot_gp_dist(ax[1], ppc[&quot;fp&quot;], xp, palette=&quot;cool&quot;) fig.show(); . tesnorflow.probability . 基于tesnorflow的贝叶斯推断和统计分析库 . &#38543;&#26426;&#20998;&#24067; . tfd = tfp.distributions . pd.Series([str(x).split(&quot;.&quot;)[-1][:-2] for x in tfd.distribution.Distribution.__subclasses__()]) . 0 Autoregressive 1 BatchReshape 2 Bernoulli 3 Beta 4 Gamma 5 Binomial 6 BetaBinomial 7 JointDistribution 8 JointDistribution 9 _Cast 10 Blockwise 11 Categorical 12 Cauchy 13 Chi2 14 TransformedDistribution 15 Normal 16 LKJ 17 CholeskyLKJ 18 _BaseDeterministic 19 _BaseDeterministic 20 Dirichlet 21 Multinomial 22 DirichletMultinomial 23 DoublesidedMaxwell 24 Empirical 25 FiniteDiscrete 26 GammaGamma 27 GaussianProcess 28 GeneralizedPareto 29 Geometric 30 Uniform 31 HalfCauchy 32 HalfNormal 33 StudentT 34 HalfStudentT 35 HiddenMarkovModel 36 Horseshoe 37 Independent 38 InverseGamma 39 InverseGaussian 40 Laplace 41 LinearGaussianStateSpaceModel 42 Logistic 43 Mixture 44 MixtureSameFamily 45 MultivariateStudentTLinearOperator 46 NegativeBinomial 47 OneHotCategorical 48 OrderedLogistic 49 Pareto 50 PERT 51 QuantizedDistribution 52 Poisson 53 _TensorCoercible 54 PixelCNN 55 PlackettLuce 56 PoissonLogNormalQuadratureCompound 57 ProbitBernoulli 58 RelaxedBernoulli 59 ExpRelaxedOneHotCategorical 60 Sample 61 StudentTProcess 62 Triangular 63 TruncatedNormal 64 VectorDiffeomixture 65 VonMises 66 VonMisesFisher 67 WishartLinearOperator 68 Zipf dtype: object . dist = tfd.Normal(loc=100, scale=15) . x = dist.sample((3, 4)) x . &lt;tf.Tensor: shape=(3, 4), dtype=float32, numpy= array([[ 94.99498 , 107.465 , 92.16038 , 119.55264 ], [105.00224 , 99.26422 , 106.99145 , 73.55863 ], [105.61177 , 92.737144, 121.1416 , 90.87714 ]], dtype=float32)&gt; . n = 100 fig, ax = plt.subplots(figsize=(12, 6)) xs = dist.sample(n) ax.hist(xs, density=True) xp = tf.linspace(50.0, 150.0, 100) ax.plot(xp, dist.prob(xp)); . &#38543;&#26426;&#37319;&#26679; . dist = tfd.Normal(loc=[3, 4, 5, 6], scale=0.5) . dist.sample(5) . &lt;tf.Tensor: shape=(5, 4), dtype=float32, numpy= array([[2.325097 , 4.3809695, 6.011235 , 6.6105776], [2.8294497, 4.795865 , 4.3433237, 5.784731 ], [3.8394353, 3.9012687, 4.900641 , 5.8869133], [2.7562547, 3.839128 , 4.772919 , 6.0769143], [2.497485 , 4.127298 , 4.343773 , 5.853659 ]], dtype=float32)&gt; . xp = tf.linspace(0.0, 9.0, 100)[:, tf.newaxis] fig = plt.figure(figsize=(12, 6)) plt.plot(np.tile(xp, dist.batch_shape), dist.prob(xp)); . &#39640;&#26031;&#28151;&#21512;&#27169;&#22411; . gmm = tfd.MixtureSameFamily( mixture_distribution=tfd.Categorical(probs=[0.4, 0.1, 0.2, 0.3]), components_distribution=tfd.Normal( loc=[3.0, 4.0, 5.0, 6.0], scale=[0.1, 0.5, 0.5, 0.1] ), ) xs = gmm.sample(10000) . fig = plt.figure(figsize=(12, 6)) sns.distplot(xs); . TFP&#39640;&#26031;&#36807;&#31243;&#22238;&#24402; . xs = tf.Variable([0.0, 1.0, 2.0, 5.0, 6.0, 8.0]) ys = tf.sin(xs) + tfd.Normal(loc=0, scale=0.5).sample(xs.shape[0]) xp = tf.linspace(-1.0, 9.0, 100)[:, None] . kernel = tfp.math.psd_kernels.ExponentiatedQuadratic(length_scale=1.5) reg = tfd.GaussianProcessRegressionModel( kernel, xp[:, tf.newaxis], xs[:, tf.newaxis], ys ) . ub, lb = reg.mean() + [2 * reg.stddev(), -2 * reg.stddev()] fig, ax = plt.subplots(figsize=(12, 6)) ax.fill_between(np.ravel(xp), np.ravel(ub), np.ravel(lb), alpha=0.2) ax.plot(xp, reg.mean(), c=&quot;red&quot;, linewidth=2) ax.scatter(xs[:], ys[:], s=50, c=&quot;k&quot;); . Edward2 . Edward2是谷歌推出的简单概率编程语言，基于NumPy和TensorFlow生态系统构建，可以将模型编写为概率模块与模型计算结合，从而实现灵活的训练和推理。 . Edward2借助GPU提升计算性能，谷歌使用NUTS(No-U-Turn Sampler, HMC变体)采样实现贝叶斯逻辑回归（Bayesian logistic regression）的运行时间对比。 . 模块 运行时间 (ms) . Stan (CPU) | 201.0 | . PyMC3 (CPU) | 74.8 | . Handwritten TF (CPU) | 66.2 | . Edward2 (CPU) | 68.4 | . Handwritten TF (1 GPU) | 9.5 | . Edward2 (1 GPU) | 9.7 | . Edward2 (8 GPU) | 2.3 | . &#38543;&#26426;&#21464;&#37327; . normal_rv = ed.Normal(loc=0., scale=1.) normal_rv . &lt;ed.RandomVariable &#39;Normal&#39; shape=() dtype=float32 numpy=-0.8224109&gt; . normal_rv.distribution.log_prob(1.231) . &lt;tf.Tensor: shape=(), dtype=float32, numpy=-1.6766189&gt; . dirichlet_rv = ed.Dirichlet(concentration=tf.ones([2, 10])) dirichlet_rv . &lt;ed.RandomVariable &#39;Dirichlet&#39; shape=(2, 10) dtype=float32 numpy= array([[0.31023756, 0.07827895, 0.08835499, 0.03265208, 0.04359685, 0.02597943, 0.07192924, 0.15645337, 0.025865 , 0.16665252], [0.31551656, 0.08522676, 0.1547178 , 0.10970751, 0.06513554, 0.03616604, 0.02903147, 0.1352999 , 0.01480891, 0.05438948]], dtype=float32)&gt; . &#22522;&#26412;&#25805;&#20316; . x = ed.Normal(loc=tf.zeros(20), scale=tf.ones(20)); x . &lt;ed.RandomVariable &#39;Normal&#39; shape=(20,) dtype=float32 numpy= array([ 0.7987103 , 0.14509809, 0.8323622 , 0.29810244, 0.08135905, -0.49820969, -1.5680871 , 0.9793448 , 0.8511595 , 1.2923892 , -0.16361478, 0.61047137, 0.21112299, 0.20411171, -1.4496089 , 0.95102966, 0.83335084, 0.7262526 , 0.03912232, -1.5042037 ], dtype=float32)&gt; . y = 5; x + y, x / y . (&lt;tf.Tensor: shape=(20,), dtype=float32, numpy= array([5.7987103, 5.145098 , 5.832362 , 5.2981024, 5.081359 , 4.5017905, 3.431913 , 5.979345 , 5.8511596, 6.292389 , 4.8363853, 5.6104712, 5.211123 , 5.2041116, 3.5503912, 5.95103 , 5.8333507, 5.7262526, 5.039122 , 3.4957962], dtype=float32)&gt;, &lt;tf.Tensor: shape=(20,), dtype=float32, numpy= array([ 0.15974206, 0.02901962, 0.16647243, 0.05962049, 0.01627181, -0.09964193, -0.3136174 , 0.19586895, 0.17023191, 0.25847784, -0.03272296, 0.12209427, 0.0422246 , 0.04082234, -0.2899218 , 0.19020593, 0.16667017, 0.14525053, 0.00782446, -0.30084074], dtype=float32)&gt;) . tf.tanh(x * y) . &lt;tf.Tensor: shape=(20,), dtype=float32, numpy= array([ 0.99932045, 0.6202987 , 0.99951476, 0.90341896, 0.38574815, -0.9863742 , -0.99999964, 0.9998883 , 0.9995977 , 0.99999523, -0.6740202 , 0.99554545, 0.7839798 , 0.770094 , -0.99999905, 0.9998518 , 0.99951935, 0.9985982 , 0.19315422, -0.9999994 ], dtype=float32)&gt; . base = tf.range(20) fig, ax = plt.subplots(figsize=(12, 6)) ax.scatter(base[:], x[:], c=&quot;r&quot;, label=&quot;x&quot;) ax.scatter(base[:], (x + y)[:], c=&quot;g&quot;, label=&quot;x + y&quot;) ax.scatter(base[:], (x / y)[:], c=&quot;b&quot;, label=&quot;x / y&quot;) ax.scatter(base[:], tf.tanh(x * y)[:], c=&quot;k&quot;, label=&quot;tf.tanh(x * y)&quot;) ax.set_ylim(-5, 10) ax.legend(loc=&#39;upper right&#39;); .",
            "url": "/Kivy/jupyter/python/data%20science/2020/06/08/data-stats.html",
            "relUrl": "/jupyter/python/data%20science/2020/06/08/data-stats.html",
            "date": " • Jun 8, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "Python数据科学分享——3.数据可视化(2)",
            "content": "%load_ext autoreload %autoreload 2 %matplotlib inline from matplotlib.font_manager import _rebuild _rebuild() import matplotlib.pyplot as plt import seaborn as sns sns.set_style(&quot;whitegrid&quot;, {&quot;font.sans-serif&quot;: [&quot;SimHei&quot;, &quot;Arial&quot;]}) import pandas_alive import pandas as pd import numpy as np import ssl ssl._create_default_https_context = ssl._create_unverified_context iris = sns.load_dataset(&quot;iris&quot;) tips = sns.load_dataset(&quot;tips&quot;) . df_covid = pd.read_json(&quot;3.data-viz/timeseries.json&quot;) df_covid.index = pd.DatetimeIndex(df_covid.iloc[:, 0].apply(lambda _: _[&quot;date&quot;])) df_covid.index.name = &quot;日期&quot; df_covid = df_covid.applymap(lambda _: int(_[&quot;confirmed&quot;])) df_covid.replace(0, np.nan, inplace=True) top20 = df_covid.iloc[-1].sort_values().tail(20).index df_covid = df_covid[top20] . seaborn&#32479;&#35745;&#22270; . 面朝大海，春暖花开——海子（原名查海生，1964-1989，安徽安庆市怀宁县人） . 2012年，美国斯坦福大学（Stanford）Michael Waskom（目前就职纽约大学NYU）用高级接口在Matplotlib基础上为数据探索和模型拟合创建各种统计图 . &#39057;&#27425;&#30452;&#26041;&#22270;&#12289;KDE&#22270; . data = np.random.multivariate_normal(mean=[0, 0], cov=[[5, 2], [2, 2]], size=2000) data = pd.DataFrame(data, columns=[&quot;x&quot;, &quot;y&quot;]) . plt.figure(figsize=(6, 6)) for col in &quot;xy&quot;: plt.hist(data[col], density=True, alpha=0.5) . 除了频次直方图，我们还可以用KDE获取变量的平滑分布估计图。Seaborn通过sns.kdeplot实现： . plt.figure(figsize=(6, 6)) for col in &quot;xy&quot;: sns.kdeplot(data[col], shade=True) . 用sns.distplot可以让频次直方图与KDE叠加： . plt.figure(figsize=(6, 6)) for col in &quot;xy&quot;: sns.distplot(data[col]) . 如果向kdeplot输入的是二维数据集，那么就可以获得一个二维数据可视化图： . plt.figure(figsize=(6, 6)) sns.kdeplot(data.x, data.y); . 用sns.jointplot可以同时看到两个变量的联合分布与单变量分布： . with sns.axes_style(&quot;white&quot;): sns.jointplot(&quot;x&quot;, &quot;y&quot;, data, kind=&quot;kde&quot;) . 可以向jointplot函数传递一些参数。例如，可以用六边形块代替频次直方图： . with sns.axes_style(&quot;white&quot;): sns.jointplot(&quot;x&quot;, &quot;y&quot;, data, kind=&quot;hex&quot;) . &#30697;&#38453;&#22270;&#65288;pair plot&#65289; . 用sns.pairplot探索多维数据不同维度间的相关性，例如费舍尔鸢尾花数据集记录了3种鸢尾花的花瓣与花萼数据： . sns.pairplot(iris, hue=&quot;species&quot;); . &#20998;&#38754;&#39057;&#27425;&#30452;&#26041;&#22270; . sns.FacetGrid获取数据子集的频次直方图。例如，饭店服务员收小费的数据集： . tips[&quot;tip_pct&quot;] = 100 * tips[&quot;tip&quot;] / tips[&quot;total_bill&quot;] tips.head() . total_bill tip sex smoker day time size tip_pct . 0 16.99 | 1.01 | Female | No | Sun | Dinner | 2 | 5.944673 | . 1 10.34 | 1.66 | Male | No | Sun | Dinner | 3 | 16.054159 | . 2 21.01 | 3.50 | Male | No | Sun | Dinner | 3 | 16.658734 | . 3 23.68 | 3.31 | Male | No | Sun | Dinner | 2 | 13.978041 | . 4 24.59 | 3.61 | Female | No | Sun | Dinner | 4 | 14.680765 | . grid = sns.FacetGrid(tips, row=&quot;sex&quot;, col=&quot;time&quot;, margin_titles=True, height=4) grid.map(plt.hist, &quot;tip_pct&quot;, bins=np.linspace(0, 40, 15)) . &lt;seaborn.axisgrid.FacetGrid at 0x1a1ddd0f50&gt; . &#20998;&#31867;&#22270;&#65288;Categorical plot&#65289; . 展示分类数据分布情况： . Categorical scatterplots: . :func:stripplot (with kind=&quot;strip&quot;; the default) | :func:swarmplot (with kind=&quot;swarm&quot;) | . | Categorical distribution plots: . :func:boxplot (with kind=&quot;box&quot;) | :func:violinplot (with kind=&quot;violin&quot;) | :func:boxenplot (with kind=&quot;boxen&quot;) | . | Categorical estimate plots: . :func:pointplot (with kind=&quot;point&quot;) | :func:barplot (with kind=&quot;bar&quot;) | :func:countplot (with kind=&quot;count&quot;) | . | def show_factor(kind=&quot;strip&quot;): g = sns.catplot(&quot;day&quot;, &quot;total_bill&quot;, &quot;sex&quot;, kind=kind, data=tips, height=7) g.set_axis_labels(&quot;日期&quot;, &quot;小费金额&quot;) g._legend.set_bbox_to_anchor((1.1, 0.5)) . show_factor() . show_factor(kind=&quot;swarm&quot;) . show_factor(kind=&quot;box&quot;) . show_factor(kind=&quot;violin&quot;) . show_factor(kind=&quot;bar&quot;) . show_factor(kind=&quot;point&quot;) . &#32852;&#21512;&#20998;&#24067;&#22270; . sns.jointplot画出不同数据集的联合分布和各数据本身的分布： . sns.jointplot(&quot;total_bill&quot;, &quot;tip&quot;, data=tips, kind=&quot;hex&quot;); . 联合分布图也可以自动进行KDE和线性拟合： . sns.jointplot(&quot;total_bill&quot;, &quot;tip&quot;, data=tips, kind=&quot;reg&quot;); . pandas-profiling . Pandas + Matplotlib + Seabron实现的极速EDA工具，中文显示设置方法 . &lt;/img&gt; . 类型推断（Type inference）：检测Dataframe字段类型 | 基础统计（Essentials）：数据类型、惟一值、缺失值 | 分位数统计（Quantile statistics）：最小值，Q1，中位数，Q3，最大值，四分位距（interquartile range, IQR） | 描述性统计（Descriptive statistics）：均值、众数、标准差、和、MAD（Median absolute deviation, 中位数绝对偏差）、CV(coefficient of variation，变异系数)、峰度、偏度 | 高频次样本（Most frequent values） | 频次直方图（Histogram） | 相关矩阵（Correlation Matrix）：三大相关系数——皮尔逊（Pearson）、斯皮尔曼（Spearman）和肯德尔（Kendall），ϕ相关系数（Phi coefficient, Matthews coefficient=MCC） | 缺失值处理（Missing values）：矩阵、计数、热力图（heatmap）和树状图（dendrogram） | 文本分析（Text analysis）：文本数据的类别(大小写、空格)、字体(拉丁、西里尔)和字符(ASCII) | 文件和图像分析（File and Image analysis）：提取文件大小、创建日期和尺寸，并扫描截断的图像或包含EXIF信息的图像 | from pandas_profiling import ProfileReport profile = ProfileReport(iris, title=&quot;EDA报告&quot;, explorative=True) . profile.to_file(&quot;iris_profile.html&quot;) . . !open iris_profile.html . profile.to_widgets() . 字段较多时，相关性分析会比较慢，可以通过minimal=True设置参数 . profile = ProfileReport(iris, minimal=True) . &#22768;&#26126;&#24335;&#22270;&#24418;&#24211; . Matplotlib的缺点： . 样式不够丰富 | web/交互比较差 | 大数据渲染速度慢 | API是命令式（Imperative），语法比较啰嗦 | 数据可视化最大的挑战之一是图形的可移植性（portability）和可重复性（reproducibility ），创建一个图形并导出到PNG或PDF后，数据就很难再提取出来被再次利用。 | altair . 2015年，美国华盛顿大学天文学家、UW eScience Institute主任Jake Vanderplas（@jakevpd，目前在谷歌开发基于Numpy的自动微分器jax）在可视化语义（visualization grammar）库Vega基础上开发了altair，一种Python的声明式统计可视化库（Declarative statistical visualization library），将图形打包成描述数据和可视编码之间的关系的声明式（Declarative）JSON文件，从而实现将图形与JSON互转，增量更新无需重新绘制 . . 命令式（Imperative） 声明式（Declarative） . 关注怎样做(How)的过程 | 关注做什么(What)的结果 | . 必须手工配置绘图步骤 | 自动完成绘图细节 | . 配置与执行是耦合的 | 配置与执行分离的 | . “声明式可视化让你专注数据与联结，毋需深陷技术细节 . （Declarative visualization lets you think about data and relationships, rather than incidental details.）” . ——Jake Vanderplas 2017 . import altair as alt from vega_datasets import data . column = iris.columns.to_list() alt.Chart(iris).mark_circle().encode( alt.X(alt.repeat(&quot;column&quot;), type=&quot;quantitative&quot;), alt.Y(alt.repeat(&quot;row&quot;), type=&quot;quantitative&quot;), color=&quot;species:N&quot;, tooltip=column, ).properties(width=200, height=200).repeat( row=column[:-1], column=column[:-1], ).interactive() . source = data.movies.url heatmap = ( alt.Chart(source) .mark_rect() .encode( alt.X(&quot;IMDB_Rating:Q&quot;, bin=True), alt.Y(&quot;Rotten_Tomatoes_Rating:Q&quot;, bin=True), alt.Color(&quot;count()&quot;, scale=alt.Scale(scheme=&quot;greenblue&quot;)), ) ) points = ( alt.Chart(source) .mark_circle(color=&quot;black&quot;, size=5,) .encode(x=&quot;IMDB_Rating:Q&quot;, y=&quot;Rotten_Tomatoes_Rating:Q&quot;,) ) . # 支持&amp;（垂直）、|（水平）、+（有序叠加）三种Infix notation（中缀表示法）实现图层排列 heatmap &amp; points . heatmap | points . heatmap + points . pyecharts . ECharts声明式Javascript可视化库，由百度前端2013年发布1.0版本，2018年进入Apache孵化器。pyecharts是Python对ECharts的简易封装，相比js语法并没有太多优化 . 参考论文：ECharts:A declarative framework for rapid construction of web-based visualization . from pyecharts import charts, options bar = ( charts.Bar() .add_xaxis([&quot;衬衫&quot;, &quot;毛衣&quot;, &quot;领带&quot;, &quot;裤子&quot;, &quot;风衣&quot;, &quot;高跟鞋&quot;, &quot;袜子&quot;]) .add_yaxis(&quot;商家A&quot;, [114, 55, 27, 101, 125, 27, 105]) .add_yaxis(&quot;商家B&quot;, [57, 134, 137, 129, 145, 60, 49]) .set_global_opts(title_opts=options.TitleOpts(title=&quot;某商场销售情况&quot;)) ) . bar.render_notebook() . bar.render() . &#39;/Users/toddtao/Documents/reader/data_science/data_science2020/3.数据可视化/render.html&#39; . from IPython.display import IFrame IFrame(src=&#39;3.data-viz/render.html&#39;, width=700, height=600) . # print(bar.render_embed()) . webapp . 将可视化图转换为webapp发布，解决方案有dash、volia、streamlit、Panel、Bokeh . plotly&#20132;&#20114;&#29983;&#24577;&#31995;&#32479; . 加拿大plotly公司开发的可视化工具，有企业版授权，dash解决方案，支持Python、R、JS、Julia、Scala。plotly + pandas = cufflinks . import plotly.graph_objects as go fig = go.Figure() fig.add_trace(go.Scatter(y=np.random.rand(20))) fig.add_trace(go.Bar(y=np.random.rand(20))) fig.update_layout(title=&quot;plotly图形示例&quot;) fig.show() . ipywidgets&#20132;&#20114;&#25511;&#20214; . from IPython.display import HTML from ipywidgets import interact, interact_manual import cufflinks as cf cf.go_offline(connected=True) cf.set_config_file(colorscale=&quot;plotly&quot;, world_readable=True) . @interact def show_articles_more_than(字段=df_covid.columns, 阈值=[50_000, 100_000, 200_000]): display(HTML(f&quot;&lt;h2&gt;过滤部件：显示{字段} 超过 {阈值} 的行数&lt;h2&gt;&quot;)) display(df_covid.loc[df_covid[字段] &gt; 阈值, df_covid.columns]) . @interact def correlations( x=list(df_covid.select_dtypes(&quot;number&quot;).columns), y=list(df_covid.select_dtypes(&quot;number&quot;).columns[1:]), ): print(f&quot;皮尔逊相关系数: {df_covid[x].corr(df_covid[y])}&quot;) print(f&quot;描述性统计: n{df_covid[[x, y]].describe()}&quot;) df_covid.iplot( kind=&quot;scatter&quot;, x=x, y=y, mode=&quot;markers&quot;, xTitle=x.title(), yTitle=y.title(), title=f&quot;{y.title()} vs {x.title()}&quot;, ) . Voil&#224;&#22522;&#20110;jupyter&#26500;&#24314;webapp . 将notebook直接转换成web页面，可以通过命令行volia 3.数据可视化.ipynb --port 8880运行notebook，也可以通过notebook插件运行 . papermill可以将直接运行notebook文件，支持自定义参数 . dash&#22522;&#20110;flask&#12289;reactjs&#26500;&#24314;webapp . 由于dash运行方式与flask相同，因此不能直接在notebook上渲染，可以通过plotly开发的jupyter-dash在notebook上渲染 . from jupyter_dash import JupyterDash import dash import dash_core_components as dcc import dash_html_components as html from dash.dependencies import Input, Output import pandas as pd . df = pd.read_csv(&quot;3.data-viz/gapminderDataFiveYear.csv&quot;) df.shape . (1704, 6) . df.head() . country year pop continent lifeExp gdpPercap . 0 Afghanistan | 1952 | 8425333.0 | Asia | 28.801 | 779.445314 | . 1 Afghanistan | 1957 | 9240934.0 | Asia | 30.332 | 820.853030 | . 2 Afghanistan | 1962 | 10267083.0 | Asia | 31.997 | 853.100710 | . 3 Afghanistan | 1967 | 11537966.0 | Asia | 34.020 | 836.197138 | . 4 Afghanistan | 1972 | 13079460.0 | Asia | 36.088 | 739.981106 | . # app = dash.Dash(__name__) app = JupyterDash(__name__) app.layout = html.Div( [ dcc.Graph(id=&quot;graph-with-slider&quot;), dcc.Slider( id=&quot;year-slider&quot;, min=df[&quot;year&quot;].min(), max=df[&quot;year&quot;].max(), value=df[&quot;year&quot;].min(), marks={str(year): str(year) for year in df[&quot;year&quot;].unique()}, step=None, ), ] ) . @app.callback(Output(&quot;graph-with-slider&quot;, &quot;figure&quot;), [Input(&quot;year-slider&quot;, &quot;value&quot;)]) def update_figure(selected_year): filtered_df = df[df.year == selected_year] traces = [] for i in filtered_df.continent.unique(): df_by_continent = filtered_df[filtered_df[&quot;continent&quot;] == i] traces.append( dict( x=df_by_continent[&quot;gdpPercap&quot;], y=df_by_continent[&quot;lifeExp&quot;], text=df_by_continent[&quot;country&quot;], mode=&quot;markers&quot;, opacity=0.7, marker={&quot;size&quot;: 15, &quot;line&quot;: {&quot;width&quot;: 0.5, &quot;color&quot;: &quot;white&quot;}}, name=i, ) ) return { &quot;data&quot;: traces, &quot;layout&quot;: dict( xaxis={&quot;type&quot;: &quot;log&quot;, &quot;title&quot;: &quot;国家(地区)GDP&quot;, &quot;range&quot;: [2.3, 4.8]}, yaxis={&quot;title&quot;: &quot;人均预期寿命&quot;, &quot;range&quot;: [20, 90]}, margin={&quot;l&quot;: 40, &quot;b&quot;: 40, &quot;t&quot;: 10, &quot;r&quot;: 10}, legend={&quot;x&quot;: 0, &quot;y&quot;: 1}, hovermode=&quot;closest&quot;, transition={&quot;duration&quot;: 500}, ), } # if __name__ == &quot;__main__&quot;: # app.run_server(host=&quot;0.0.0.0&quot;, debug=True) . app.run_server(host=&quot;0.0.0.0&quot;) . Dash app running on http://0.0.0.0:8050/ . app.run_server(host=&quot;0.0.0.0&quot;, mode=&quot;inline&quot;, height=500) . df = pd.read_csv(&quot;3.data-viz/country.csv&quot;) available_indicators = df[&quot;Indicator Name&quot;].unique() df.head() . Country Name Indicator Name Year Value . 0 Arab World | Agriculture, value added (% of GDP) | 1962 | NaN | . 1 Arab World | CO2 emissions (metric tons per capita) | 1962 | 0.760996 | . 2 Arab World | Domestic credit provided by financial sector (... | 1962 | 18.168690 | . 3 Arab World | Electric power consumption (kWh per capita) | 1962 | NaN | . 4 Arab World | Energy use (kg of oil equivalent per capita) | 1962 | NaN | . app = JupyterDash(__name__) # server = app.server app.layout = html.Div([ html.Div([ html.Div([ dcc.Dropdown( id=&#39;crossfilter-xaxis-column&#39;, options=[{&#39;label&#39;: i, &#39;value&#39;: i} for i in available_indicators], value=&#39;Fertility rate, total (births per woman)&#39; ), dcc.RadioItems( id=&#39;crossfilter-xaxis-type&#39;, options=[{&#39;label&#39;: i, &#39;value&#39;: i} for i in [&#39;Linear&#39;, &#39;Log&#39;]], value=&#39;Linear&#39;, labelStyle={&#39;display&#39;: &#39;inline-block&#39;} ) ], style={&#39;width&#39;: &#39;49%&#39;, &#39;display&#39;: &#39;inline-block&#39;}), html.Div([ dcc.Dropdown( id=&#39;crossfilter-yaxis-column&#39;, options=[{&#39;label&#39;: i, &#39;value&#39;: i} for i in available_indicators], value=&#39;Life expectancy at birth, total (years)&#39; ), dcc.RadioItems( id=&#39;crossfilter-yaxis-type&#39;, options=[{&#39;label&#39;: i, &#39;value&#39;: i} for i in [&#39;Linear&#39;, &#39;Log&#39;]], value=&#39;Linear&#39;, labelStyle={&#39;display&#39;: &#39;inline-block&#39;} ) ], style={&#39;width&#39;: &#39;49%&#39;, &#39;float&#39;: &#39;right&#39;, &#39;display&#39;: &#39;inline-block&#39;}) ], style={ &#39;borderBottom&#39;: &#39;thin lightgrey solid&#39;, &#39;backgroundColor&#39;: &#39;rgb(250, 250, 250)&#39;, &#39;padding&#39;: &#39;10px 5px&#39; }), html.Div([ dcc.Graph( id=&#39;crossfilter-indicator-scatter&#39;, hoverData={&#39;points&#39;: [{&#39;customdata&#39;: &#39;Japan&#39;}]} ) ], style={&#39;width&#39;: &#39;49%&#39;, &#39;display&#39;: &#39;inline-block&#39;, &#39;padding&#39;: &#39;0 20&#39;}), html.Div([ dcc.Graph(id=&#39;x-time-series&#39;), dcc.Graph(id=&#39;y-time-series&#39;), ], style={&#39;display&#39;: &#39;inline-block&#39;, &#39;width&#39;: &#39;49%&#39;}), html.Div(dcc.Slider( id=&#39;crossfilter-year--slider&#39;, min=df[&#39;Year&#39;].min(), max=df[&#39;Year&#39;].max(), value=df[&#39;Year&#39;].max(), marks={str(year): str(year) for year in df[&#39;Year&#39;].unique()}, step=None ), style={&#39;width&#39;: &#39;49%&#39;, &#39;padding&#39;: &#39;0px 20px 20px 20px&#39;}) ]) . @app.callback( dash.dependencies.Output(&#39;crossfilter-indicator-scatter&#39;, &#39;figure&#39;), [dash.dependencies.Input(&#39;crossfilter-xaxis-column&#39;, &#39;value&#39;), dash.dependencies.Input(&#39;crossfilter-yaxis-column&#39;, &#39;value&#39;), dash.dependencies.Input(&#39;crossfilter-xaxis-type&#39;, &#39;value&#39;), dash.dependencies.Input(&#39;crossfilter-yaxis-type&#39;, &#39;value&#39;), dash.dependencies.Input(&#39;crossfilter-year--slider&#39;, &#39;value&#39;)]) def update_graph(xaxis_column_name, yaxis_column_name, xaxis_type, yaxis_type, year_value): dff = df[df[&#39;Year&#39;] == year_value] return { &#39;data&#39;: [dict( x=dff[dff[&#39;Indicator Name&#39;] == xaxis_column_name][&#39;Value&#39;], y=dff[dff[&#39;Indicator Name&#39;] == yaxis_column_name][&#39;Value&#39;], text=dff[dff[&#39;Indicator Name&#39;] == yaxis_column_name][&#39;Country Name&#39;], customdata=dff[dff[&#39;Indicator Name&#39;] == yaxis_column_name][&#39;Country Name&#39;], mode=&#39;markers&#39;, marker={ &#39;size&#39;: 25, &#39;opacity&#39;: 0.7, &#39;color&#39;: &#39;orange&#39;, &#39;line&#39;: {&#39;width&#39;: 2, &#39;color&#39;: &#39;purple&#39;} } )], &#39;layout&#39;: dict( xaxis={ &#39;title&#39;: xaxis_column_name, &#39;type&#39;: &#39;linear&#39; if xaxis_type == &#39;Linear&#39; else &#39;log&#39; }, yaxis={ &#39;title&#39;: yaxis_column_name, &#39;type&#39;: &#39;linear&#39; if yaxis_type == &#39;Linear&#39; else &#39;log&#39; }, margin={&#39;l&#39;: 40, &#39;b&#39;: 30, &#39;t&#39;: 10, &#39;r&#39;: 0}, height=450, hovermode=&#39;closest&#39; ) } . def create_time_series(dff, axis_type, title): return { &#39;data&#39;: [dict( x=dff[&#39;Year&#39;], y=dff[&#39;Value&#39;], mode=&#39;lines+markers&#39; )], &#39;layout&#39;: { &#39;height&#39;: 225, &#39;margin&#39;: {&#39;l&#39;: 20, &#39;b&#39;: 30, &#39;r&#39;: 10, &#39;t&#39;: 10}, &#39;annotations&#39;: [{ &#39;x&#39;: 0, &#39;y&#39;: 0.85, &#39;xanchor&#39;: &#39;left&#39;, &#39;yanchor&#39;: &#39;bottom&#39;, &#39;xref&#39;: &#39;paper&#39;, &#39;yref&#39;: &#39;paper&#39;, &#39;showarrow&#39;: False, &#39;align&#39;: &#39;left&#39;, &#39;bgcolor&#39;: &#39;rgba(255, 255, 255, 0.5)&#39;, &#39;text&#39;: title }], &#39;yaxis&#39;: {&#39;type&#39;: &#39;linear&#39; if axis_type == &#39;Linear&#39; else &#39;log&#39;}, &#39;xaxis&#39;: {&#39;showgrid&#39;: False} } } . @app.callback( dash.dependencies.Output(&#39;x-time-series&#39;, &#39;figure&#39;), [dash.dependencies.Input(&#39;crossfilter-indicator-scatter&#39;, &#39;hoverData&#39;), dash.dependencies.Input(&#39;crossfilter-xaxis-column&#39;, &#39;value&#39;), dash.dependencies.Input(&#39;crossfilter-xaxis-type&#39;, &#39;value&#39;)]) def update_y_timeseries(hoverData, xaxis_column_name, axis_type): country_name = hoverData[&#39;points&#39;][0][&#39;customdata&#39;] dff = df[df[&#39;Country Name&#39;] == country_name] dff = dff[dff[&#39;Indicator Name&#39;] == xaxis_column_name] title = &#39;&lt;b&gt;{}&lt;/b&gt;&lt;br&gt;{}&#39;.format(country_name, xaxis_column_name) return create_time_series(dff, axis_type, title) . @app.callback( dash.dependencies.Output(&#39;y-time-series&#39;, &#39;figure&#39;), [dash.dependencies.Input(&#39;crossfilter-indicator-scatter&#39;, &#39;hoverData&#39;), dash.dependencies.Input(&#39;crossfilter-yaxis-column&#39;, &#39;value&#39;), dash.dependencies.Input(&#39;crossfilter-yaxis-type&#39;, &#39;value&#39;)]) def update_x_timeseries(hoverData, yaxis_column_name, axis_type): dff = df[df[&#39;Country Name&#39;] == hoverData[&#39;points&#39;][0][&#39;customdata&#39;]] dff = dff[dff[&#39;Indicator Name&#39;] == yaxis_column_name] return create_time_series(dff, axis_type, yaxis_column_name) . app.run_server(host=&quot;0.0.0.0&quot;) . Dash app running on http://0.0.0.0:8050/ . app.run_server(host=&quot;0.0.0.0&quot;, mode=&quot;inline&quot;, width=1400, height=700) . &#32593;&#32476;&#22270; . Networkx:复杂网络绘制与图算法工具 | daft:matplotlib基础上构建的概率图模型 | Networkx&#32593;&#32476;&#22270; . 复杂网络绘制与图算法工具，可以与graphviz结合使用，类似工具推荐Gephi . import networkx as nx G = nx.Graph() G.add_edge(&quot;A&quot;, &quot;B&quot;, weight=4) G.add_edge(&quot;B&quot;, &quot;D&quot;, weight=2) G.add_edge(&quot;A&quot;, &quot;C&quot;, weight=3) G.add_edge(&quot;C&quot;, &quot;D&quot;, weight=4) pos = nx.spring_layout(G) nx.draw_networkx_edge_labels(G, pos, edge_labels=nx.get_edge_attributes(G, &quot;weight&quot;)) nx.draw(G, pos, with_labels=True, node_size=1000) . nx.shortest_path(G, &quot;A&quot;, &quot;D&quot;, weight=&quot;weight&quot;) . [&#39;A&#39;, &#39;B&#39;, &#39;D&#39;] . import pydot from networkx.drawing.nx_pydot import graphviz_layout G = nx.balanced_tree(2, 5) . pos = graphviz_layout(G) nx.draw(G, pos, node_size=20, alpha=0.5, node_color=&quot;blue&quot;, with_labels=False) . pos = graphviz_layout(G, prog=&quot;dot&quot;) nx.draw(G, pos, node_size=20, alpha=0.5, node_color=&quot;blue&quot;, with_labels=False) . plt.figure(figsize=(8, 8)) pos = graphviz_layout(G, prog=&quot;twopi&quot;) nx.draw(G, pos, node_size=20, alpha=0.5, node_color=&quot;blue&quot;, with_labels=False) plt.axis(&quot;equal&quot;) plt.show() . scikit-learn与graphviz结合，可以让决策树实现可视化 . from sklearn.datasets import load_iris from sklearn import tree iris = load_iris() clf = tree.DecisionTreeClassifier().fit(iris.data, iris.target) . gini不纯度（gini impurity）是CART (classification and regression tree) 决策树进行分裂的衡量指标之一，表示按照当前分裂规则随机抽取样本是错误分类的频率。 . 鸢尾花种类是$J=3$，那么第$i$种花在数据集中的占比（概率、频率）用$p_i$表示，则计算公式为： . $${I} _{G}(p)= sum _{i=1}^{3}p_{i} sum _{k neq i}p_{k}= sum _{i=1}^{3}p_{i}(1-p_{i})= sum _{i=1}^{3}(p_{i}-{p_{i}}^{2})= sum _{i=1}^{3}p_{i}- sum _{i=1}^{3}{p_{i}}^{2}=1- sum _{i=1}^{3}{p_{i}}^{2}$$ . 如果gini不纯度为0，则表示每个叶子节点的所有鸢尾花都有一个明确的分类 . plt.style.use(&quot;classic&quot;) plt.figure(figsize=(15, 15)) tree.plot_tree( clf, feature_names=iris.feature_names, class_names=iris.target_names, filled=True, ) plt.show() . daft&#36125;&#21494;&#26031;&#32593;&#32476; . Daft是在matplotlib基础上构建的概率图模型（probabilistic graphical models），贝叶斯网络之父朱迪亚·珀尔（Judea Pearl，2011年图灵奖得主）2018年出版了《The book of why（为什么）》介绍贝叶斯网络的因果推断。 . !pyreverse -o png -p daft /Users/toddtao/opt/anaconda3/lib/python3.7/site-packages/daft.py . parsing /Users/toddtao/opt/anaconda3/lib/python3.7/site-packages/daft.py... . . import daft p_color = {&quot;ec&quot;: &quot;#46a546&quot;} s_color = {&quot;ec&quot;: &quot;#f89406&quot;} pgm = daft.PGM([5.6, 1.4], origin=[0.75, 0.3]) pgm.add_plate([1.4, 0.4, 3.1, 1.2], r&quot;$D$&quot;) pgm.add_plate([2.5, 0.5, 1.95, 1], r&quot;$N_d$&quot;) pgm.add_plate([4.6, 0.5, 1, 1], r&quot;$K$&quot;, position=&quot;bottom right&quot;) pgm.add_node(&quot;alpha&quot;, r&quot;$ alpha$&quot;, 1, 1, fixed=True) pgm.add_node(&quot;theta&quot;, r&quot;$ theta_d$&quot;, 2, 1, plot_params=p_color) pgm.add_node(&quot;z&quot;, r&quot;$z_{d,n}$&quot;, 3, 1) pgm.add_node(&quot;w&quot;, r&quot;$w_{d,n}$&quot;, 4, 1, observed=True) pgm.add_node(&quot;beta&quot;, r&quot;$ beta_{k}$&quot;, 5.1, 1, plot_params=s_color) pgm.add_node(&quot;eta&quot;, r&quot;$ eta$&quot;, 6.1, 1, fixed=True) pgm.add_edge(&quot;alpha&quot;, &quot;theta&quot;) pgm.add_edge(&quot;theta&quot;, &quot;z&quot;) pgm.add_edge(&quot;z&quot;, &quot;w&quot;) pgm.add_edge(&quot;eta&quot;, &quot;beta&quot;) pgm.add_edge(&quot;beta&quot;, &quot;w&quot;) pgm.render() pgm.savefig(&quot;lda.png&quot;, dpi=150); . .",
            "url": "/Kivy/jupyter/python/data%20science/2020/05/29/data-viz-2.html",
            "relUrl": "/jupyter/python/data%20science/2020/05/29/data-viz-2.html",
            "date": " • May 29, 2020"
        }
        
    
  
    
        ,"post3": {
            "title": "Python数据科学分享——3.数据可视化(1)",
            "content": "&lt;/img&gt; . . &#30446;&#26631;&#19982;&#21407;&#21017; . 以最小的复杂度展示足够多的信息 . 目标：如果不能为用户提供有用的信息，那么就没啥用；如果信息展现形式太复杂，那么就会被噪声干扰 | 原则： 对比（Contrast）:让页面引人注目，避免页面上的元素太过相似。如果元素（字体、颜色、大小、线宽、形状、空间等）不相同，那就干脆让它们截然不同。 | 重复（Repetition）:让设计中的视觉要素在整个作品中重复出现。既能增加条理性，还可以加强统一性。 | 对齐（Alignment）:任何东西都不能在页面上随意安放。每个元素都应当与页面上的另一个元素有某种视觉联系，建立清晰、精巧而且清爽的外观。 | 亲密性（Proximity）:彼此相关的项应当靠近，归组在一起。如果多个项相互之间存在很近的亲密性，它们就会成为一个视觉单元，而不是多个孤立的元素。这有助于组织信息，减少混乱，为读者提供清晰的结构。 | | 美国教育家、设计师Robin Williams《The Non-Designer&#39;s Design Book（写给大家看的设计书）》 . 随着HTML5、SVG/Canvas普及，尤其是Mike Bostock于2010开源D3.js，python数据可视化受到冲击，Facebook于2013发布react.js后，Python数据可视化开始向web组件化发展，重点方向是机器学习与Web交互 . 首发年份 名称 简介 . 2003 | matplotlib | 基础绘图工具 | . 2010 | networkx | 复杂网络与图算法工具 | . 2012 | seaborn | 快速统计图 | . 2012 | bokeh | 交互式 | . 2012 | plotly | 交互式 | . 2015 | altair | 声明式语义 | . 2015 | dash | 基于plotly的web app | . 2015 | tensorboard | tensorflow and keras | . 2017 | ipyvolume | 3D交互 | . 2018 | Vaex | 高性能渲染 | . 2018 | streamlit | 机器学习web app | . 2018 | volia | notebook web app | . pyviz网站整理了Python数据可视化工具 . . matplotlib&#22522;&#30784;&#22270;&#24211; . Matplotlib的设计哲学是让Python程序员完全控制可视化应用。Matplotlib中文字体显示问题，请参考中文设置方法 . 模仿MatLab，上手简单，理工科同学上手成本低 | 许多渲染接口 | 功能齐全、文档完整 | 测试容易、源代码质量高 | &lt;/img&gt; . %load_ext autoreload %autoreload 2 %matplotlib inline from matplotlib.font_manager import _rebuild _rebuild() import matplotlib.pyplot as plt import seaborn as sns sns.set_style(&quot;whitegrid&quot;, {&quot;font.sans-serif&quot;: [&quot;SimHei&quot;, &quot;Arial&quot;]}) import pandas_alive import pandas as pd import numpy as np . df_covid = pd.read_json(&quot;3.data-viz/timeseries.json&quot;) df_covid.index = pd.DatetimeIndex(df_covid.iloc[:, 0].apply(lambda _: _[&quot;date&quot;])) df_covid.index.name = &quot;日期&quot; df_covid = df_covid.applymap(lambda _: int(_[&quot;confirmed&quot;])) df_covid.replace(0, np.nan, inplace=True) top20 = df_covid.iloc[-1].sort_values().tail(20).index df_covid = df_covid[top20] . &#32472;&#22270;&#29615;&#22659; . 在Jupyter(IPython) Notebook中画图： %matplotlib notebook会在Notebook中启动交互式图形 | %matplotlib inline会在Notebook中启动静态图形 | . | 在.py文件中画图：执行使用matplotlib的脚本后，会看到一个新窗口，里面会显示图形 | 在IPython shell中画图（在图形界面系统中启动）：在IPython shell中启动ipython后使用%matplotlib魔法命令，每个plt命令都会自动打开一个图形窗口 | %matplotlib notebook x = np.linspace(0, 10, 100) fig = plt.figure() plt.plot(x, np.sin(x)) plt.plot(x, np.cos(x)) plt.title(&#39;测试&#39;) # plt.show()`会启动一个事件循环（event loop） plt.show() . %matplotlib inline x = np.linspace(0, 10, 100) fig = plt.figure() plt.plot(x, np.sin(x)) plt.plot(x, np.cos(x)) plt.title(&#39;测试&#39;) # plt.show()`会启动一个事件循环（event loop） plt.show() . # 保存图形 fig.savefig(&#39;sin_cos.png&#39;) . ls -lh sin_cos.png . -rw-r--r-- 1 toddtao staff 23K May 28 16:13 sin_cos.png . # 用IPython的`Image`对象显示图形 from IPython.display import Image Image(&#39;sin_cos.png&#39;) . 用markdown语法显示图形 . . &#32472;&#22270;&#25509;&#21475; . 图形结构：Artist(Figure、Axes、Axis) | MATLAB风格接口：通过pyplot（plt）接口绘图，与MATLAB语法类似，plt是有状态的（stateful），会持续跟踪“当前的”图形和坐标轴，控制子图时比较麻烦 | 面向对象接口：通过Figure和Axes方法控制图形，可以按照行列控制子图，操作非常灵活 figure:plt.Figure类的一个实例，是一个能够容纳各种坐标轴、图形、文字和标签的容器 | axes：plt.Axes类的一个实例，是一个带有刻度和标签的矩形，包含所有可视化的图形元素 | . | &lt;/img&gt; . MATLAB&#39118;&#26684;&#25509;&#21475; . plt.figure() # 创建图形 # 创建两个子图中的第一个，设置坐标轴 plt.subplot(2, 1, 1) # (行、列、子图编号) plt.plot(x, np.sin(x)) # 创建两个子图中的第二个，设置坐标轴 plt.subplot(2, 1, 2) plt.plot(x, np.cos(x)); . &#38754;&#21521;&#23545;&#35937;&#25509;&#21475; . # 先创建图形网格 # ax是一个包含两个Axes对象的数组 fig, ax = plt.subplots(2) # 在每个对象上调用`plot()`方法 ax[0].plot(x, np.sin(x)) ax[1].plot(x, np.cos(x)); . &#22270;&#24418;&#37197;&#32622; . &#22270;&#24418;&#26679;&#24335; . plt.plot()函数设置颜色（color参数）与风格（linestyle参数） . plt.figure(figsize=(10, 5)) plt.plot(x, np.sin(x - 0), color=&#39;blue&#39;) # 标准颜色名称 plt.plot(x, np.sin(x - 1), color=&#39;g&#39;) # 缩写颜色代码（rgbcmyk） plt.plot(x, np.sin(x - 2), color=&#39;0.75&#39;) # 范围在0~1之间的灰度值 plt.plot(x, np.sin(x - 3), color=&#39;#FFDD44&#39;) # 十六进制（RRGGBB，00~FF） plt.show() . plt.figure(figsize=(10, 5)) plt.plot(x, np.sin(x - 0), linestyle=&#39;-&#39;) # 实线 plt.plot(x, np.sin(x - 1), linestyle=&#39;--&#39;) # 虚线 plt.plot(x, np.sin(x - 2), linestyle=&#39;-.&#39;) # 点划线 plt.plot(x, np.sin(x - 3), linestyle=&#39;:&#39;); # 实点线 plt.show() . 可以将linestyle和color编码组合起来，作为plt.plot()函数的一个参数使用： . plt.figure(figsize=(10, 5)) plt.plot(x, np.sin(x - 0), &#39;-g&#39;) # 绿色实线 plt.plot(x, np.sin(x - 1), &#39;--c&#39;) # 青色虚线 plt.plot(x, np.sin(x - 2), &#39;-.k&#39;) # 黑色点划线 plt.plot(x, np.sin(x - 3), &#39;:r&#39;); # 红色实点线 . &#22270;&#24418;&#26631;&#31614; . 图标题 | 轴标题 | 图例 | plt.figure(figsize=(10, 5)) plt.plot(x, np.sin(x), &#39;-g&#39;, label=&#39;sin(x)&#39;) plt.plot(x, np.cos(x), &#39;:b&#39;, label=&#39;cos(x)&#39;) plt.title(&quot;正弦余弦曲线&quot;) plt.xlabel(&quot;x值&quot;) plt.ylabel(&quot;三角函数值&quot;); plt.legend(); . &#30011;&#25955;&#28857;&#22270; . 创建散点图可以用plt.plot和plt.scatter。后者功能更强大，可以让每个散点具有不同的属性（大小、表面颜色、边框颜色等），实现多维度可视化，例如alpha参数来调整透明度： . plt.plot性能优于plt.scatter：由于plt.scatter会对每个散点进行单独渲染，因此渲染器会消耗更多的资源。而在plt.plot中，散点基本都彼此复制，因此整个数据集中所有点的颜色、尺寸只需要配置一次，因此处理几千个点的数据集时，plt.plot方法比plt.scatter方法性能好。 . rng = np.random.RandomState(0) x = rng.randn(100) y = rng.randn(100) colors = rng.rand(100) sizes = 1000 * rng.rand(100) . plt.figure(figsize=(10, 10)) plt.scatter(x, y, c=colors, s=sizes, alpha=0.3, cmap=&quot;viridis&quot;) # 显示颜色条 plt.colorbar(); . MNIST&#25163;&#20889;&#25968;&#23383;&#21487;&#35270;&#21270; . MNIST手写数字是机器学习图像识别经典示例，在Scikit-Learn里面，包含近2000份8×8的手写数字缩略图，每个图片都是8x8=64像素，展开成特征矩阵是64维空间。 . from sklearn.datasets import load_digits digits = load_digits() fig, ax = plt.subplots(10, 10, figsize=(8, 8)) for i, axi in enumerate(ax.flat): axi.imshow(digits.images[i], cmap=&#39;binary&#39;) axi.set(xticks=[], yticks=[]) . 通过scikit-learn流形学习（manifold learning）最早的算法Isomap（Isometric Mapping）将64维空间降成2维平面实现可视化，对比PCA（主成分分析），Isomap可以学习到非线性特征 . &quot;流形学习&quot;——中国拓扑学家江泽涵院士取自文天祥《正气歌》的“天地有正气，杂然赋流形”，表示“多样体” . from sklearn.manifold import Isomap iso = Isomap(n_components=2).fit_transform(digits.data) . sns.set_style(&quot;dark&quot;, {&quot;font.sans-serif&quot;: [&quot;SimHei&quot;, &quot;Arial&quot;]}) plt.figure(figsize=(10, 10)) plt.scatter( iso[:, 0], iso[:, 1], lw=0.1, c=digits.target, cmap=plt.cm.get_cmap(&quot;cubehelix&quot;, 10), ) plt.colorbar(ticks=range(10), label=&quot;数字值&quot;) plt.clim(-0.5, 9.5); . &#23376;&#22270; . Matplotlib通过子图（subplot）的概念，实现多角度数据对比： . plt.axes：手动创建子图 | plt.subplot：简易网格子图 | plt.subplots：用NumPy数组创建网格 | plt.GridSpec：自由排列网格 | plt.axes&#65306;&#25163;&#21160;&#21019;&#24314;&#23376;&#22270; . plt.axes函数默认创建一个标准的坐标轴，填满整张图。其可选参数用4个值分别表示图形坐标的 [bottom, left, width, height]（底坐标、左坐标、宽度、高度），数值的取值范围是左下角（原点）为0，右上角为1。 . sns.set_style(&quot;white&quot;, {&quot;font.sans-serif&quot;: [&quot;SimHei&quot;, &quot;Arial&quot;]}) . plt.figure(figsize=(10, 10)) ax1 = plt.axes() # 默认坐标轴 ax2 = plt.axes([0.65, 0.65, 0.2, 0.2]) . 面向对象画图接口中类似的命令有fig.add_axes()。用这个命令创建两个竖直排列的坐标轴： . fig = plt.figure(figsize=(10, 10)) ax1 = fig.add_axes([0.1, 0.5, 0.8, 0.4], xticklabels=[], ylim=(-1.2, 1.2)) ax2 = fig.add_axes([0.1, 0.1, 0.8, 0.4], ylim=(-1.2, 1.2)) x = np.linspace(0, 10) ax1.plot(np.sin(x)) ax2.plot(np.cos(x)); . plt.subplot&#65306;&#31616;&#26131;&#32593;&#26684;&#23376;&#22270; . plt.subplot()在一个网格中创建一个子图。这个命令有3个整型参数——将要创建的网格子图行数、列数和索引值，索引值从1开始，从左上角到右下角依次增大： . plt.figure(figsize=(10, 10)) for i in range(1, 7): plt.subplot(2, 3, i) plt.text(0.5, 0.5, str((2, 3, i)), fontsize=18, ha=&quot;center&quot;) . plt.subplots_adjust命令可以调整子图之间的间隔。用面向对象接口的命令fig.add_subplot()可以取得同样的效果: . 通过plt.subplots_adjust的hspace与wspace参数设置与图形高度与宽度一致的子图间距 . fig = plt.figure(figsize=(10, 10)) fig.subplots_adjust(hspace=0.4, wspace=0.4) for i in range(1, 7): ax = fig.add_subplot(2, 3, i) ax.text(0.5, 0.5, str((2, 3, i)), fontsize=18, ha=&quot;center&quot;) . plt.subplots&#65306;&#29992;&#19968;&#34892;&#20195;&#30721;&#21019;&#24314;&#32593;&#26684; . plt.subplots()实用一行代码创建多个子图，并返回一个包含子图的NumPy数组。参数是行数与列数，以及可选参数sharex与sharey，通过它们可以设置不同子图之间的关联关系。 . fig, ax = plt.subplots(2, 3, sharex=&quot;col&quot;, sharey=&quot;row&quot;, figsize=(10, 10)) for i in range(2): for j in range(3): ax[i, j].text(0.5, 0.5, str((i, j)), fontsize=18, ha=&quot;center&quot;) . plt.GridSpec`&#65306;&#23454;&#29616;&#26356;&#22797;&#26434;&#30340;&#25490;&#21015;&#26041;&#24335; . plt.GridSpec()可以实现不规则的多行多列子图网格。例如，一个带行列间距的2x3网格的配置代码如下所示： . plt.figure(figsize=(10, 10)) grid = plt.GridSpec(2, 3, wspace=0.4, hspace=0.3) plt.subplot(grid[0, 0]) plt.subplot(grid[0, 1:]) plt.subplot(grid[1, :2]) plt.subplot(grid[1, 2]); . &#29992;Matplotlib&#30011;&#19977;&#32500;&#22270; . 可以用ax.plot3D与ax.scatter3D函数来创建三维坐标点构成的线图与散点图，需要用%matplotlib notebook实现交互 . ipyvolume：通过WebGL在Jupyter notebook实现3D交互，支持百万散点的页面渲染和交互 . %matplotlib notebook from mpl_toolkits import mplot3d fig = plt.figure(figsize=(10, 10)) ax = plt.axes(projection=&quot;3d&quot;) y = 15 # 三维曲线 zline = np.linspace(0, y, 1000) xline = np.sin(zline) yline = np.cos(zline) ax.plot3D(xline, yline, zline, &quot;gray&quot;) # 三维散点 zdata = y * np.random.random(100) xdata = np.sin(zdata) + 0.1 * np.random.randn(100) ydata = np.cos(zdata) + 0.1 * np.random.randn(100) ax.scatter3D(xdata, ydata, zdata, c=zdata, cmap=&quot;Greens&quot;); . 用ax.plot_surface演示一个三维正弦函数画的三维等高曲面图，要求X,Y,Z都是二维网格数据的形式: . x = np.linspace(-6, 6, 30) y = np.linspace(-6, 6, 30) X, Y = np.meshgrid(x, y) Z = np.sin(np.sqrt(X ** 2 + Y ** 2)) fig = plt.figure(figsize=(10, 10)) ax = plt.axes(projection=&quot;3d&quot;) ax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap=&quot;viridis&quot;, edgecolor=&quot;none&quot;) ax.set_xlabel(&quot;x&quot;) ax.set_ylabel(&quot;y&quot;) ax.set_zlabel(&quot;z&quot;) . Text(0.5, 0, &#39;z&#39;) . pandas plot&#19982;pandas-alive . Pandas以Matplotlib实现了plot接口（Matlab风格），可以快速实现Serise与Datafram的可视化，pandas-alive增加了时间序列的动态图效果 . %matplotlib inline . !head -n 20 timeseries.json . { &#34;Afghanistan&#34;: [ { &#34;date&#34;: &#34;2020-1-22&#34;, &#34;confirmed&#34;: 0, &#34;deaths&#34;: 0, &#34;recovered&#34;: 0 }, { &#34;date&#34;: &#34;2020-1-23&#34;, &#34;confirmed&#34;: 0, &#34;deaths&#34;: 0, &#34;recovered&#34;: 0 }, { &#34;date&#34;: &#34;2020-1-24&#34;, &#34;confirmed&#34;: 0, &#34;deaths&#34;: 0, &#34;recovered&#34;: 0 }, . df_covid.diff().hist(figsize=(20,15), sharey=True); . spain = df_covid[&#39;Spain&#39;].diff() spain[spain&lt;0] . 日期 2020-04-24 -10034.0 Name: Spain, dtype: float64 . df_covid.loc[&quot;2020-04-20&quot;:&quot;2020-04-30&quot;, &quot;Spain&quot;] . 日期 2020-04-20 200210.0 2020-04-21 204178.0 2020-04-22 208389.0 2020-04-23 213024.0 2020-04-24 202990.0 2020-04-25 205905.0 2020-04-26 207634.0 2020-04-27 209465.0 2020-04-28 210773.0 2020-04-29 212917.0 2020-04-30 213435.0 Name: Spain, dtype: float64 . def current_total(values): total = values.sum() s = f&quot;总数 : {int(total)}&quot; return {&quot;x&quot;: 0.85, &quot;y&quot;: 0.2, &quot;s&quot;: s, &quot;ha&quot;: &quot;right&quot;, &quot;size&quot;: 11} animated_html = df_covid.tail(60).plot_animated(period_summary_func=current_total) . Generating BarChartRace, plotting [&#39;Netherlands&#39;, &#39;Pakistan&#39;, &#39;Belgium&#39;, &#39;Chile&#39;, &#39;Mexico&#39;, &#39;Saudi Arabia&#39;, &#39;Canada&#39;, &#39;China&#39;, &#39;Peru&#39;, &#39;India&#39;, &#39;Iran&#39;, &#39;Turkey&#39;, &#39;Germany&#39;, &#39;France&#39;, &#39;Italy&#39;, &#39;Spain&#39;, &#39;United Kingdom&#39;, &#39;Brazil&#39;, &#39;Russia&#39;, &#39;US&#39;] . /Users/toddtao/opt/anaconda3/lib/python3.7/site-packages/pandas_alive/charts.py:70: UserWarning: Plotting too many bars may result in undesirable output, use `n_visible=5 to limit number of bars &#34;Plotting too many bars may result in undesirable output, use `n_visible=5 to limit number of bars&#34; . from IPython.display import display, Video display(Video(&#39;3.data-viz/covid19.mp4&#39;)) . Your browser does not support the video element.",
            "url": "/Kivy/jupyter/python/data%20science/2020/05/22/data-viz-1.html",
            "relUrl": "/jupyter/python/data%20science/2020/05/22/data-viz-1.html",
            "date": " • May 22, 2020"
        }
        
    
  
    
        ,"post4": {
            "title": "Python数据科学分享——2.数据处理",
            "content": ". %load_ext autoreload %autoreload 2 import matplotlib.pyplot as plt import seaborn seaborn.set() plt.rcParams[&quot;font.sans-serif&quot;] = [&quot;SimHei&quot;] import numpy as np import pandas as pd from scipy import sparse from tqdm.notebook import tqdm . &lt;/img&gt; . &lt;/img&gt; . python数值计算历史 首发年份 名称 场景 . 1991 | Python | 编程语言 | . 2001 | ipython | 增强shell | . 2001 | SciPy | 算法库 | . 2006 | Numpy | 数组运算 | . 2007 | Cython | AOT静态编译 | . 2008 | Pandas | 标签数组运算 | . 2010 | scikit-learn | 机器学习 | . 2012 | ipython notebook | 计算环境 | . 2012 | anaconda | 管理工具 | . 2012 | Numba | llvm实现JIT编译器 | . 2012 | pyspark | 集群运算 | . 2015 | jupyter | 多语言支持 | . 2015 | TensorFlow | 深度学习 | . 2018 | jax | Numpy+autogrd+JIT+GPU+TPU | . With great power comes great complexity（越强大越复杂） Numpy . &#31070;&#32463;&#32593;&#32476;&#31034;&#20363; . &#32972;&#26223; . from IPython.display import Video # https://github.com/Sentdex/NNfSiX # Video(&quot;2.data-elt/cat_neural_network.mp4&quot;, embed=True) . x1 x2 x3 Y . 0 | 0 | 1 | 0 | . 0 | 1 | 1 | 1 | . 1 | 0 | 1 | 1 | . 1 | 1 | 1 | 0 | . X = np.array([[0, 0, 1], [0, 1, 1], [1, 0, 1], [1, 1, 1]]) y = np.array([[0], [1], [1], [0]]) . &#32593;&#32476;&#22270; . &lt;/img&gt; . &#25968;&#23398;&#25551;&#36848; . 公式1 $$ hat y = sigma(W_2 sigma(W_1x+ b_1) + b_2) $$ . 公式2（sigmoid） $$ sigma = frac {1} {1 + e^{-x}} $$ . 公式3（sigmoid导数） $$ sigma&#39; = sigma(x) times (1 - sigma(x)) $$ . . &#21453;&#21521;&#20256;&#25773; . . 公式4 $$ Loss(Sum of Squares Error) = sum_{i=1}^n(y- hat y)^2 $$ . numpy&#23454;&#29616; . def σ(x): return 1 / (1 + np.exp(-x)) def σ_dvt(x): return σ(x) * (1 - σ(x)) class NeuralNetwork(object): def __init__(self, x, y): self.x = x self.y = y self.w1 = np.random.rand(self.x.shape[1], 4) self.w2 = np.random.rand(4, 1) self.yhat = np.zeros(self.y.shape) def feedforward(self): self.layer1 = σ(self.x @ self.w1) self.yhat = σ(self.layer1 @ self.w2) def backprop(self): gd = 2 * (self.y - self.yhat) * σ_dvt(self.yhat) d_w2 = self.layer1.T @ gd d_w1 = self.x.T @ (gd @ (self.w2.T) * σ_dvt(self.layer1)) self.w1 += d_w1 self.w2 += d_w2 . nn = NeuralNetwork(X, y) train = [] for i in tqdm(range(10000)): nn.feedforward() nn.backprop() loss = sum((_[0] - _[1])[0] ** 2 for _ in zip(nn.y, nn.yhat)) train.append(loss) print(nn.yhat) . [[0.00644673] [0.9909493 ] [0.99080728] [0.00803459]] . def show_plot(x, y): plt.figure(figsize=(15, 5)) plt.plot( x, y, linewidth=3, linestyle=&quot;:&quot;, color=&quot;blue&quot;, label=&quot;Sum of Squares Error&quot;, ) plt.xlabel(&quot;训练次数&quot;) plt.ylabel(&quot;训练损失&quot;) plt.title(&quot;训练损失随次数增加而递减&quot;) plt.legend(loc=&quot;upper right&quot;) plt.show() . show_plot(range(len(train)), train) . show_plot(range(4000, len(train)), train[4000:]) . &#25968;&#25454;&#32467;&#26500; . NumPy在C语言的基础上开发ndarray对象，其数据类型也是在C语言基础上进行扩充。 . CPython的整型对象是一个PyObject_HEAD是C语言结构体，包含引用计数、类型编码和数据大小等信息，相比C语言的整型增加了很多开销，Numpy进行了优化。 . . &#25968;&#32452;&#21021;&#22987;&#21270; . # 创建一个长度为10的数组，数组的值都是0 np.zeros(10, dtype=int) . array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) . # 创建一个3x5的浮点型数组，数组的值都是1 np.ones((3, 5), dtype=float) . array([[1., 1., 1., 1., 1.], [1., 1., 1., 1., 1.], [1., 1., 1., 1., 1.]]) . # 创建一个3x5的浮点型数组，数组的值都是3.14 np.full((3, 5), 3.14) . array([[3.14, 3.14, 3.14, 3.14, 3.14], [3.14, 3.14, 3.14, 3.14, 3.14], [3.14, 3.14, 3.14, 3.14, 3.14]]) . # 创建一个线性序列数组，从0开始，到20结束，步长为2（它和内置的range()函数类似） np.arange(0, 20, 2) . array([ 0, 2, 4, 6, 8, 10, 12, 14, 16, 18]) . # 创建一个5个元素的数组，这5个数均匀地分配到0~1区间 np.linspace(0, 1, 5) . array([0. , 0.25, 0.5 , 0.75, 1. ]) . # NumPy的随机数生成器设置一组种子值，以确保每次程序执行时都可以生成同样的随机数组： np.random.seed(1024) # 创建一个3x3的、0~1之间均匀分布的随机数组成的数组 np.random.random((3, 3)) . array([[0.64769123, 0.99691358, 0.51880326], [0.65811273, 0.59906347, 0.75306733], [0.13624713, 0.00411712, 0.14950888]]) . # 创建一个3x3的、均值为0、标准差为1的正态分布的随机数数组 np.random.normal(0, 1, (3, 3)) . array([[ 0.7729004 , 1.64294992, -0.12721717], [ 0.91598327, 0.52267255, -0.22634267], [ 1.41873344, -0.16232799, 0.53831355]]) . # 创建一个3x3的、[0, 10)区间的随机整型数组 np.random.randint(0, 10, (3, 3)) . array([[6, 4, 4], [1, 0, 1], [8, 7, 0]]) . # 创建一个3x3的单位矩阵 np.eye(3) . array([[1., 0., 0.], [0., 1., 0.], [0., 0., 1.]]) . # 创建一个由3个整型数组成的未初始化的数组，数组的值是内存空间中的任意值 np.empty(3) . array([1., 1., 1.]) . 属性：确定数组的大小、形状、存储大小、数据类型 | 读写：数组保存与加载文件 | 数学运算：加减乘除、指数与平方根、三角函数、聚合比较等基本运算 | 复制与排序：数组深浅copy、快速排序、归并排序和堆排序 | 索引：获取和设置数组各个元素的值 | 切分：在数组中获取或设置子数组 | 变形：改变给定数组的形状 | 连接和分裂：将多个数组合并为一个，或者将一个数组分裂成多个 | . &#36890;&#29992;&#20989;&#25968;(universal functions, ufunc) . NumPy实现一种静态类型、可编译程序接口（ufunc），实现向量化(vectorize)操作，避免for循环，提高效率，节约内存。 . 通用函数有两种存在形式： . 一元通用函数（unary ufunc）对单个输入操作 | 二元通用函数（binary ufunc）对两个输入操作 | &#25968;&#32452;&#30340;&#36816;&#31639; . NumPy通用函数的使用方式非常自然，因为它用到了Python原生的算术运算符(加、减、乘、除)、绝对值、三角函数、指数与对数、布尔/位运算符。 . 运算符 对应的通用函数 描述 . + | np.add | 加法运算（即1 + 1 = 2） | . - | np.subtract | 减法运算（即3 - 2 = 1） | . - | np.negative | 负数运算 （即-2） | . * | np.multiply | 乘法运算 （即2 * 3 = 6） | . / | np.divide | 除法运算 （即3 / 2 = 1.5） | . // | np.floor_divide | 地板除法运算（floor division，即3 // 2 = 1） | . ** | np.power | 指数运算 （即2 ** 3 = 8） | . % | np.mod | 模/余数 （即9 % 4 = 1） | . | np.abs | 绝对值 | . x = np.arange(4) print(&quot;x =&quot;, x) print(&quot;x + 5 =&quot;, x + 5) print(&quot;x - 5 =&quot;, x - 5) print(&quot;x * 2 =&quot;, x * 2) print(&quot;x / 2 =&quot;, x / 2) print(&quot;x // 2 =&quot;, x // 2) # 整除运算 . x = [0 1 2 3] x + 5 = [5 6 7 8] x - 5 = [-5 -4 -3 -2] x * 2 = [0 2 4 6] x / 2 = [0. 0.5 1. 1.5] x // 2 = [0 0 1 1] . x = [1, 2, 3] print(&quot;x =&quot;, x) print(&quot;e^x =&quot;, np.exp(x)) print(&quot;2^x =&quot;, np.exp2(x)) print(&quot;3^x =&quot;, np.power(3, x)) print(&quot;x =&quot;, x) print(&quot;ln(x) =&quot;, np.log(x)) print(&quot;log2(x) =&quot;, np.log2(x)) print(&quot;log10(x) =&quot;, np.log10(x)) . x = [1, 2, 3] e^x = [ 2.71828183 7.3890561 20.08553692] 2^x = [2. 4. 8.] 3^x = [ 3 9 27] x = [1, 2, 3] ln(x) = [0. 0.69314718 1.09861229] log2(x) = [0. 1. 1.5849625] log10(x) = [0. 0.30103 0.47712125] . &#29305;&#27530;ufunc . scipy.special提供了大量统计学函数。例如，Γ函数和β函数 . from scipy import special x = [1, 5, 10] print(&quot;gamma(x) =&quot;, special.gamma(x)) print(&quot;ln|gamma(x)| =&quot;, special.gammaln(x)) print(&quot;beta(x, 2) =&quot;, special.beta(x, 2)) . gamma(x) = [1.0000e+00 2.4000e+01 3.6288e+05] ln|gamma(x)| = [ 0. 3.17805383 12.80182748] beta(x, 2) = [0.5 0.03333333 0.00909091] . &#39640;&#32423;&#29305;&#24615; . &#32047;&#35745; . 二元通用函数的reduce方法可以对给定元素和操作重复执行，直至得到一个汇总结果。accumulate方法实现截至每一个元素的累积结果 . 例如，对add通用函数调用reduce方法会返回数组中所有元素的和： . x = np.arange(1, 6) np.add.reduce(x) . 15 . 同样，对multiply通用函数调用reduce方法会返回数组中所有元素的乘积： . np.multiply.reduce(x) . 120 . np.add.accumulate(x) . array([ 1, 3, 6, 10, 15]) . np.multiply.accumulate(x) . array([ 1, 2, 6, 24, 120]) . NumPy提供了专用的函数（np.sum、np.prod、np.cumsum、np.cumprod ），它们也可以实现reduce的功能 . &#22806;&#31215; . 任何通用函数都可以用outer方法获得两个不同输入数组所有元素对的函数运算结果。用一行代码实现一个99乘法表： . x = np.arange(1, 10) np.multiply.outer(x, x) . array([[ 1, 2, 3, 4, 5, 6, 7, 8, 9], [ 2, 4, 6, 8, 10, 12, 14, 16, 18], [ 3, 6, 9, 12, 15, 18, 21, 24, 27], [ 4, 8, 12, 16, 20, 24, 28, 32, 36], [ 5, 10, 15, 20, 25, 30, 35, 40, 45], [ 6, 12, 18, 24, 30, 36, 42, 48, 54], [ 7, 14, 21, 28, 35, 42, 49, 56, 63], [ 8, 16, 24, 32, 40, 48, 56, 64, 72], [ 9, 18, 27, 36, 45, 54, 63, 72, 81]]) . &#24191;&#25773;(Broadcasting) . NumPy也可以通过广播实现向量化操作。广播可以用于不同大小数组的二元通用函数（加、减、乘等）的一组规则: . 规则1：如果两个数组的维度数不相同，那么小维度数组的形状将会在最左边补1。 | 规则2：如果两个数组的形状在任何一个维度上都不匹配，那么数组的形状会沿着维度为1的维度扩展以匹配另外一个数组的形状。 | 规则3：如果两个数组的形状在任何一个维度上都不匹配并且没有任何一个维度等于1，那么会引发异常。 | . a = np.arange(3) a + 5 . array([5, 6, 7]) . np.ones((3, 3)) + a . array([[1., 2., 3.], [1., 2., 3.], [1., 2., 3.]]) . 根据规则1，数组a的维度数更小，所以在其左边补1： . b.shape -&gt; (3, 3) . a.shape -&gt; (1, 3) . 根据规则2，第一个维度不匹配，因此扩展这个维度以匹配数组： . b.shape -&gt; (3, 3) . a.shape -&gt; (3, 3) . 现在两个数组的形状匹配了，可以看到它们的最终形状都为(3, 3)： . b = np.arange(3)[:, np.newaxis] b + a . array([[0, 1, 2], [1, 2, 3], [2, 3, 4]]) . 根据规则1，数组a的维度数更小，所以在其左边补1： . b.shape -&gt; (3, 1) . a.shape -&gt; (1, 3) . 根据规则2，两个维度都不匹配，因此扩展这个维度以匹配数组： . b.shape -&gt; (3, 3) . a.shape -&gt; (3, 3) . 现在两个数组的形状匹配了，可以看到它们的最终形状都为(3, 3)： . . Scipy&#31232;&#30095;&#30697;&#38453; . 地球70多亿人的社交网络中，大部分人直接认识的人数不超过10000，因此这个矩阵中，大部分的值都是0（稀疏） . &lt;/img&gt; . SN = np.random.poisson(0.2, (10, 10)) * np.random.randint(0, 10, (10, 10)) SN . array([[ 8, 0, 0, 0, 9, 0, 0, 0, 0, 3], [ 0, 0, 9, 0, 7, 0, 0, 0, 0, 4], [ 0, 0, 0, 0, 0, 0, 0, 0, 8, 0], [ 0, 0, 0, 9, 0, 0, 0, 4, 0, 0], [ 0, 5, 0, 0, 0, 7, 0, 0, 0, 0], [ 0, 8, 8, 1, 0, 1, 4, 0, 0, 0], [ 0, 18, 0, 0, 0, 0, 0, 0, 0, 4], [ 0, 0, 4, 0, 0, 0, 5, 0, 0, 0], [ 0, 0, 0, 0, 5, 0, 0, 0, 0, 0], [ 0, 0, 0, 9, 0, 0, 4, 0, 0, 0]]) . rows, cols = np.nonzero(SN) vals = SN[rows, cols] rows, cols, vals . (array([0, 0, 0, 1, 1, 1, 2, 3, 3, 4, 4, 5, 5, 5, 5, 5, 6, 6, 7, 7, 8, 9, 9]), array([0, 4, 9, 2, 4, 9, 8, 3, 7, 1, 5, 1, 2, 3, 5, 6, 1, 9, 2, 6, 4, 3, 6]), array([ 8, 9, 3, 9, 7, 4, 8, 9, 4, 5, 7, 8, 8, 1, 1, 4, 18, 4, 4, 5, 5, 9, 4])) . &#31232;&#30095;&#30697;&#38453;&#21021;&#22987;&#21270; . X = sparse.coo_matrix(SN) X . &lt;10x10 sparse matrix of type &#39;&lt;class &#39;numpy.int64&#39;&gt;&#39; with 23 stored elements in COOrdinate format&gt; . print(X) . (0, 0) 8 (0, 4) 9 (0, 9) 3 (1, 2) 9 (1, 4) 7 (1, 9) 4 (2, 8) 8 (3, 3) 9 (3, 7) 4 (4, 1) 5 (4, 5) 7 (5, 1) 8 (5, 2) 8 (5, 3) 1 (5, 5) 1 (5, 6) 4 (6, 1) 18 (6, 9) 4 (7, 2) 4 (7, 6) 5 (8, 4) 5 (9, 3) 9 (9, 6) 4 . &#25353;&#22352;&#26631;&#21019;&#24314;&#31232;&#30095;&#30697;&#38453; . X2 = sparse.coo_matrix((vals, (rows, cols))) . X2.todense() . matrix([[ 8, 0, 0, 0, 9, 0, 0, 0, 0, 3], [ 0, 0, 9, 0, 7, 0, 0, 0, 0, 4], [ 0, 0, 0, 0, 0, 0, 0, 0, 8, 0], [ 0, 0, 0, 9, 0, 0, 0, 4, 0, 0], [ 0, 5, 0, 0, 0, 7, 0, 0, 0, 0], [ 0, 8, 8, 1, 0, 1, 4, 0, 0, 0], [ 0, 18, 0, 0, 0, 0, 0, 0, 0, 4], [ 0, 0, 4, 0, 0, 0, 5, 0, 0, 0], [ 0, 0, 0, 0, 5, 0, 0, 0, 0, 0], [ 0, 0, 0, 9, 0, 0, 4, 0, 0, 0]]) . &#25968;&#25454;&#21387;&#32553; . 将稀疏矩阵保存为 CSR(Compressed Sparse Row)/CSC(Compressed Sparse Column) 格式 . np.vstack([rows, cols]) . array([[0, 0, 0, 1, 1, 1, 2, 3, 3, 4, 4, 5, 5, 5, 5, 5, 6, 6, 7, 7, 8, 9, 9], [0, 4, 9, 2, 4, 9, 8, 3, 7, 1, 5, 1, 2, 3, 5, 6, 1, 9, 2, 6, 4, 3, 6]]) . indptr = np.r_[np.searchsorted(rows, np.unique(rows)), len(rows)] indptr . array([ 0, 3, 6, 7, 9, 11, 16, 18, 20, 21, 23]) . X3 = sparse.csr_matrix((vals, cols, indptr)) X3 . &lt;10x10 sparse matrix of type &#39;&lt;class &#39;numpy.int64&#39;&gt;&#39; with 23 stored elements in Compressed Sparse Row format&gt; . print(X3) . (0, 0) 8 (0, 4) 9 (0, 9) 3 (1, 2) 9 (1, 4) 7 (1, 9) 4 (2, 8) 8 (3, 3) 9 (3, 7) 4 (4, 1) 5 (4, 5) 7 (5, 1) 8 (5, 2) 8 (5, 3) 1 (5, 5) 1 (5, 6) 4 (6, 1) 18 (6, 9) 4 (7, 2) 4 (7, 6) 5 (8, 4) 5 (9, 3) 9 (9, 6) 4 . X3.todense() . matrix([[ 8, 0, 0, 0, 9, 0, 0, 0, 0, 3], [ 0, 0, 9, 0, 7, 0, 0, 0, 0, 4], [ 0, 0, 0, 0, 0, 0, 0, 0, 8, 0], [ 0, 0, 0, 9, 0, 0, 0, 4, 0, 0], [ 0, 5, 0, 0, 0, 7, 0, 0, 0, 0], [ 0, 8, 8, 1, 0, 1, 4, 0, 0, 0], [ 0, 18, 0, 0, 0, 0, 0, 0, 0, 4], [ 0, 0, 4, 0, 0, 0, 5, 0, 0, 0], [ 0, 0, 0, 0, 5, 0, 0, 0, 0, 0], [ 0, 0, 0, 9, 0, 0, 4, 0, 0, 0]]) . X4 = X2.tocsr() X4 . &lt;10x10 sparse matrix of type &#39;&lt;class &#39;numpy.longlong&#39;&gt;&#39; with 23 stored elements in Compressed Sparse Row format&gt; . print(X4) . (0, 0) 8 (0, 4) 9 (0, 9) 3 (1, 2) 9 (1, 4) 7 (1, 9) 4 (2, 8) 8 (3, 3) 9 (3, 7) 4 (4, 1) 5 (4, 5) 7 (5, 1) 8 (5, 2) 8 (5, 3) 1 (5, 5) 1 (5, 6) 4 (6, 1) 18 (6, 9) 4 (7, 2) 4 (7, 6) 5 (8, 4) 5 (9, 3) 9 (9, 6) 4 . X5 = X2.tocsc() X5 . &lt;10x10 sparse matrix of type &#39;&lt;class &#39;numpy.longlong&#39;&gt;&#39; with 23 stored elements in Compressed Sparse Column format&gt; . print(X5) . (0, 0) 8 (4, 1) 5 (5, 1) 8 (6, 1) 18 (1, 2) 9 (5, 2) 8 (7, 2) 4 (3, 3) 9 (5, 3) 1 (9, 3) 9 (0, 4) 9 (1, 4) 7 (8, 4) 5 (4, 5) 7 (5, 5) 1 (5, 6) 4 (7, 6) 5 (9, 6) 4 (3, 7) 4 (2, 8) 8 (0, 9) 3 (1, 9) 4 (6, 9) 4 . COO&#21512;&#35745;&#36716;&#25442; . coo_matrix会默认将重复元素求和，适合构造多分类模型的混淆矩阵 . rows = np.repeat([0, 1], 4) cols = np.repeat([0, 1], 4) vals = np.arange(8) . rows, cols, vals . (array([0, 0, 0, 0, 1, 1, 1, 1]), array([0, 0, 0, 0, 1, 1, 1, 1]), array([0, 1, 2, 3, 4, 5, 6, 7])) . X6 = sparse.coo_matrix((vals, (rows, cols))) X6.todense() . matrix([[ 6, 0], [ 0, 22]]) . 2X2&#28151;&#28102;&#30697;&#38453; . y_true = np.random.randint(0, 2, 100) y_pred = np.random.randint(0, 2, 100) vals = np.ones(100).astype(&quot;int&quot;) y_true, y_pred . (array([0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1]), array([0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0])) . vals.shape, y_true.shape, y_pred.shape . ((100,), (100,), (100,)) . X7 = sparse.coo_matrix((vals, (y_true, y_pred))) X7.todense() . matrix([[21, 23], [30, 26]]) . from sklearn.metrics import confusion_matrix confusion_matrix(y_true, y_pred) . array([[21, 23], [30, 26]]) . y_true = [&quot;cat&quot;, &quot;ant&quot;, &quot;cat&quot;, &quot;cat&quot;, &quot;ant&quot;, &quot;bird&quot;] y_pred = [&quot;ant&quot;, &quot;ant&quot;, &quot;cat&quot;, &quot;cat&quot;, &quot;ant&quot;, &quot;cat&quot;] confusion_matrix(y_true, y_pred, labels=[&quot;ant&quot;, &quot;bird&quot;, &quot;cat&quot;]) . array([[2, 0, 0], [0, 0, 1], [1, 0, 2]]) . Pandas . Series &#19982; Dataframe . Series：键值对形成的二序序列，有标签的numpy一维数组 | Dataframe：行列值三元序列（类似excel表），有标签的numpy二维数组 | Input/output | General functions | Pandas arrays | Index objects | Date offsets | Window | GroupBy | Resampling | Style | Plotting | General utility functions | Extensions | . &#21521;&#37327;&#21270;&#23383;&#31526;&#20018;&#25805;&#20316; . Pandas提供了一系列向量化字符串操作（vectorized string operation），极大地提高了字符串清洗效率。Pandas为包含字符串的Series和Index对象提供了str属性，既可以处理字符串，又可以处理缺失值。 . &#23383;&#31526;&#20018;&#26041;&#27861; . 所有Python内置的字符串方法都被复制到Pandas的向量化字符串方法中： . len() | lower() | translate() | islower() ljust() | upper() | startswith() | isupper() rjust() | find() | endswith() | isnumeric() center() | rfind() | isalnum() | isdecimal() zfill() | index() | isalpha() | split() strip() | rindex() | isdigit() | rsplit() rstrip() | capitalize() | isspace() | partition() lstrip() | swapcase() | istitle() | rpartition() . 这些方法的返回值并不完全相同，例如lower()方法返回字符串，len()方法返回数值，startswith(&#39;T&#39;)返回布尔值，split()方法返回列表 . monte = pd.Series( ( &quot;Gerald R. Ford&quot;, &quot;James Carter&quot;, &quot;Ronald Reagan&quot;, &quot;George H. W. Bush&quot;, &quot;William J. Clinton&quot;, &quot;George W. Bush&quot;, &quot;Barack Obama&quot;, &quot;Donald J. Trump&quot;, ) ) . monte.str.len() . 0 14 1 12 2 13 3 17 4 18 5 14 6 12 7 15 dtype: int64 . &#27491;&#21017;&#34920;&#36798;&#24335; . 有一些方法支持正则表达式处理字符串。下面是Pandas根据Python标准库的re模块函数实现的API： . 方法 描述 . match() | 对每个元素调用re.match()，返回布尔类型值 | . extract() | 对每个元素调用re.match()，返回匹配的字符串组（groups） | . findall() | 对每个元素调用re.findall() | . replace() | 用正则模式替换字符串 | . contains() | 对每个元素调用re.search()，返回布尔类型值 | . count() | 计算符合正则模式的字符串的数量 | . split() | 等价于str.split()，支持正则表达式 | . rsplit() | 等价于str.rsplit()，支持正则表达式 | . monte.str.extract(&#39;([A-Za-z]+)&#39;) . 0 . 0 Gerald | . 1 James | . 2 Ronald | . 3 George | . 4 William | . 5 George | . 6 Barack | . 7 Donald | . 找出所有开头和结尾都是辅音字母的名字——这可以用正则表达式中的开始符号（^）与结尾符号（$）来实现： . monte.str.findall(r&#39;^[^AEIOU].*[^aeiou]$&#39;) . 0 [Gerald R. Ford] 1 [James Carter] 2 [Ronald Reagan] 3 [George H. W. Bush] 4 [William J. Clinton] 5 [George W. Bush] 6 [] 7 [Donald J. Trump] dtype: object . &#20854;&#20182;&#23383;&#31526;&#20018;&#26041;&#27861; . 还有其他一些方法可以实现更方便的操作 . 方法 描述 . get() | 获取元素索引位置上的值，索引从0开始 | . slice() | 对元素进行切片取值 | . slice_replace() | 对元素进行切片替换 | . cat() | 连接字符串（此功能比较复杂，建议阅读文档） | . repeat() | 重复元素 | . normalize() | 将字符串转换为Unicode规范形式 | . pad() | 在字符串的左边、右边或两边增加空格 | . wrap() | 将字符串按照指定的宽度换行 | . join() | 用分隔符连接Series的每个元素 | . get_dummies() | 按照分隔符提取每个元素的dummy变量，转换为独热（one-hot）编码的DataFrame | . &#21521;&#37327;&#21270;&#23383;&#31526;&#20018;&#30340;&#21462;&#20540;&#19982;&#20999;&#29255;&#25805;&#20316; . get()与slice()操作可以从每个字符串数组中获取向量化元素。例如，我们可以通过str.slice(0, 3)获取每个字符串数组的前3个字符，df.str.slice(0, 3)=df.str[0:3]，df.str.get(i)=df.str[i] . monte.str[0:3] . 0 Ger 1 Jam 2 Ron 3 Geo 4 Wil 5 Geo 6 Bar 7 Don dtype: object . get()与slice()操作还可以在split()操作之后使用。例如，要获取每个姓名的姓（last name），可以结合使用split()与get()： . monte.str.split().str.get(-1) . 0 Ford 1 Carter 2 Reagan 3 Bush 4 Clinton 5 Bush 6 Obama 7 Trump dtype: object . &#25351;&#26631;&#21464;&#37327; . get_dummies()方法可以快速将指标变量分割成一个独热编码的DataFrame（每个元素都是0或1），如A=出生在美国、B=出生在英国、C=喜欢奶酪、D=喜欢午餐肉： . full_monte = pd.DataFrame( { &quot;name&quot;: monte, &quot;info&quot;: [&quot;B|C|D&quot;, &quot;B|D&quot;, &quot;A|C&quot;, &quot;B|D&quot;, &quot;B|C&quot;, &quot;A|C&quot;, &quot;B|D&quot;, &quot;B|C|D&quot;], } ) full_monte . name info . 0 Gerald R. Ford | B|C|D | . 1 James Carter | B|D | . 2 Ronald Reagan | A|C | . 3 George H. W. Bush | B|D | . 4 William J. Clinton | B|C | . 5 George W. Bush | A|C | . 6 Barack Obama | B|D | . 7 Donald J. Trump | B|C|D | . full_monte[&#39;info&#39;].str.get_dummies(&#39;|&#39;) . A B C D . 0 0 | 1 | 1 | 1 | . 1 0 | 1 | 0 | 1 | . 2 1 | 0 | 1 | 0 | . 3 0 | 1 | 0 | 1 | . 4 0 | 1 | 1 | 0 | . 5 1 | 0 | 1 | 0 | . 6 0 | 1 | 0 | 1 | . 7 0 | 1 | 1 | 1 | . &#22788;&#29702;&#26102;&#38388;&#24207;&#21015; . 由于Pandas最初是为金融模型而创建的，因此日期时间数据处理功能非常强大 . Pandas&#30340;&#26085;&#26399;&#19982;&#26102;&#38388;&#24037;&#20855; . Pandas所有关于日期与时间的处理方法全部都是通过Timestamp对象实现的，可以作为Series或DataFrame的索引DatetimeIndex。例如，可以用Pandas的方式演示前面介绍的日期与时间功能。我们可以灵活处理不同格式的日期与时间字符串，获取某一天是星期几： . date = pd.to_datetime(&quot;4th of May, 2020&quot;) date . Timestamp(&#39;2020-05-04 00:00:00&#39;) . date.strftime(&#39;%A&#39;) . &#39;Monday&#39; . 可以直接进行NumPy类型的向量化运算： . date + pd.to_timedelta(np.arange(12), &#39;D&#39;) . DatetimeIndex([&#39;2020-05-04&#39;, &#39;2020-05-05&#39;, &#39;2020-05-06&#39;, &#39;2020-05-07&#39;, &#39;2020-05-08&#39;, &#39;2020-05-09&#39;, &#39;2020-05-10&#39;, &#39;2020-05-11&#39;, &#39;2020-05-12&#39;, &#39;2020-05-13&#39;, &#39;2020-05-14&#39;, &#39;2020-05-15&#39;], dtype=&#39;datetime64[ns]&#39;, freq=None) . Pandas&#26102;&#38388;&#24207;&#21015;&#65306;&#29992;&#26102;&#38388;&#20316;&#32034;&#24341; . Pandas时间序列工具非常适合用来处理带时间戳的索引数据。 . 通过一个时间索引数据创建一个Series对象： . index = pd.DatetimeIndex([&quot;2019-01-04&quot;, &quot;2019-02-04&quot;, &quot;2020-03-04&quot;, &quot;2020-04-04&quot;]) data = pd.Series([0, 1, 2, 3], index=index) data . 2019-01-04 0 2019-02-04 1 2020-03-04 2 2020-04-04 3 dtype: int64 . 直接用日期进行切片取值： . data[&#39;2020-02-04&#39;:&#39;2020-04-04&#39;] . 2020-03-04 2 2020-04-04 3 dtype: int64 . 直接通过年份切片获取该年的数据： . data[&#39;2020&#39;] . 2020-03-04 2 2020-04-04 3 dtype: int64 . Pandas&#26102;&#38388;&#24207;&#21015;&#25968;&#25454;&#32467;&#26500; . 本节将介绍Pandas用来处理时间序列的基础数据类型。 . 时间戳，Pandas提供了Timestamp类型。本质上是Python的原生datetime类型的替代品，但是在性能更好的numpy.datetime64类型的基础上创建。对应的索引数据结构是DatetimeIndex。 | 时间周期，Pandas提供了Period类型。这是利用numpy.datetime64类型将固定频率的时间间隔进行编码。对应的索引数据结构是PeriodIndex。 | 时间增量或持续时间，Pandas提供了Timedelta类型。Timedelta是一种代替Python原生datetime.timedelta类型的高性能数据结构，同样是基于numpy.timedelta64类型。对应的索引数据结构是TimedeltaIndex。 | . 最基础的日期/时间对象是Timestamp和DatetimeIndex，对pd.to_datetime()传递一个日期会返回一个Timestamp类型，传递一个时间序列会返回一个DatetimeIndex类型： . from datetime import datetime dates = pd.to_datetime( [datetime(2020, 7, 3), &quot;4th of July, 2020&quot;, &quot;2020-Jul-6&quot;, &quot;07-07-2020&quot;, &quot;20200708&quot;] ) dates . DatetimeIndex([&#39;2020-07-03&#39;, &#39;2020-07-04&#39;, &#39;2020-07-06&#39;, &#39;2020-07-07&#39;, &#39;2020-07-08&#39;], dtype=&#39;datetime64[ns]&#39;, freq=None) . 任何DatetimeIndex类型都可以通过to_period()方法和一个频率代码转换成PeriodIndex类型。 . 用&#39;D&#39;将数据转换成单日的时间序列： . dates.to_period(&#39;D&#39;) . PeriodIndex([&#39;2020-07-03&#39;, &#39;2020-07-04&#39;, &#39;2020-07-06&#39;, &#39;2020-07-07&#39;, &#39;2020-07-08&#39;], dtype=&#39;period[D]&#39;, freq=&#39;D&#39;) . 当用一个日期减去另一个日期时，返回的结果是TimedeltaIndex类型： . dates - dates[0] . TimedeltaIndex([&#39;0 days&#39;, &#39;1 days&#39;, &#39;3 days&#39;, &#39;4 days&#39;, &#39;5 days&#39;], dtype=&#39;timedelta64[ns]&#39;, freq=None) . &#26377;&#35268;&#24459;&#30340;&#26102;&#38388;&#24207;&#21015;&#65306;pd.date_range() . 为了能更简便地创建有规律的时间序列，Pandas提供了一些方法：pd.date_range()可以处理时间戳、pd.period_range()可以处理周期、pd.timedelta_range()可以处理时间间隔。通过开始日期、结束日期和频率代码（同样是可选的）创建一个有规律的日期序列，默认的频率是天： . pd.date_range(&#39;2020-07-03&#39;, &#39;2020-07-10&#39;) . DatetimeIndex([&#39;2020-07-03&#39;, &#39;2020-07-04&#39;, &#39;2020-07-05&#39;, &#39;2020-07-06&#39;, &#39;2020-07-07&#39;, &#39;2020-07-08&#39;, &#39;2020-07-09&#39;, &#39;2020-07-10&#39;], dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;) . 日期范围不一定非是开始时间与结束时间，也可以是开始时间与周期数periods： . pd.date_range(&#39;2020-07-03&#39;, periods=8) . DatetimeIndex([&#39;2020-07-03&#39;, &#39;2020-07-04&#39;, &#39;2020-07-05&#39;, &#39;2020-07-06&#39;, &#39;2020-07-07&#39;, &#39;2020-07-08&#39;, &#39;2020-07-09&#39;, &#39;2020-07-10&#39;], dtype=&#39;datetime64[ns]&#39;, freq=&#39;D&#39;) . 通过freq参数改变时间间隔，默认值是D。例如，可以创建一个按小时变化的时间戳： . pd.date_range(&#39;2020-07-03&#39;, periods=8, freq=&#39;H&#39;) . DatetimeIndex([&#39;2020-07-03 00:00:00&#39;, &#39;2020-07-03 01:00:00&#39;, &#39;2020-07-03 02:00:00&#39;, &#39;2020-07-03 03:00:00&#39;, &#39;2020-07-03 04:00:00&#39;, &#39;2020-07-03 05:00:00&#39;, &#39;2020-07-03 06:00:00&#39;, &#39;2020-07-03 07:00:00&#39;], dtype=&#39;datetime64[ns]&#39;, freq=&#39;H&#39;) . 如果要创建一个有规律的周期或时间间隔序列，有类似的函数pd.period_range()和pd.timedelta_range()。下面是一个以月为周期的示例： . pd.period_range(&#39;2020-07&#39;, periods=8, freq=&#39;M&#39;) . PeriodIndex([&#39;2020-07&#39;, &#39;2020-08&#39;, &#39;2020-09&#39;, &#39;2020-10&#39;, &#39;2020-11&#39;, &#39;2020-12&#39;, &#39;2021-01&#39;, &#39;2021-02&#39;], dtype=&#39;period[M]&#39;, freq=&#39;M&#39;) . 以小时递增： . pd.timedelta_range(0, periods=10, freq=&#39;H&#39;) . TimedeltaIndex([&#39;00:00:00&#39;, &#39;01:00:00&#39;, &#39;02:00:00&#39;, &#39;03:00:00&#39;, &#39;04:00:00&#39;, &#39;05:00:00&#39;, &#39;06:00:00&#39;, &#39;07:00:00&#39;, &#39;08:00:00&#39;, &#39;09:00:00&#39;], dtype=&#39;timedelta64[ns]&#39;, freq=&#39;H&#39;) . &#26102;&#38388;&#39057;&#29575;&#19982;&#20559;&#31227;&#37327; . Pandas时间序列工具的基础是时间频率或偏移量（offset）代码。就像之前见过的D（day）和H（hour）代码，可以设置任意需要的时间间隔 . 代码 描述 代码 描述 . D | 天（calendar day，按日历算，含双休日） | B | 天（business day，仅含工作日） | . W | 周（weekly） | | | . M | 月末（month end） | BM | 月末（business month end，仅含工作日） | . Q | 季节末（quarter end） | BQ | 季节末（business quarter end，仅含工作日） | . A | 年末（year end） | BA | 年末（business year end，仅含工作日） | . H | 小时（hours） | BH | 小时（business hours，工作时间） | . T | 分钟（minutes） | | | . S | 秒（seconds） | | | . L | 毫秒（milliseonds） | | | . U | 微秒（microseconds） | | | . N | 纳秒（nanoseconds） | | | . 月、季、年频率都是具体周期的结束时间（月末、季末、年末），而有一些以S（start，开始） 为后缀的代码表示日期开始。 . 代码 频率 . MS | 月初（month start） | . BMS | 月初（business month start，仅含工作日） | . QS | 季初（quarter start） | . BQS | 季初（business quarter start，仅含工作日） | . AS | 年初（year start） | . BAS | 年初（business year start，仅含工作日） | . 另外，可以在频率代码后面加三位月份缩写字母来改变季、年频率的开始时间： . Q-JAN、BQ-FEB、QS-MAR、BQS-APR等 | A-JAN、BA-FEB、AS-MAR、BAS-APR等 | . 也可以在后面加三位星期缩写字母来改变一周的开始时间： . W-SUN、W-MON、W-TUE、W-WED等 | . 还可以将频率组合起来创建的新的周期。例如，可以用小时（H）和分钟（T）的组合来实现2小时30分钟： . pd.timedelta_range(0, periods=9, freq=&quot;2H30T&quot;) . TimedeltaIndex([&#39;00:00:00&#39;, &#39;02:30:00&#39;, &#39;05:00:00&#39;, &#39;07:30:00&#39;, &#39;10:00:00&#39;, &#39;12:30:00&#39;, &#39;15:00:00&#39;, &#39;17:30:00&#39;, &#39;20:00:00&#39;], dtype=&#39;timedelta64[ns]&#39;, freq=&#39;150T&#39;) . 所有这些频率代码都对应Pandas时间序列的偏移量，具体内容可以在pd.tseries.offsets模块中找到。例如，可以用下面的方法直接创建一个工作日偏移序列： . from pandas.tseries.offsets import BDay pd.date_range(&#39;2020-07-01&#39;, periods=5, freq=BDay()) . DatetimeIndex([&#39;2020-07-01&#39;, &#39;2020-07-02&#39;, &#39;2020-07-03&#39;, &#39;2020-07-06&#39;, &#39;2020-07-07&#39;], dtype=&#39;datetime64[ns]&#39;, freq=&#39;B&#39;) . &#37325;&#37319;&#26679;&#12289;&#26102;&#38388;&#36801;&#31227;&#21644;&#31383;&#21475;&#20989;&#25968; . 下面用贵州茅台的历史股票价格演示： . %%file snowball.py from datetime import datetime import requests import pandas as pd def get_stock(code): response = requests.get( &quot;https://stock.xueqiu.com/v5/stock/chart/kline.json&quot;, headers={ &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.138 Safari/537.36&quot; }, params=( (&quot;symbol&quot;, code), (&quot;begin&quot;, int(datetime.now().timestamp() * 1000)), (&quot;period&quot;, &quot;day&quot;), (&quot;type&quot;, &quot;before&quot;), (&quot;count&quot;, &quot;-5000&quot;), (&quot;indicator&quot;, &quot;kline&quot;), ), cookies={&quot;xq_a_token&quot;: &quot;328f8bbf7903261db206d83de7b85c58e4486dda&quot;,}, ) if response.ok: d = response.json()[&quot;data&quot;] data = pd.DataFrame(data=d[&quot;item&quot;], columns=d[&quot;column&quot;]) data.index = data.timestamp.apply( lambda _: pd.Timestamp(_, unit=&quot;ms&quot;, tz=&quot;Asia/Shanghai&quot;) ) return data else: print(&quot;stock error&quot;) . Writing snowball.py . from snowball import get_stock data = get_stock(&quot;SH600519&quot;) # 贵州茅台 data.tail() . timestamp volume open high low close chg percent turnoverrate amount volume_post amount_post . timestamp . 2020-05-08 00:00:00+08:00 1588867200000 | 2907868 | 1317.0 | 1338.00 | 1308.51 | 1314.61 | 2.61 | 0.20 | 0.23 | 3.839218e+09 | None | None | . 2020-05-11 00:00:00+08:00 1589126400000 | 2367119 | 1320.0 | 1335.00 | 1313.67 | 1323.01 | 8.40 | 0.64 | 0.19 | 3.135991e+09 | None | None | . 2020-05-12 00:00:00+08:00 1589212800000 | 1972181 | 1318.0 | 1334.99 | 1316.00 | 1333.00 | 9.99 | 0.76 | 0.16 | 2.621825e+09 | None | None | . 2020-05-13 00:00:00+08:00 1589299200000 | 2201431 | 1333.0 | 1337.99 | 1322.88 | 1335.95 | 2.95 | 0.22 | 0.18 | 2.931465e+09 | None | None | . 2020-05-14 00:00:00+08:00 1589385600000 | 1857492 | 1330.0 | 1334.88 | 1325.11 | 1326.59 | -9.36 | -0.70 | 0.15 | 2.467976e+09 | None | None | . gzmt = data[&#39;close&#39;] . gzmt.plot(figsize=(15,8)); plt.title(&#39;贵州茅台历史收盘价&#39;); . &#37325;&#37319;&#26679;&#19982;&#39057;&#29575;&#36716;&#25442; . 按照新的频率（更高频率、更低频率）对数据进行重采样，可以通过resample()方法、asfreq()方法。 . resample()方法是以数据累计（data aggregation）为基础 | asfreq()方法是以数据选择（data selection）为基础。 | 用两种方法对数据进行下采样（down-sample，减少采样频率，从日到月）。用每年末（&#39;BA&#39;，最后一个工作日）对数据进行重采样： . plt.figure(figsize=(15, 8)) gzmt.plot(alpha=0.5, style=&quot;-&quot;) gzmt.resample(&quot;BA&quot;).mean().plot(style=&quot;:&quot;) gzmt.asfreq(&quot;BA&quot;).plot(style=&quot;--&quot;) plt.title(&#39;贵州茅台历史收盘价年末采样&#39;); plt.legend([&quot;input&quot;, &quot;resample&quot;, &quot;asfreq&quot;], loc=&quot;upper left&quot;); . 在每个数据点上，resample反映的是上一年的均值，而asfreq反映的是上一年最后一个工作日的收盘价。 . 在进行上采样（up-sampling，增加采样频率，从月到日）时，resample()与asfreq()的用法大体相同， . 两种方法都默认将采样作为缺失值NaN，与pd.fillna()函数类似，asfreq()有一个method参数可以设置填充缺失值的方式。对数据按天进行重采样（包含周末），asfreq()向前填充与向后填充缺失值的结果对比： . fig, ax = plt.subplots(2, sharex=True, figsize=(15, 8)) data = gzmt.iloc[-14:] ax[0].set_title(&quot;贵州茅台近两周收盘价&quot;) data.asfreq(&quot;D&quot;).plot(ax=ax[0], marker=&quot;o&quot;) ax[1].set_title(&quot;采样缺失值填充方法对比&quot;) data.asfreq(&quot;D&quot;, method=&quot;bfill&quot;).plot(ax=ax[1], style=&quot;-o&quot;) data.asfreq(&quot;D&quot;, method=&quot;ffill&quot;).plot(ax=ax[1], style=&quot;--o&quot;) ax[1].legend([&quot;back-fill&quot;, &quot;forward-fill&quot;]); . &#26102;&#38388;&#36801;&#31227; . Pandas提供shift()方法迁移数据，tshift()方法迁移索引。两种方法都是按照频率代码进行迁移。 . 用shift()和tshift()这两种方法让数据迁移900天： . fig, ax = plt.subplots(3, sharey=True, figsize=(15, 8)) # 对数据应用时间频率，用向后填充解决缺失值 gzmt = gzmt.asfreq(&quot;D&quot;, method=&quot;pad&quot;) gzmt.plot(ax=ax[0]) gzmt.shift(900).plot(ax=ax[1]) gzmt.tshift(900).plot(ax=ax[2]) # 设置图例与标签 local_max = pd.to_datetime(&quot;2010-01-01&quot;) offset = pd.Timedelta(900, &quot;D&quot;) ax[0].legend([&quot;input&quot;], loc=2) ax[0].get_xticklabels()[5].set(weight=&quot;heavy&quot;, color=&quot;red&quot;) ax[0].axvline(local_max, alpha=0.3, color=&quot;red&quot;) ax[1].legend([&quot;shift(900)&quot;], loc=2) ax[1].get_xticklabels()[5].set(weight=&quot;heavy&quot;, color=&quot;red&quot;) ax[1].axvline(local_max + offset, alpha=0.3, color=&quot;red&quot;) ax[2].legend([&quot;tshift(900)&quot;], loc=2) ax[2].get_xticklabels()[1].set(weight=&quot;heavy&quot;, color=&quot;red&quot;) ax[2].axvline(local_max + offset, alpha=0.3, color=&quot;red&quot;); . shift(900)将数据向前推进了900天，这样图形中的一段就消失了（最左侧就变成了缺失值），而tshift(900)方法是将时间索引值向前推进了900天。 . 可以用迁移后的值来计算gzmtle股票一年期的投资回报率： . ROI = (gzmt.tshift(-365) / gzmt - 1) * 100 ROI.plot(figsize=(15, 8)) plt.title(&quot;贵州茅台年度ROI&quot;); . &#31227;&#21160;&#26102;&#38388;&#31383;&#21475; . Pandas处理时间序列数据的第3种操作是移动统计值（rolling statistics）。通过Series和DataFrame的rolling()属性实现，它会返回与groupby操作类似的结果。 . 计算茅台股票收盘价的一年期移动平均值和标准差： . rolling = gzmt.rolling(365, center=True) data = pd.DataFrame( { &quot;input&quot;: gzmt, &quot;one-year rolling_mean&quot;: rolling.mean(), &quot;one-year rolling_std&quot;: rolling.std(), } ) ax = data.plot(style=[&quot;-&quot;, &quot;--&quot;, &quot;:&quot;], figsize=(15, 8)) ax.lines[0].set_alpha(0.8) plt.title(&quot;贵州茅台一年期移动平均值和标准差&quot;); . &#39640;&#24615;&#33021;Pandas&#65306;eval()&#19982;query() . Pandas在处理复合代数式时（compound expression），每段中间过程都需要占用内存。Pandas从0.13版开始（2014年1月）基于Numexpr程序包实现了query()与eval()，可以避免中间过程直接运算，借助NumPy风格的字符串实现，可以比普通方法快一倍（而且内存消耗更少） . nrows, ncols = 100000, 100 rng = np.random.RandomState(42) df1, df2, df3, df4 = (pd.DataFrame(rng.rand(nrows, ncols)) for i in range(4)) . %timeit df1 + df2 + df3 + df4 . 46.6 ms ± 394 µs per loop (mean ± std. dev. of 7 runs, 10 loops each) . %timeit pd.eval(&#39;df1 + df2 + df3 + df4&#39;) . 28.3 ms ± 424 µs per loop (mean ± std. dev. of 7 runs, 10 loops each) . &#31639;&#26415;&#36816;&#31639;&#31526; . pd.eval()支持所有的算术运算符： . result1 = -df1 * df2 / (df3 + df4) result2 = pd.eval(&#39;-df1 * df2 / (df3 + df4)&#39;) np.allclose(result1, result2) . True . &#27604;&#36739;&#36816;&#31639;&#31526; . pd.eval()支持所有的比较运算符，包括链式代数式（chained expression）： . result1 = (df1 &lt; df2) &amp; (df2 &lt;= df3) &amp; (df3 != df4) result2 = pd.eval(&#39;df1 &lt; df2 &lt;= df3 != df4&#39;) np.allclose(result1, result2) . True . &#20301;&#36816;&#31639;&#31526; . pd.eval()支持&amp;（与）和|（或）等位运算符： . result1 = (df1 &lt; 0.5) &amp; (df2 &lt; 0.5) | (df3 &lt; df4) result2 = pd.eval(&#39;(df1 &lt; 0.5) &amp; (df2 &lt; 0.5) | (df3 &lt; df4)&#39;) np.allclose(result1, result2) . True . 还可以在布尔类型的代数式中使用and和or： . result3 = pd.eval(&#39;(df1 &lt; 0.5) and (df2 &lt; 0.5) or (df3 &lt; df4)&#39;) np.allclose(result1, result3) . True . &#23545;&#35937;&#23646;&#24615;&#19982;&#32034;&#24341; . pd.eval()可以通过obj.attr语法获取对象属性，通过obj[index]语法获取对象索引： . result1 = df2.T[0] + df3.iloc[1] result2 = pd.eval(&#39;df2.T[0] + df3.iloc[1]&#39;) np.allclose(result1, result2) . True . &#29992;DataFrame.eval()&#23454;&#29616;&#21015;&#38388;&#36816;&#31639; . 由于pd.eval()是Pandas的顶层函数，因此DataFrame有一个eval()方法可以做类似的运算。使用eval()方法的好处是可以借助列名称进行运算，示例如下： . df = pd.DataFrame(rng.rand(1000, 3), columns=[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]) df.head() . A B C . 0 0.615875 | 0.525167 | 0.047354 | . 1 0.330858 | 0.412879 | 0.441564 | . 2 0.689047 | 0.559068 | 0.230350 | . 3 0.290486 | 0.695479 | 0.852587 | . 4 0.424280 | 0.534344 | 0.245216 | . result1 = (df[&#39;A&#39;] + df[&#39;B&#39;]) / (df[&#39;C&#39;] - 1) result2 = pd.eval(&quot;(df.A + df.B) / (df.C - 1)&quot;) np.allclose(result1, result2) . True . result3 = df.eval(&#39;(A + B) / (C - 1)&#39;) np.allclose(result1, result3) . True . &#29992;DataFrame.eval()&#26032;&#22686;&#25110;&#20462;&#25913;&#21015; . 除了前面介绍的运算功能，DataFrame.eval()还可以创建新的列，创建一个新的列&#39;D&#39;： . df.eval(&#39;D = (A + B) / C&#39;, inplace=True) df.head() . A B C D . 0 0.615875 | 0.525167 | 0.047354 | 24.095868 | . 1 0.330858 | 0.412879 | 0.441564 | 1.684325 | . 2 0.689047 | 0.559068 | 0.230350 | 5.418335 | . 3 0.290486 | 0.695479 | 0.852587 | 1.156439 | . 4 0.424280 | 0.534344 | 0.245216 | 3.909296 | . 还可以修改已有的列： . df.eval(&#39;D = (A - B) / C&#39;, inplace=True) df.head() . A B C D . 0 0.615875 | 0.525167 | 0.047354 | 1.915527 | . 1 0.330858 | 0.412879 | 0.441564 | -0.185752 | . 2 0.689047 | 0.559068 | 0.230350 | 0.564268 | . 3 0.290486 | 0.695479 | 0.852587 | -0.475016 | . 4 0.424280 | 0.534344 | 0.245216 | -0.448844 | . DataFrame.eval()&#20351;&#29992;&#23616;&#37096;&#21464;&#37327; . DataFrame.eval()方法还支持通过@符号使用Python的局部变量，如下所示： . column_mean = df.mean(1) result1 = df[&#39;A&#39;] + column_mean result2 = df.eval(&#39;A + @column_mean&#39;) np.allclose(result1, result2) . True . @符号表示变量名称（Python对象的命名空间）而非列名称（DataFrame列名称的命名空间）。需要注意的是，@符号只能在DataFrame.eval()方法中使用，而不能在pandas.eval()函数中使用，因为pandas.eval()函数只能获取一个（Python）命名空间的内容。 . DataFrame.query()&#26041;&#27861; . 用query()方法进行过滤运算： . result1 = df[(df.A &lt; 0.5) &amp; (df.B &lt; 0.5)] result2 = pd.eval(&#39;df[(df.A &lt; 0.5) &amp; (df.B &lt; 0.5)]&#39;) np.allclose(result1, result2) . True . result3 = df.query(&#39;A &lt; 0.5 and B &lt; 0.5&#39;) np.allclose(result1, result3) . True . Cython&#19982;Numba . Cython . 直接将Python代码编译成C/C++，然后编译成Python模块： . 用Python代码调用原生C/C++ | 用静态类型声明让Python代码达到C语言的性能 | 代码变得更啰嗦，会破坏可维护性和可读性 | . &lt;/img&gt; . %load_ext Cython # %reload_ext Cython . %%cython cdef int a = 0 for i in range(10): a += i print(a) . 45 . 用Cython把.pyx文件编译（翻译）成.c文件。这些文件里的源代码，基本都是纯Python代码加上一些Cython代码 | .c文件被C语言编译器编译成.so库，这个库之后可以导入Python | 编译代码有3种方法： 创建一个distutils模块配置文件，生成自定义的C语言编译文件。 | 运行cython命令将.pyx文件编译成.c文件，然后用C语言编译器（gcc）把C代码手动编译成库文件。 | 用pyximport，像导入.py文件一样导入.pyx直接使用。 | | &#21019;&#24314;Cython&#27169;&#22359; . %%bash pwd rm -rf test_cython mkdir test_cython ls . /home/junjiet/data_science2020/2.数据处理 2.数据处理.ipynb cat_neural_network.mp4 cpp.ipynb data2info.png data_type.png markmap.png matlab_numpy.png nn_flow.png numpy.png pandas.png py_cy.png pysparkdf.png python_visual.png rdd.png sigmoid.png social_network.jpg test_cython two_layer_nn.png . cd test_cython . /home/junjiet/data_science2020/2.数据处理/test_cython . pwd . &#39;/home/junjiet/data_science2020/2.数据处理/test_cython&#39; . %%file test.pyx def join_n_print(parts): &quot;&quot;&quot;merge string list with space&quot;&quot;&quot; print(&#39; &#39;.join(parts)) . Writing test.pyx . ls . test.pyx . pyximport&#33258;&#21160;&#32534;&#35793; . %%cython import pyximport; pyximport.install() from test_cython.test import join_n_print join_n_print([&quot;This&quot;, &quot;is&quot;, &quot;a&quot;, &quot;test&quot;]) . This is a test . setup.py&#25163;&#21160;&#32534;&#35793; . %%file setup.py from distutils.core import setup from Cython.Build import cythonize setup( name=&quot;Test app&quot;, ext_modules=cythonize(&quot;test.pyx&quot;), ) . Writing setup.py . !python setup.py build_ext --inplace . running build_ext . ls . build/ setup.py test.c test.cpython-37m-x86_64-linux-gnu.so* test.pyx . !tree build/ . build/ └── temp.linux-x86_64-3.7 └── test.o 1 directory, 1 file . Cython通常都需要导入两类文件: . 定义文件：文件扩展名.pxd，是Cython文件要使用的变量、类型、函数名称的C语言声明。 | 实现文件：文件扩展名.pyx，包括在.pxd文件中已经定义好的函数实现。 | . %%file dishes.pxd cdef enum otherstuff: sausage, eggs, lettuce cdef struct spamdish: int oz_of_spam otherstuff filler . Writing dishes.pxd . %%file restaurant.pyx cimport dishes from dishes cimport spamdish cdef void prepare(spamdish * d): d.oz_of_spam = 42 d.filler = dishes.sausage def serve(): cdef spamdish d prepare( &amp; d) print(f&quot;{d.oz_of_spam} oz spam, filler no. {d.filler}&quot;) . Writing restaurant.pyx . &#35843;&#29992;Cython&#27169;&#22359; . ls . build/ setup.py test.c test.cpython-37m-x86_64-linux-gnu.so* test.pyx . from test_cython.test import join_n_print join_n_print([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]) . a b c . &#23450;&#20041;&#20989;&#25968;&#31867;&#22411; . Cython除了可以调用标准C语言函数，还可以定义两种函数： . 标准Python函数：与纯Python代码中声明的函数完全一样，用cdef关键字定义。接受Python对象作为参数，也返回Python对象 | C函数：是标准函数的优化版，用Python对象或C语言类型作为参数，返回值也可以是两种类型。要定义这种函数，用cpdef关键字定义 | . 虽然这两种函数都可以通过Cython模块调用。但是从Python代码(.py)中调用函数，必须是标准Python函数，或者cpdef关键字定义函数。这个关键字会创建一个函数的封装对象。当用Cython调用函数时，它用C语言对象；当从Python代码中调用函数时，它用纯Python函数。 . 下面是一个纯Python函数，因此Cython会让这个函数返回并接收一个Python对象，而不是C语言原生类型。 . %%cython cdef full_python_function (x): return x**2 . 这个函数使用了cpdef关键字，所以它既是一个标准函数，也是一个优化过的C语言函数。 . %%cython cpdef int c_function(int x): return x**2 . &#20248;&#21270;&#31034;&#20363; . 两经纬度地理距离，A点经纬度（110.0123, 23.32435），B点经纬度（129.1344,25.5465） . &#32431;Python . lon1, lat1, lon2, lat2 = 110.0123, 23.32435, 129.1344, 25.5465 num = 5000000 . %%file great_circle_py.py from math import pi, acos, cos, sin def great_circle(lon1, lat1, lon2, lat2): radius = 6371 # 公里 x = pi / 180 a = (90 - lat1) * (x) b = (90 - lat2) * (x) theta = (lon2 - lon1) * (x) c = acos((cos(a) * cos(b)) + (sin(a) * sin(b) * cos(theta))) return radius * c . Overwriting great_circle_py.py . from great_circle_py import great_circle for i in range(num): great_circle(lon1, lat1, lon2, lat2) . %%cython -a from math import pi, acos, cos, sin def great_circle(lon1, lat1, lon2, lat2): radius = 6371 # 公里 x = pi / 180 a = (90 - lat1) * (x) b = (90 - lat2) * (x) theta = (lon2 - lon1) * (x) c = acos((cos(a) * cos(b)) + (sin(a) * sin(b) * cos(theta))) return radius * c . building &#39;_cython_magic_510139e97843e1ad4066ec2ca94da783&#39; extension /home/junjiet/conda/bin/x86_64-conda_cos6-linux-gnu-cc -Wno-unused-result -Wsign-compare -DNDEBUG -fwrapv -O2 -Wall -Wstrict-prototypes -march=nocona -mtune=haswell -ftree-vectorize -fPIC -fstack-protector-strong -fno-plt -O2 -pipe -march=nocona -mtune=haswell -ftree-vectorize -fPIC -fstack-protector-strong -fno-plt -O2 -pipe -march=nocona -mtune=haswell -ftree-vectorize -fPIC -fstack-protector-strong -fno-plt -O2 -ffunction-sections -pipe -isystem /home/junjiet/conda/include -DNDEBUG -D_FORTIFY_SOURCE=2 -O2 -isystem /home/junjiet/conda/include -fPIC -I/home/junjiet/conda/include/python3.7m -c /home/junjiet/.cache/ipython/cython/_cython_magic_510139e97843e1ad4066ec2ca94da783.c -o /home/junjiet/.cache/ipython/cython/home/junjiet/.cache/ipython/cython/_cython_magic_510139e97843e1ad4066ec2ca94da783.o x86_64-conda_cos6-linux-gnu-gcc -pthread -shared -Wl,-O2 -Wl,--sort-common -Wl,--as-needed -Wl,-z,relro -Wl,-z,now -Wl,-rpath,/home/junjiet/conda/lib -L/home/junjiet/conda/lib -Wl,-O2 -Wl,--sort-common -Wl,--as-needed -Wl,-z,relro -Wl,-z,now -Wl,-rpath,/home/junjiet/conda/lib -L/home/junjiet/conda/lib -Wl,-O2 -Wl,--sort-common -Wl,--as-needed -Wl,-z,relro -Wl,-z,now -Wl,--disable-new-dtags -Wl,--gc-sections -Wl,-rpath,/home/junjiet/conda/lib -Wl,-rpath-link,/home/junjiet/conda/lib -L/home/junjiet/conda/lib -march=nocona -mtune=haswell -ftree-vectorize -fPIC -fstack-protector-strong -fno-plt -O2 -ffunction-sections -pipe -isystem /home/junjiet/conda/include -DNDEBUG -D_FORTIFY_SOURCE=2 -O2 -isystem /home/junjiet/conda/include /home/junjiet/.cache/ipython/cython/home/junjiet/.cache/ipython/cython/_cython_magic_510139e97843e1ad4066ec2ca94da783.o -o /home/junjiet/.cache/ipython/cython/_cython_magic_510139e97843e1ad4066ec2ca94da783.cpython-37m-x86_64-linux-gnu.so . &lt;!DOCTYPE html&gt; Cython: _cython_magic_510139e97843e1ad4066ec2ca94da783.pyx . Generated by Cython 0.29.15 . Yellow lines hint at Python interaction. Click on a line that starts with a &quot;+&quot; to see the C code that Cython generated for it. . &amp;#xA0;01: . +02: from math import pi, acos, cos, sin . __pyx_t_1 = PyList_New(4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_1); __Pyx_INCREF(__pyx_n_s_pi); __Pyx_GIVEREF(__pyx_n_s_pi); PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_pi); __Pyx_INCREF(__pyx_n_s_acos); __Pyx_GIVEREF(__pyx_n_s_acos); PyList_SET_ITEM(__pyx_t_1, 1, __pyx_n_s_acos); __Pyx_INCREF(__pyx_n_s_cos); __Pyx_GIVEREF(__pyx_n_s_cos); PyList_SET_ITEM(__pyx_t_1, 2, __pyx_n_s_cos); __Pyx_INCREF(__pyx_n_s_sin); __Pyx_GIVEREF(__pyx_n_s_sin); PyList_SET_ITEM(__pyx_t_1, 3, __pyx_n_s_sin); __pyx_t_2 = __Pyx_Import(__pyx_n_s_math, __pyx_t_1, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_2); __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0; __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_pi); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_1); if (PyDict_SetItem(__pyx_d, __pyx_n_s_pi, __pyx_t_1) &lt; 0) __PYX_ERR(0, 2, __pyx_L1_error) __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0; __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_acos); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_1); if (PyDict_SetItem(__pyx_d, __pyx_n_s_acos, __pyx_t_1) &lt; 0) __PYX_ERR(0, 2, __pyx_L1_error) __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0; __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_cos); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_1); if (PyDict_SetItem(__pyx_d, __pyx_n_s_cos, __pyx_t_1) &lt; 0) __PYX_ERR(0, 2, __pyx_L1_error) __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0; __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_sin); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_1); if (PyDict_SetItem(__pyx_d, __pyx_n_s_sin, __pyx_t_1) &lt; 0) __PYX_ERR(0, 2, __pyx_L1_error) __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0; __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0; . &amp;#xA0;03: . &amp;#xA0;04: . +05: def great_circle(lon1, lat1, lon2, lat2): . /* Python wrapper */ static PyObject *__pyx_pw_46_cython_magic_510139e97843e1ad4066ec2ca94da783_1great_circle(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/ static PyMethodDef __pyx_mdef_46_cython_magic_510139e97843e1ad4066ec2ca94da783_1great_circle = {&quot;great_circle&quot;, (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_46_cython_magic_510139e97843e1ad4066ec2ca94da783_1great_circle, METH_VARARGS|METH_KEYWORDS, 0}; static PyObject *__pyx_pw_46_cython_magic_510139e97843e1ad4066ec2ca94da783_1great_circle(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) { PyObject *__pyx_v_lon1 = 0; PyObject *__pyx_v_lat1 = 0; PyObject *__pyx_v_lon2 = 0; PyObject *__pyx_v_lat2 = 0; PyObject *__pyx_r = 0; __Pyx_RefNannyDeclarations __Pyx_RefNannySetupContext(&quot;great_circle (wrapper)&quot;, 0); { static PyObject **__pyx_pyargnames[] = {&amp;__pyx_n_s_lon1,&amp;__pyx_n_s_lat1,&amp;__pyx_n_s_lon2,&amp;__pyx_n_s_lat2,0}; PyObject* values[4] = {0,0,0,0}; if (unlikely(__pyx_kwds)) { Py_ssize_t kw_args; const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args); switch (pos_args) { case 4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3); CYTHON_FALLTHROUGH; case 3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2); CYTHON_FALLTHROUGH; case 2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1); CYTHON_FALLTHROUGH; case 1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0); CYTHON_FALLTHROUGH; case 0: break; default: goto __pyx_L5_argtuple_error; } kw_args = PyDict_Size(__pyx_kwds); switch (pos_args) { case 0: if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_lon1)) != 0)) kw_args--; else goto __pyx_L5_argtuple_error; CYTHON_FALLTHROUGH; case 1: if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_lat1)) != 0)) kw_args--; else { __Pyx_RaiseArgtupleInvalid(&quot;great_circle&quot;, 1, 4, 4, 1); __PYX_ERR(0, 5, __pyx_L3_error) } CYTHON_FALLTHROUGH; case 2: if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_lon2)) != 0)) kw_args--; else { __Pyx_RaiseArgtupleInvalid(&quot;great_circle&quot;, 1, 4, 4, 2); __PYX_ERR(0, 5, __pyx_L3_error) } CYTHON_FALLTHROUGH; case 3: if (likely((values[3] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_lat2)) != 0)) kw_args--; else { __Pyx_RaiseArgtupleInvalid(&quot;great_circle&quot;, 1, 4, 4, 3); __PYX_ERR(0, 5, __pyx_L3_error) } } if (unlikely(kw_args &gt; 0)) { if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, &quot;great_circle&quot;) &lt; 0)) __PYX_ERR(0, 5, __pyx_L3_error) } } else if (PyTuple_GET_SIZE(__pyx_args) != 4) { goto __pyx_L5_argtuple_error; } else { values[0] = PyTuple_GET_ITEM(__pyx_args, 0); values[1] = PyTuple_GET_ITEM(__pyx_args, 1); values[2] = PyTuple_GET_ITEM(__pyx_args, 2); values[3] = PyTuple_GET_ITEM(__pyx_args, 3); } __pyx_v_lon1 = values[0]; __pyx_v_lat1 = values[1]; __pyx_v_lon2 = values[2]; __pyx_v_lat2 = values[3]; } goto __pyx_L4_argument_unpacking_done; __pyx_L5_argtuple_error:; __Pyx_RaiseArgtupleInvalid(&quot;great_circle&quot;, 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 5, __pyx_L3_error) __pyx_L3_error:; __Pyx_AddTraceback(&quot;_cython_magic_510139e97843e1ad4066ec2ca94da783.great_circle&quot;, __pyx_clineno, __pyx_lineno, __pyx_filename); __Pyx_RefNannyFinishContext(); return NULL; __pyx_L4_argument_unpacking_done:; __pyx_r = __pyx_pf_46_cython_magic_510139e97843e1ad4066ec2ca94da783_great_circle(__pyx_self, __pyx_v_lon1, __pyx_v_lat1, __pyx_v_lon2, __pyx_v_lat2); /* function exit code */ __Pyx_RefNannyFinishContext(); return __pyx_r; } static PyObject *__pyx_pf_46_cython_magic_510139e97843e1ad4066ec2ca94da783_great_circle(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_lon1, PyObject *__pyx_v_lat1, PyObject *__pyx_v_lon2, PyObject *__pyx_v_lat2) { PyObject *__pyx_v_radius = NULL; PyObject *__pyx_v_x = NULL; PyObject *__pyx_v_a = NULL; PyObject *__pyx_v_b = NULL; PyObject *__pyx_v_theta = NULL; PyObject *__pyx_v_c = NULL; PyObject *__pyx_r = NULL; __Pyx_RefNannyDeclarations __Pyx_RefNannySetupContext(&quot;great_circle&quot;, 0); /* … */ /* function exit code */ __pyx_L1_error:; __Pyx_XDECREF(__pyx_t_1); __Pyx_XDECREF(__pyx_t_2); __Pyx_XDECREF(__pyx_t_3); __Pyx_XDECREF(__pyx_t_4); __Pyx_XDECREF(__pyx_t_5); __Pyx_XDECREF(__pyx_t_6); __Pyx_XDECREF(__pyx_t_7); __Pyx_AddTraceback(&quot;_cython_magic_510139e97843e1ad4066ec2ca94da783.great_circle&quot;, __pyx_clineno, __pyx_lineno, __pyx_filename); __pyx_r = NULL; __pyx_L0:; __Pyx_XDECREF(__pyx_v_radius); __Pyx_XDECREF(__pyx_v_x); __Pyx_XDECREF(__pyx_v_a); __Pyx_XDECREF(__pyx_v_b); __Pyx_XDECREF(__pyx_v_theta); __Pyx_XDECREF(__pyx_v_c); __Pyx_XGIVEREF(__pyx_r); __Pyx_RefNannyFinishContext(); return __pyx_r; } /* … */ __pyx_tuple_ = PyTuple_Pack(10, __pyx_n_s_lon1, __pyx_n_s_lat1, __pyx_n_s_lon2, __pyx_n_s_lat2, __pyx_n_s_radius, __pyx_n_s_x, __pyx_n_s_a, __pyx_n_s_b, __pyx_n_s_theta, __pyx_n_s_c); if (unlikely(!__pyx_tuple_)) __PYX_ERR(0, 5, __pyx_L1_error) __Pyx_GOTREF(__pyx_tuple_); __Pyx_GIVEREF(__pyx_tuple_); /* … */ __pyx_t_2 = PyCFunction_NewEx(&amp;__pyx_mdef_46_cython_magic_510139e97843e1ad4066ec2ca94da783_1great_circle, NULL, __pyx_n_s_cython_magic_510139e97843e1ad40); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 5, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_2); if (PyDict_SetItem(__pyx_d, __pyx_n_s_great_circle, __pyx_t_2) &lt; 0) __PYX_ERR(0, 5, __pyx_L1_error) __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0; . +06: radius = 6371 # 公里 . __Pyx_INCREF(__pyx_int_6371); __pyx_v_radius = __pyx_int_6371; . +07: x = pi / 180 . __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_pi); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 7, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_1); __pyx_t_2 = __Pyx_PyInt_TrueDivideObjC(__pyx_t_1, __pyx_int_180, 0xB4, 0, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 7, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_2); __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0; __pyx_v_x = __pyx_t_2; __pyx_t_2 = 0; . &amp;#xA0;08: . +09: a = (90 - lat1) * (x) . __pyx_t_2 = __Pyx_PyInt_SubtractCObj(__pyx_int_90, __pyx_v_lat1, 90, 0, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 9, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_2); __pyx_t_1 = PyNumber_Multiply(__pyx_t_2, __pyx_v_x); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 9, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_1); __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0; __pyx_v_a = __pyx_t_1; __pyx_t_1 = 0; . +10: b = (90 - lat2) * (x) . __pyx_t_1 = __Pyx_PyInt_SubtractCObj(__pyx_int_90, __pyx_v_lat2, 90, 0, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 10, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_1); __pyx_t_2 = PyNumber_Multiply(__pyx_t_1, __pyx_v_x); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 10, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_2); __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0; __pyx_v_b = __pyx_t_2; __pyx_t_2 = 0; . +11: theta = (lon2 - lon1) * (x) . __pyx_t_2 = PyNumber_Subtract(__pyx_v_lon2, __pyx_v_lon1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 11, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_2); __pyx_t_1 = PyNumber_Multiply(__pyx_t_2, __pyx_v_x); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 11, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_1); __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0; __pyx_v_theta = __pyx_t_1; __pyx_t_1 = 0; . +12: c = acos((cos(a) * cos(b)) + (sin(a) * sin(b) * cos(theta))) . __Pyx_GetModuleGlobalName(__pyx_t_2, __pyx_n_s_acos); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 12, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_2); __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_cos); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 12, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_4); __pyx_t_5 = NULL; if (CYTHON_UNPACK_METHODS &amp;&amp; unlikely(PyMethod_Check(__pyx_t_4))) { __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4); if (likely(__pyx_t_5)) { PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4); __Pyx_INCREF(__pyx_t_5); __Pyx_INCREF(function); __Pyx_DECREF_SET(__pyx_t_4, function); } } __pyx_t_3 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_5, __pyx_v_a) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_v_a); __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 12, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_3); __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0; __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_cos); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 12, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_5); __pyx_t_6 = NULL; if (CYTHON_UNPACK_METHODS &amp;&amp; unlikely(PyMethod_Check(__pyx_t_5))) { __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_5); if (likely(__pyx_t_6)) { PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5); __Pyx_INCREF(__pyx_t_6); __Pyx_INCREF(function); __Pyx_DECREF_SET(__pyx_t_5, function); } } __pyx_t_4 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_6, __pyx_v_b) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_v_b); __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 12, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_4); __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0; __pyx_t_5 = PyNumber_Multiply(__pyx_t_3, __pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 12, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_5); __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0; __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0; __Pyx_GetModuleGlobalName(__pyx_t_3, __pyx_n_s_sin); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 12, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_3); __pyx_t_6 = NULL; if (CYTHON_UNPACK_METHODS &amp;&amp; unlikely(PyMethod_Check(__pyx_t_3))) { __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_3); if (likely(__pyx_t_6)) { PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3); __Pyx_INCREF(__pyx_t_6); __Pyx_INCREF(function); __Pyx_DECREF_SET(__pyx_t_3, function); } } __pyx_t_4 = (__pyx_t_6) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_6, __pyx_v_a) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_a); __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 12, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_4); __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0; __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_sin); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 12, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_6); __pyx_t_7 = NULL; if (CYTHON_UNPACK_METHODS &amp;&amp; unlikely(PyMethod_Check(__pyx_t_6))) { __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_6); if (likely(__pyx_t_7)) { PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6); __Pyx_INCREF(__pyx_t_7); __Pyx_INCREF(function); __Pyx_DECREF_SET(__pyx_t_6, function); } } __pyx_t_3 = (__pyx_t_7) ? __Pyx_PyObject_Call2Args(__pyx_t_6, __pyx_t_7, __pyx_v_b) : __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_v_b); __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 12, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_3); __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0; __pyx_t_6 = PyNumber_Multiply(__pyx_t_4, __pyx_t_3); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 12, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_6); __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0; __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0; __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_cos); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 12, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_4); __pyx_t_7 = NULL; if (CYTHON_UNPACK_METHODS &amp;&amp; unlikely(PyMethod_Check(__pyx_t_4))) { __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_4); if (likely(__pyx_t_7)) { PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4); __Pyx_INCREF(__pyx_t_7); __Pyx_INCREF(function); __Pyx_DECREF_SET(__pyx_t_4, function); } } __pyx_t_3 = (__pyx_t_7) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_7, __pyx_v_theta) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_v_theta); __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 12, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_3); __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0; __pyx_t_4 = PyNumber_Multiply(__pyx_t_6, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 12, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_4); __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0; __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0; __pyx_t_3 = PyNumber_Add(__pyx_t_5, __pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 12, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_3); __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0; __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0; __pyx_t_4 = NULL; if (CYTHON_UNPACK_METHODS &amp;&amp; unlikely(PyMethod_Check(__pyx_t_2))) { __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2); if (likely(__pyx_t_4)) { PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2); __Pyx_INCREF(__pyx_t_4); __Pyx_INCREF(function); __Pyx_DECREF_SET(__pyx_t_2, function); } } __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_2, __pyx_t_4, __pyx_t_3) : __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3); __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0; __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0; if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 12, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_1); __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0; __pyx_v_c = __pyx_t_1; __pyx_t_1 = 0; . +13: return radius * c . __Pyx_XDECREF(__pyx_r); __pyx_t_1 = PyNumber_Multiply(__pyx_v_radius, __pyx_v_c); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 13, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_1); __pyx_r = __pyx_t_1; __pyx_t_1 = 0; goto __pyx_L0; . Cython&#32534;&#35793; . %%file great_circle_cy_v1.pyx from math import pi, acos, cos, sin def great_circle(double lon1, double lat1, double lon2, double lat2): cdef double a, b, theta, c, x, radius radius = 6371 # 公里 x = pi/180 a = (90-lat1)*(x) b = (90-lat2)*(x) theta = (lon2-lon1)*(x) c = acos((cos(a)*cos(b)) + (sin(a)*sin(b)*cos(theta))) return radius*c . Writing great_circle_cy_v1.pyx . %%file great_circle_setup_v1.py from distutils.core import setup from Cython.Build import cythonize setup( name=&#39;Great Circle module v1&#39;, ext_modules=cythonize(&quot;great_circle_cy_v1.pyx&quot;), ) . Writing great_circle_setup_v1.py . !python great_circle_setup_v1.py build_ext --inplace . Compiling great_circle_cy_v1.pyx because it changed. [1/1] Cythonizing great_circle_cy_v1.pyx /home/junjiet/conda/lib/python3.7/site-packages/Cython/Compiler/Main.py:369: FutureWarning: Cython directive &#39;language_level&#39; not set, using 2 for now (Py2). This will change in a later release! File: /home/junjiet/data_science2020/2.数据处理/test_cython/great_circle_cy_v1.pyx tree = Parsing.p_module(s, pxd, full_module_name) running build_ext building &#39;great_circle_cy_v1&#39; extension /home/junjiet/conda/bin/x86_64-conda_cos6-linux-gnu-cc -Wno-unused-result -Wsign-compare -DNDEBUG -fwrapv -O2 -Wall -Wstrict-prototypes -march=nocona -mtune=haswell -ftree-vectorize -fPIC -fstack-protector-strong -fno-plt -O2 -pipe -march=nocona -mtune=haswell -ftree-vectorize -fPIC -fstack-protector-strong -fno-plt -O2 -pipe -march=nocona -mtune=haswell -ftree-vectorize -fPIC -fstack-protector-strong -fno-plt -O2 -ffunction-sections -pipe -isystem /home/junjiet/conda/include -DNDEBUG -D_FORTIFY_SOURCE=2 -O2 -isystem /home/junjiet/conda/include -fPIC -I/home/junjiet/conda/include/python3.7m -c great_circle_cy_v1.c -o build/temp.linux-x86_64-3.7/great_circle_cy_v1.o x86_64-conda_cos6-linux-gnu-gcc -pthread -shared -Wl,-O2 -Wl,--sort-common -Wl,--as-needed -Wl,-z,relro -Wl,-z,now -Wl,-rpath,/home/junjiet/conda/lib -L/home/junjiet/conda/lib -Wl,-O2 -Wl,--sort-common -Wl,--as-needed -Wl,-z,relro -Wl,-z,now -Wl,-rpath,/home/junjiet/conda/lib -L/home/junjiet/conda/lib -Wl,-O2 -Wl,--sort-common -Wl,--as-needed -Wl,-z,relro -Wl,-z,now -Wl,--disable-new-dtags -Wl,--gc-sections -Wl,-rpath,/home/junjiet/conda/lib -Wl,-rpath-link,/home/junjiet/conda/lib -L/home/junjiet/conda/lib -march=nocona -mtune=haswell -ftree-vectorize -fPIC -fstack-protector-strong -fno-plt -O2 -ffunction-sections -pipe -isystem /home/junjiet/conda/include -DNDEBUG -D_FORTIFY_SOURCE=2 -O2 -isystem /home/junjiet/conda/include build/temp.linux-x86_64-3.7/great_circle_cy_v1.o -o /home/junjiet/data_science2020/2.数据处理/test_cython/great_circle_cy_v1.cpython-37m-x86_64-linux-gnu.so . ls . build/ great_circle_cy_v1.c great_circle_cy_v1.cpython-37m-x86_64-linux-gnu.so* great_circle_cy_v1.pyx great_circle_py.py great_circle_setup_v1.py __pycache__/ setup.py test.c test.cpython-37m-x86_64-linux-gnu.so* test.pyx . from great_circle_cy_v1 import great_circle for i in range(num): great_circle(lon1, lat1, lon2, lat2) . %%cython -a from math import pi, acos, cos, sin def great_circle(double lon1, double lat1, double lon2, double lat2): cdef double a, b, theta, c, x, radius radius = 6371 # 公里 x = pi/180 a = (90-lat1)*(x) b = (90-lat2)*(x) theta = (lon2-lon1)*(x) c = acos((cos(a)*cos(b)) + (sin(a)*sin(b)*cos(theta))) return radius*c . &lt;!DOCTYPE html&gt; Cython: _cython_magic_a8c9eb2e14c0c5fef8bdedbf1ab48c55.pyx . Generated by Cython 0.29.15 . Yellow lines hint at Python interaction. Click on a line that starts with a &quot;+&quot; to see the C code that Cython generated for it. . &amp;#xA0;01: . +02: from math import pi, acos, cos, sin . __pyx_t_1 = PyList_New(4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_1); __Pyx_INCREF(__pyx_n_s_pi); __Pyx_GIVEREF(__pyx_n_s_pi); PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_pi); __Pyx_INCREF(__pyx_n_s_acos); __Pyx_GIVEREF(__pyx_n_s_acos); PyList_SET_ITEM(__pyx_t_1, 1, __pyx_n_s_acos); __Pyx_INCREF(__pyx_n_s_cos); __Pyx_GIVEREF(__pyx_n_s_cos); PyList_SET_ITEM(__pyx_t_1, 2, __pyx_n_s_cos); __Pyx_INCREF(__pyx_n_s_sin); __Pyx_GIVEREF(__pyx_n_s_sin); PyList_SET_ITEM(__pyx_t_1, 3, __pyx_n_s_sin); __pyx_t_2 = __Pyx_Import(__pyx_n_s_math, __pyx_t_1, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_2); __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0; __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_pi); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_1); if (PyDict_SetItem(__pyx_d, __pyx_n_s_pi, __pyx_t_1) &lt; 0) __PYX_ERR(0, 2, __pyx_L1_error) __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0; __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_acos); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_1); if (PyDict_SetItem(__pyx_d, __pyx_n_s_acos, __pyx_t_1) &lt; 0) __PYX_ERR(0, 2, __pyx_L1_error) __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0; __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_cos); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_1); if (PyDict_SetItem(__pyx_d, __pyx_n_s_cos, __pyx_t_1) &lt; 0) __PYX_ERR(0, 2, __pyx_L1_error) __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0; __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_sin); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_1); if (PyDict_SetItem(__pyx_d, __pyx_n_s_sin, __pyx_t_1) &lt; 0) __PYX_ERR(0, 2, __pyx_L1_error) __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0; __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0; . &amp;#xA0;03: . +04: def great_circle(double lon1, double lat1, double lon2, double lat2): . /* Python wrapper */ static PyObject *__pyx_pw_46_cython_magic_a8c9eb2e14c0c5fef8bdedbf1ab48c55_1great_circle(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/ static PyMethodDef __pyx_mdef_46_cython_magic_a8c9eb2e14c0c5fef8bdedbf1ab48c55_1great_circle = {&quot;great_circle&quot;, (PyCFunction)(void*)(PyCFunctionWithKeywords)__pyx_pw_46_cython_magic_a8c9eb2e14c0c5fef8bdedbf1ab48c55_1great_circle, METH_VARARGS|METH_KEYWORDS, 0}; static PyObject *__pyx_pw_46_cython_magic_a8c9eb2e14c0c5fef8bdedbf1ab48c55_1great_circle(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) { double __pyx_v_lon1; double __pyx_v_lat1; double __pyx_v_lon2; double __pyx_v_lat2; PyObject *__pyx_r = 0; __Pyx_RefNannyDeclarations __Pyx_RefNannySetupContext(&quot;great_circle (wrapper)&quot;, 0); { static PyObject **__pyx_pyargnames[] = {&amp;__pyx_n_s_lon1,&amp;__pyx_n_s_lat1,&amp;__pyx_n_s_lon2,&amp;__pyx_n_s_lat2,0}; PyObject* values[4] = {0,0,0,0}; if (unlikely(__pyx_kwds)) { Py_ssize_t kw_args; const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args); switch (pos_args) { case 4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3); CYTHON_FALLTHROUGH; case 3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2); CYTHON_FALLTHROUGH; case 2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1); CYTHON_FALLTHROUGH; case 1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0); CYTHON_FALLTHROUGH; case 0: break; default: goto __pyx_L5_argtuple_error; } kw_args = PyDict_Size(__pyx_kwds); switch (pos_args) { case 0: if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_lon1)) != 0)) kw_args--; else goto __pyx_L5_argtuple_error; CYTHON_FALLTHROUGH; case 1: if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_lat1)) != 0)) kw_args--; else { __Pyx_RaiseArgtupleInvalid(&quot;great_circle&quot;, 1, 4, 4, 1); __PYX_ERR(0, 4, __pyx_L3_error) } CYTHON_FALLTHROUGH; case 2: if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_lon2)) != 0)) kw_args--; else { __Pyx_RaiseArgtupleInvalid(&quot;great_circle&quot;, 1, 4, 4, 2); __PYX_ERR(0, 4, __pyx_L3_error) } CYTHON_FALLTHROUGH; case 3: if (likely((values[3] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_lat2)) != 0)) kw_args--; else { __Pyx_RaiseArgtupleInvalid(&quot;great_circle&quot;, 1, 4, 4, 3); __PYX_ERR(0, 4, __pyx_L3_error) } } if (unlikely(kw_args &gt; 0)) { if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, &quot;great_circle&quot;) &lt; 0)) __PYX_ERR(0, 4, __pyx_L3_error) } } else if (PyTuple_GET_SIZE(__pyx_args) != 4) { goto __pyx_L5_argtuple_error; } else { values[0] = PyTuple_GET_ITEM(__pyx_args, 0); values[1] = PyTuple_GET_ITEM(__pyx_args, 1); values[2] = PyTuple_GET_ITEM(__pyx_args, 2); values[3] = PyTuple_GET_ITEM(__pyx_args, 3); } __pyx_v_lon1 = __pyx_PyFloat_AsDouble(values[0]); if (unlikely((__pyx_v_lon1 == (double)-1) &amp;&amp; PyErr_Occurred())) __PYX_ERR(0, 4, __pyx_L3_error) __pyx_v_lat1 = __pyx_PyFloat_AsDouble(values[1]); if (unlikely((__pyx_v_lat1 == (double)-1) &amp;&amp; PyErr_Occurred())) __PYX_ERR(0, 4, __pyx_L3_error) __pyx_v_lon2 = __pyx_PyFloat_AsDouble(values[2]); if (unlikely((__pyx_v_lon2 == (double)-1) &amp;&amp; PyErr_Occurred())) __PYX_ERR(0, 4, __pyx_L3_error) __pyx_v_lat2 = __pyx_PyFloat_AsDouble(values[3]); if (unlikely((__pyx_v_lat2 == (double)-1) &amp;&amp; PyErr_Occurred())) __PYX_ERR(0, 4, __pyx_L3_error) } goto __pyx_L4_argument_unpacking_done; __pyx_L5_argtuple_error:; __Pyx_RaiseArgtupleInvalid(&quot;great_circle&quot;, 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 4, __pyx_L3_error) __pyx_L3_error:; __Pyx_AddTraceback(&quot;_cython_magic_a8c9eb2e14c0c5fef8bdedbf1ab48c55.great_circle&quot;, __pyx_clineno, __pyx_lineno, __pyx_filename); __Pyx_RefNannyFinishContext(); return NULL; __pyx_L4_argument_unpacking_done:; __pyx_r = __pyx_pf_46_cython_magic_a8c9eb2e14c0c5fef8bdedbf1ab48c55_great_circle(__pyx_self, __pyx_v_lon1, __pyx_v_lat1, __pyx_v_lon2, __pyx_v_lat2); /* function exit code */ __Pyx_RefNannyFinishContext(); return __pyx_r; } static PyObject *__pyx_pf_46_cython_magic_a8c9eb2e14c0c5fef8bdedbf1ab48c55_great_circle(CYTHON_UNUSED PyObject *__pyx_self, double __pyx_v_lon1, double __pyx_v_lat1, double __pyx_v_lon2, double __pyx_v_lat2) { double __pyx_v_a; double __pyx_v_b; double __pyx_v_theta; double __pyx_v_c; double __pyx_v_x; double __pyx_v_radius; PyObject *__pyx_r = NULL; __Pyx_RefNannyDeclarations __Pyx_RefNannySetupContext(&quot;great_circle&quot;, 0); /* … */ /* function exit code */ __pyx_L1_error:; __Pyx_XDECREF(__pyx_t_1); __Pyx_XDECREF(__pyx_t_2); __Pyx_XDECREF(__pyx_t_4); __Pyx_XDECREF(__pyx_t_5); __Pyx_XDECREF(__pyx_t_6); __Pyx_XDECREF(__pyx_t_7); __Pyx_XDECREF(__pyx_t_8); __Pyx_XDECREF(__pyx_t_9); __Pyx_AddTraceback(&quot;_cython_magic_a8c9eb2e14c0c5fef8bdedbf1ab48c55.great_circle&quot;, __pyx_clineno, __pyx_lineno, __pyx_filename); __pyx_r = NULL; __pyx_L0:; __Pyx_XGIVEREF(__pyx_r); __Pyx_RefNannyFinishContext(); return __pyx_r; } /* … */ __pyx_tuple_ = PyTuple_Pack(10, __pyx_n_s_lon1, __pyx_n_s_lat1, __pyx_n_s_lon2, __pyx_n_s_lat2, __pyx_n_s_a, __pyx_n_s_b, __pyx_n_s_theta, __pyx_n_s_c, __pyx_n_s_x, __pyx_n_s_radius); if (unlikely(!__pyx_tuple_)) __PYX_ERR(0, 4, __pyx_L1_error) __Pyx_GOTREF(__pyx_tuple_); __Pyx_GIVEREF(__pyx_tuple_); /* … */ __pyx_t_2 = PyCFunction_NewEx(&amp;__pyx_mdef_46_cython_magic_a8c9eb2e14c0c5fef8bdedbf1ab48c55_1great_circle, NULL, __pyx_n_s_cython_magic_a8c9eb2e14c0c5fef8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_2); if (PyDict_SetItem(__pyx_d, __pyx_n_s_great_circle, __pyx_t_2) &lt; 0) __PYX_ERR(0, 4, __pyx_L1_error) __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0; . &amp;#xA0;05: cdef double a, b, theta, c, x, radius . &amp;#xA0;06: . +07: radius = 6371 # 公里 . __pyx_v_radius = 6371.0; . +08: x = pi/180 . __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_pi); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 8, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_1); __pyx_t_2 = __Pyx_PyInt_TrueDivideObjC(__pyx_t_1, __pyx_int_180, 0xB4, 0, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 8, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_2); __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0; __pyx_t_3 = __pyx_PyFloat_AsDouble(__pyx_t_2); if (unlikely((__pyx_t_3 == (double)-1) &amp;&amp; PyErr_Occurred())) __PYX_ERR(0, 8, __pyx_L1_error) __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0; __pyx_v_x = __pyx_t_3; . &amp;#xA0;09: . +10: a = (90-lat1)*(x) . __pyx_v_a = ((90.0 - __pyx_v_lat1) * __pyx_v_x); . +11: b = (90-lat2)*(x) . __pyx_v_b = ((90.0 - __pyx_v_lat2) * __pyx_v_x); . +12: theta = (lon2-lon1)*(x) . __pyx_v_theta = ((__pyx_v_lon2 - __pyx_v_lon1) * __pyx_v_x); . +13: c = acos((cos(a)*cos(b)) + (sin(a)*sin(b)*cos(theta))) . __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_acos); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 13, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_1); __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_cos); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 13, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_5); __pyx_t_6 = PyFloat_FromDouble(__pyx_v_a); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 13, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_6); __pyx_t_7 = NULL; if (CYTHON_UNPACK_METHODS &amp;&amp; unlikely(PyMethod_Check(__pyx_t_5))) { __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_5); if (likely(__pyx_t_7)) { PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5); __Pyx_INCREF(__pyx_t_7); __Pyx_INCREF(function); __Pyx_DECREF_SET(__pyx_t_5, function); } } __pyx_t_4 = (__pyx_t_7) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_7, __pyx_t_6) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_t_6); __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0; __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 13, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_4); __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0; __Pyx_GetModuleGlobalName(__pyx_t_6, __pyx_n_s_cos); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 13, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_6); __pyx_t_7 = PyFloat_FromDouble(__pyx_v_b); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 13, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_7); __pyx_t_8 = NULL; if (CYTHON_UNPACK_METHODS &amp;&amp; unlikely(PyMethod_Check(__pyx_t_6))) { __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_6); if (likely(__pyx_t_8)) { PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_6); __Pyx_INCREF(__pyx_t_8); __Pyx_INCREF(function); __Pyx_DECREF_SET(__pyx_t_6, function); } } __pyx_t_5 = (__pyx_t_8) ? __Pyx_PyObject_Call2Args(__pyx_t_6, __pyx_t_8, __pyx_t_7) : __Pyx_PyObject_CallOneArg(__pyx_t_6, __pyx_t_7); __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0; __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 13, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_5); __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0; __pyx_t_6 = PyNumber_Multiply(__pyx_t_4, __pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 13, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_6); __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0; __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0; __Pyx_GetModuleGlobalName(__pyx_t_4, __pyx_n_s_sin); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 13, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_4); __pyx_t_7 = PyFloat_FromDouble(__pyx_v_a); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 13, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_7); __pyx_t_8 = NULL; if (CYTHON_UNPACK_METHODS &amp;&amp; unlikely(PyMethod_Check(__pyx_t_4))) { __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_4); if (likely(__pyx_t_8)) { PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4); __Pyx_INCREF(__pyx_t_8); __Pyx_INCREF(function); __Pyx_DECREF_SET(__pyx_t_4, function); } } __pyx_t_5 = (__pyx_t_8) ? __Pyx_PyObject_Call2Args(__pyx_t_4, __pyx_t_8, __pyx_t_7) : __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_7); __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0; __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 13, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_5); __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0; __Pyx_GetModuleGlobalName(__pyx_t_7, __pyx_n_s_sin); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 13, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_7); __pyx_t_8 = PyFloat_FromDouble(__pyx_v_b); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 13, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_8); __pyx_t_9 = NULL; if (CYTHON_UNPACK_METHODS &amp;&amp; unlikely(PyMethod_Check(__pyx_t_7))) { __pyx_t_9 = PyMethod_GET_SELF(__pyx_t_7); if (likely(__pyx_t_9)) { PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_7); __Pyx_INCREF(__pyx_t_9); __Pyx_INCREF(function); __Pyx_DECREF_SET(__pyx_t_7, function); } } __pyx_t_4 = (__pyx_t_9) ? __Pyx_PyObject_Call2Args(__pyx_t_7, __pyx_t_9, __pyx_t_8) : __Pyx_PyObject_CallOneArg(__pyx_t_7, __pyx_t_8); __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0; __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 13, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_4); __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0; __pyx_t_7 = PyNumber_Multiply(__pyx_t_5, __pyx_t_4); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 13, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_7); __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0; __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0; __Pyx_GetModuleGlobalName(__pyx_t_5, __pyx_n_s_cos); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 13, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_5); __pyx_t_8 = PyFloat_FromDouble(__pyx_v_theta); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 13, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_8); __pyx_t_9 = NULL; if (CYTHON_UNPACK_METHODS &amp;&amp; unlikely(PyMethod_Check(__pyx_t_5))) { __pyx_t_9 = PyMethod_GET_SELF(__pyx_t_5); if (likely(__pyx_t_9)) { PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5); __Pyx_INCREF(__pyx_t_9); __Pyx_INCREF(function); __Pyx_DECREF_SET(__pyx_t_5, function); } } __pyx_t_4 = (__pyx_t_9) ? __Pyx_PyObject_Call2Args(__pyx_t_5, __pyx_t_9, __pyx_t_8) : __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_t_8); __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0; __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 13, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_4); __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0; __pyx_t_5 = PyNumber_Multiply(__pyx_t_7, __pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 13, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_5); __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0; __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0; __pyx_t_4 = PyNumber_Add(__pyx_t_6, __pyx_t_5); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 13, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_4); __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0; __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0; __pyx_t_5 = NULL; if (CYTHON_UNPACK_METHODS &amp;&amp; unlikely(PyMethod_Check(__pyx_t_1))) { __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_1); if (likely(__pyx_t_5)) { PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1); __Pyx_INCREF(__pyx_t_5); __Pyx_INCREF(function); __Pyx_DECREF_SET(__pyx_t_1, function); } } __pyx_t_2 = (__pyx_t_5) ? __Pyx_PyObject_Call2Args(__pyx_t_1, __pyx_t_5, __pyx_t_4) : __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_t_4); __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0; __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 13, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_2); __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0; __pyx_t_3 = __pyx_PyFloat_AsDouble(__pyx_t_2); if (unlikely((__pyx_t_3 == (double)-1) &amp;&amp; PyErr_Occurred())) __PYX_ERR(0, 13, __pyx_L1_error) __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0; __pyx_v_c = __pyx_t_3; . +14: return radius*c . __Pyx_XDECREF(__pyx_r); __pyx_t_2 = PyFloat_FromDouble((__pyx_v_radius * __pyx_v_c)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 14, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_2); __pyx_r = __pyx_t_2; __pyx_t_2 = 0; goto __pyx_L0; . C&#26631;&#20934;&#24211;&#20989;&#25968; . %%file great_circle_cy_v2.pyx cdef extern from &quot;math.h&quot;: float cosf(float theta) float sinf(float theta) float acosf(float theta) cpdef double great_circle(double lon1, double lat1, double lon2, double lat2): cdef double a, b, theta, c, x, radius cdef double pi = 3.141592653589793 radius = 6371 # 公里 x = pi/180 a = (90-lat1)*(x) b = (90-lat2)*(x) theta = (lon2-lon1)*(x) c = acosf((cosf(a)*cosf(b)) + (sinf(a)*sinf(b)*cosf(theta))) return radius*c . Writing great_circle_cy_v2.pyx . %%file great_circle_setup_v2.py from distutils.core import setup from Cython.Build import cythonize setup( name=&quot;Great Circle module v2&quot;, ext_modules=cythonize(&quot;great_circle_cy_v2.pyx&quot;), ) . Writing great_circle_setup_v2.py . !python great_circle_setup_v2.py build_ext --inplace . Compiling great_circle_cy_v2.pyx because it changed. [1/1] Cythonizing great_circle_cy_v2.pyx /home/junjiet/conda/lib/python3.7/site-packages/Cython/Compiler/Main.py:369: FutureWarning: Cython directive &#39;language_level&#39; not set, using 2 for now (Py2). This will change in a later release! File: /home/junjiet/data_science2020/2.数据处理/test_cython/great_circle_cy_v2.pyx tree = Parsing.p_module(s, pxd, full_module_name) running build_ext building &#39;great_circle_cy_v2&#39; extension /home/junjiet/conda/bin/x86_64-conda_cos6-linux-gnu-cc -Wno-unused-result -Wsign-compare -DNDEBUG -fwrapv -O2 -Wall -Wstrict-prototypes -march=nocona -mtune=haswell -ftree-vectorize -fPIC -fstack-protector-strong -fno-plt -O2 -pipe -march=nocona -mtune=haswell -ftree-vectorize -fPIC -fstack-protector-strong -fno-plt -O2 -pipe -march=nocona -mtune=haswell -ftree-vectorize -fPIC -fstack-protector-strong -fno-plt -O2 -ffunction-sections -pipe -isystem /home/junjiet/conda/include -DNDEBUG -D_FORTIFY_SOURCE=2 -O2 -isystem /home/junjiet/conda/include -fPIC -I/home/junjiet/conda/include/python3.7m -c great_circle_cy_v2.c -o build/temp.linux-x86_64-3.7/great_circle_cy_v2.o x86_64-conda_cos6-linux-gnu-gcc -pthread -shared -Wl,-O2 -Wl,--sort-common -Wl,--as-needed -Wl,-z,relro -Wl,-z,now -Wl,-rpath,/home/junjiet/conda/lib -L/home/junjiet/conda/lib -Wl,-O2 -Wl,--sort-common -Wl,--as-needed -Wl,-z,relro -Wl,-z,now -Wl,-rpath,/home/junjiet/conda/lib -L/home/junjiet/conda/lib -Wl,-O2 -Wl,--sort-common -Wl,--as-needed -Wl,-z,relro -Wl,-z,now -Wl,--disable-new-dtags -Wl,--gc-sections -Wl,-rpath,/home/junjiet/conda/lib -Wl,-rpath-link,/home/junjiet/conda/lib -L/home/junjiet/conda/lib -march=nocona -mtune=haswell -ftree-vectorize -fPIC -fstack-protector-strong -fno-plt -O2 -ffunction-sections -pipe -isystem /home/junjiet/conda/include -DNDEBUG -D_FORTIFY_SOURCE=2 -O2 -isystem /home/junjiet/conda/include build/temp.linux-x86_64-3.7/great_circle_cy_v2.o -o /home/junjiet/data_science2020/2.数据处理/test_cython/great_circle_cy_v2.cpython-37m-x86_64-linux-gnu.so . from great_circle_cy_v2 import great_circle for i in range(num): great_circle(lon1, lat1, lon2, lat2) . %%cython -a cdef extern from &quot;math.h&quot;: float cosf(float theta) float sinf(float theta) float acosf(float theta) cpdef double great_circle(double lon1, double lat1, double lon2, double lat2): cdef double a, b, theta, c, x, radius cdef double pi = 3.141592653589793 radius = 6371 # 公里 x = pi/180 a = (90-lat1)*(x) b = (90-lat2)*(x) theta = (lon2-lon1)*(x) c = acosf((cosf(a)*cosf(b)) + (sinf(a)*sinf(b)*cosf(theta))) return radius*c . &lt;!DOCTYPE html&gt; Cython: _cython_magic_001d315da99fd0491a49a895f572c5f0.pyx . Generated by Cython 0.29.15 . Yellow lines hint at Python interaction. Click on a line that starts with a &quot;+&quot; to see the C code that Cython generated for it. . &amp;#xA0;01: . &amp;#xA0;02: cdef extern from &quot;math.h&quot;: . &amp;#xA0;03: float cosf(float theta) . &amp;#xA0;04: float sinf(float theta) . &amp;#xA0;05: float acosf(float theta) . &amp;#xA0;06: . +07: cpdef double great_circle(double lon1, double lat1, double lon2, double lat2): . static PyObject *__pyx_pw_46_cython_magic_001d315da99fd0491a49a895f572c5f0_1great_circle(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/ static double __pyx_f_46_cython_magic_001d315da99fd0491a49a895f572c5f0_great_circle(double __pyx_v_lon1, double __pyx_v_lat1, double __pyx_v_lon2, double __pyx_v_lat2, CYTHON_UNUSED int __pyx_skip_dispatch) { double __pyx_v_a; double __pyx_v_b; double __pyx_v_theta; double __pyx_v_c; double __pyx_v_x; double __pyx_v_radius; double __pyx_v_pi; double __pyx_r; __Pyx_RefNannyDeclarations __Pyx_RefNannySetupContext(&quot;great_circle&quot;, 0); /* … */ /* function exit code */ __pyx_L0:; __Pyx_RefNannyFinishContext(); return __pyx_r; } /* Python wrapper */ static PyObject *__pyx_pw_46_cython_magic_001d315da99fd0491a49a895f572c5f0_1great_circle(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/ static PyObject *__pyx_pw_46_cython_magic_001d315da99fd0491a49a895f572c5f0_1great_circle(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) { double __pyx_v_lon1; double __pyx_v_lat1; double __pyx_v_lon2; double __pyx_v_lat2; PyObject *__pyx_r = 0; __Pyx_RefNannyDeclarations __Pyx_RefNannySetupContext(&quot;great_circle (wrapper)&quot;, 0); { static PyObject **__pyx_pyargnames[] = {&amp;__pyx_n_s_lon1,&amp;__pyx_n_s_lat1,&amp;__pyx_n_s_lon2,&amp;__pyx_n_s_lat2,0}; PyObject* values[4] = {0,0,0,0}; if (unlikely(__pyx_kwds)) { Py_ssize_t kw_args; const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args); switch (pos_args) { case 4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3); CYTHON_FALLTHROUGH; case 3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2); CYTHON_FALLTHROUGH; case 2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1); CYTHON_FALLTHROUGH; case 1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0); CYTHON_FALLTHROUGH; case 0: break; default: goto __pyx_L5_argtuple_error; } kw_args = PyDict_Size(__pyx_kwds); switch (pos_args) { case 0: if (likely((values[0] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_lon1)) != 0)) kw_args--; else goto __pyx_L5_argtuple_error; CYTHON_FALLTHROUGH; case 1: if (likely((values[1] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_lat1)) != 0)) kw_args--; else { __Pyx_RaiseArgtupleInvalid(&quot;great_circle&quot;, 1, 4, 4, 1); __PYX_ERR(0, 7, __pyx_L3_error) } CYTHON_FALLTHROUGH; case 2: if (likely((values[2] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_lon2)) != 0)) kw_args--; else { __Pyx_RaiseArgtupleInvalid(&quot;great_circle&quot;, 1, 4, 4, 2); __PYX_ERR(0, 7, __pyx_L3_error) } CYTHON_FALLTHROUGH; case 3: if (likely((values[3] = __Pyx_PyDict_GetItemStr(__pyx_kwds, __pyx_n_s_lat2)) != 0)) kw_args--; else { __Pyx_RaiseArgtupleInvalid(&quot;great_circle&quot;, 1, 4, 4, 3); __PYX_ERR(0, 7, __pyx_L3_error) } } if (unlikely(kw_args &gt; 0)) { if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, &quot;great_circle&quot;) &lt; 0)) __PYX_ERR(0, 7, __pyx_L3_error) } } else if (PyTuple_GET_SIZE(__pyx_args) != 4) { goto __pyx_L5_argtuple_error; } else { values[0] = PyTuple_GET_ITEM(__pyx_args, 0); values[1] = PyTuple_GET_ITEM(__pyx_args, 1); values[2] = PyTuple_GET_ITEM(__pyx_args, 2); values[3] = PyTuple_GET_ITEM(__pyx_args, 3); } __pyx_v_lon1 = __pyx_PyFloat_AsDouble(values[0]); if (unlikely((__pyx_v_lon1 == (double)-1) &amp;&amp; PyErr_Occurred())) __PYX_ERR(0, 7, __pyx_L3_error) __pyx_v_lat1 = __pyx_PyFloat_AsDouble(values[1]); if (unlikely((__pyx_v_lat1 == (double)-1) &amp;&amp; PyErr_Occurred())) __PYX_ERR(0, 7, __pyx_L3_error) __pyx_v_lon2 = __pyx_PyFloat_AsDouble(values[2]); if (unlikely((__pyx_v_lon2 == (double)-1) &amp;&amp; PyErr_Occurred())) __PYX_ERR(0, 7, __pyx_L3_error) __pyx_v_lat2 = __pyx_PyFloat_AsDouble(values[3]); if (unlikely((__pyx_v_lat2 == (double)-1) &amp;&amp; PyErr_Occurred())) __PYX_ERR(0, 7, __pyx_L3_error) } goto __pyx_L4_argument_unpacking_done; __pyx_L5_argtuple_error:; __Pyx_RaiseArgtupleInvalid(&quot;great_circle&quot;, 1, 4, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 7, __pyx_L3_error) __pyx_L3_error:; __Pyx_AddTraceback(&quot;_cython_magic_001d315da99fd0491a49a895f572c5f0.great_circle&quot;, __pyx_clineno, __pyx_lineno, __pyx_filename); __Pyx_RefNannyFinishContext(); return NULL; __pyx_L4_argument_unpacking_done:; __pyx_r = __pyx_pf_46_cython_magic_001d315da99fd0491a49a895f572c5f0_great_circle(__pyx_self, __pyx_v_lon1, __pyx_v_lat1, __pyx_v_lon2, __pyx_v_lat2); /* function exit code */ __Pyx_RefNannyFinishContext(); return __pyx_r; } static PyObject *__pyx_pf_46_cython_magic_001d315da99fd0491a49a895f572c5f0_great_circle(CYTHON_UNUSED PyObject *__pyx_self, double __pyx_v_lon1, double __pyx_v_lat1, double __pyx_v_lon2, double __pyx_v_lat2) { PyObject *__pyx_r = NULL; __Pyx_RefNannyDeclarations __Pyx_RefNannySetupContext(&quot;great_circle&quot;, 0); __Pyx_XDECREF(__pyx_r); __pyx_t_1 = PyFloat_FromDouble(__pyx_f_46_cython_magic_001d315da99fd0491a49a895f572c5f0_great_circle(__pyx_v_lon1, __pyx_v_lat1, __pyx_v_lon2, __pyx_v_lat2, 0)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 7, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_1); __pyx_r = __pyx_t_1; __pyx_t_1 = 0; goto __pyx_L0; /* function exit code */ __pyx_L1_error:; __Pyx_XDECREF(__pyx_t_1); __Pyx_AddTraceback(&quot;_cython_magic_001d315da99fd0491a49a895f572c5f0.great_circle&quot;, __pyx_clineno, __pyx_lineno, __pyx_filename); __pyx_r = NULL; __pyx_L0:; __Pyx_XGIVEREF(__pyx_r); __Pyx_RefNannyFinishContext(); return __pyx_r; } . &amp;#xA0;08: cdef double a, b, theta, c, x, radius . +09: cdef double pi = 3.141592653589793 . __pyx_v_pi = 3.141592653589793; . &amp;#xA0;10: . +11: radius = 6371 # 公里 . __pyx_v_radius = 6371.0; . +12: x = pi/180 . __pyx_v_x = (__pyx_v_pi / 180.0); . &amp;#xA0;13: . +14: a = (90-lat1)*(x) . __pyx_v_a = ((90.0 - __pyx_v_lat1) * __pyx_v_x); . +15: b = (90-lat2)*(x) . __pyx_v_b = ((90.0 - __pyx_v_lat2) * __pyx_v_x); . +16: theta = (lon2-lon1)*(x) . __pyx_v_theta = ((__pyx_v_lon2 - __pyx_v_lon1) * __pyx_v_x); . +17: c = acosf((cosf(a)*cosf(b)) + (sinf(a)*sinf(b)*cosf(theta))) . __pyx_v_c = acosf(((cosf(__pyx_v_a) * cosf(__pyx_v_b)) + ((sinf(__pyx_v_a) * sinf(__pyx_v_b)) * cosf(__pyx_v_theta)))); . +18: return radius*c . __pyx_r = (__pyx_v_radius * __pyx_v_c); goto __pyx_L0; . Numba . 通过装饰器控制Python解释器把函数转变成机器码，实现了与C和Cython同样的性能，但是不需要用新的解释器或者写C代码。可以按需生成优化（JIT）的机器码，甚至可以编译成CPU或GPU可执行代码。 . JIT即时代码生成（On-the-fly code generation） | CPU和GPU原生代码生成 | 与Numpy相关包交互 | . @jit&#35013;&#39280;&#22120; . a = np.random.rand(1000, 1000) . def sum2d(arr): M, N = arr.shape result = 0 for i in range(M): for j in range(N): result += arr[i, j] return result %timeit -r3 -n10 sum2d(a) . 275 ms ± 13.1 ms per loop (mean ± std. dev. of 3 runs, 10 loops each) . &#24310;&#36831;&#32534;&#35793;&#65288;Lazy compilation&#65289; . from numba import jit # jit装饰器告诉Numba编译函数，当函数被调用时，Numba再引入参数类型 @jit def sum2d(arr): M, N = arr.shape result = 0 for i in range(M): for j in range(N): result += arr[i, j] return result %timeit sum2d(a) . 1.28 ms ± 48.7 µs per loop (mean ± std. dev. of 7 runs, 1 loop each) . &#21363;&#26102;&#32534;&#35793;&#65288;Eager compilation&#65289; . 由于python支持动态类型，因此@jit装饰器可以设置函数的接收类型（返回类型），按照配置参数进行优化，适合进行浮点数精度控制float32、float64。 . from numba import jit, float64 @jit(float64(float64[:, :])) def sum2d(arr): M, N = arr.shape result = 0 for i in range(M): for j in range(N): result += arr[i, j] return result %timeit sum2d(a) . 949 µs ± 1.69 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each) . @jit配置函数签名的常用类型如下。 . void：函数返回值类型，表示不返回任何结果。 | intp和uintp：指针大小的整数，分别表示签名和无签名类型。 | intc和uintc：相当于C语言的整型和无符号整型。 | int8、int16、int32和int64：固定宽度整型（无符号整型前面加u，比如uint8）。 | float32和float64：单精度和双精度浮点数类型。 | complex64和complex128：单精度和双精度复数类型。 | 数组可以用任何带索引的数值类型表示，比如float32[:]就是一维浮点数数组类型，int32[:,:]就是二维整型数组。 | . &#32534;&#35793;&#36873;&#39033; . 非GIL模式：把nogil=True属性传到装饰器，就可以不受GIL的限制，多线程系统的常见问题（一致性、数据同步、竞态条件等）就可以解决。 | 无Python模式：可以通过nopython参数设置Numba的编译模式： object模式：默认模式，产生的代码可以处理所有Python对象，并用C API完成Python对象上的操作； | nopython模式：可以不调用C API而生成更高效的代码，不过只有一部分函数和方法可以使用： 函数中表示数值的所有原生类型都可以被引用 | 函数中不可以分配新内存 | . | | 缓存模式：避免重复调用，通过cache=True将结果保证在缓存文件中 | 并行模式：通过parallel=True并行计算，必须配合nopython=True使用 | @jit(nopython=True) def sum2d(arr): M, N = arr.shape result = 0 for i in range(M): for j in range(N): result += arr[i, j] return result %timeit sum2d(a) . 962 µs ± 29.4 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each) . from numba import prange @jit(parallel=True, nopython=True) def sum2d(arr): M, N = arr.shape result = 0 for i in prange(M): for j in range(N): result += arr[i, j] return result %timeit sum2d(a) . @njit：@jit(nopython=True)的 | @vectorize与@guvectorize：支持NumPy的通用函数（ufunc） | @stencil：定义一个核函数实现stencil（模版）类操作 | @jitclass：jit编译python类 | @cfunc：定义可以被C/C++直接调用的函数 | @overload：注册一个在nopython模式使用自定义函数 | pyspark . &lt;/img&gt; . &#23433;&#35013; . 直接用connda安装即可，自动配置 . conda install pyspark -c conda-forge pip install findspark . &#21021;&#22987;&#21270; . import findspark findspark.init(spark_home=&quot;/home/junjiet/conda/lib/python3.7/site-packages/pyspark&quot;) from pyspark.sql import SparkSession, dataframe from pyspark import SparkConf, SparkContext from pyspark.sql.types import * from pyspark.sql import functions as F sparkConf = SparkConf().set(&quot;spark.sql.execution.arrow.enabled&quot;, &quot;false&quot;) spark = SparkSession.builder.config(conf=sparkConf).enableHiveSupport().getOrCreate() sc = SparkContext.getOrCreate() . RDD&#31616;&#20171; . RDD(Resilient Distributed DataSet,弹性分布式数据集)，是Spark中最基本的数据抽象是，具有分区，不可变，并行操作特点 . &lt;/img&gt; . rdd = sc.parallelize([1, 2, 2, 3, 3, 4, 5]) . RDD&#24120;&#29992;&#36716;&#25442;(Transformation)API . &lt;/img&gt; . rdd.filter(lambda x: x % 2 == 0).collect() . [2, 2, 4] . RDD&#24120;&#29992;&#21160;&#20316;(Action)API . &lt;/img&gt; . rdd.count() . 7 . rdd.distinct().collect() . [1, 2, 3, 4, 5] . RDD&#19982;DataFrame&#22522;&#26412;&#25805;&#20316; . . . Dataframe . schema = ( StructType() .add(&quot;user_id&quot;, &quot;string&quot;) .add(&quot;country&quot;, &quot;string&quot;) .add(&quot;browser&quot;, &quot;string&quot;) .add(&quot;OS&quot;, &quot;string&quot;) .add(&quot;age&quot;, &quot;integer&quot;) .add(&quot;salary&quot;, &quot;double&quot;) ) . df = spark.createDataFrame( [ (&quot;A203&quot;, &quot;India&quot;, &quot;Chrome&quot;, &quot;WIN&quot;, 33, 12.34), (&quot;A201&quot;, &quot;China&quot;, &quot;Safari&quot;, &quot;MacOS&quot;, 45, 14.56), (&quot;A205&quot;, &quot;UK&quot;, &quot;Mozilla&quot;, &quot;Linux&quot;, 25, 16.78), (&quot;A206&quot;, &quot;China&quot;, &quot;Chrome&quot;, &quot;MacOS&quot;, 68, 23.45), ], schema=schema, ) df.printSchema() . root |-- user_id: string (nullable = true) |-- country: string (nullable = true) |-- browser: string (nullable = true) |-- OS: string (nullable = true) |-- age: integer (nullable = true) |-- salary: double (nullable = true) . df.show() . +-+-+-+--+++ |user_id|country|browser| OS|age|salary| +-+-+-+--+++ | A203| India| Chrome| WIN| 33| 12.34| | A201| China| Safari|MacOS| 45| 14.56| | A205| UK|Mozilla|Linux| 25| 16.78| | A206| China| Chrome|MacOS| 68| 23.45| +-+-+-+--+++ . df.filter(df[&quot;age&quot;] &gt; 30) . DataFrame[user_id: string, country: string, browser: string, OS: string, age: int, salary: double] . df.filter(df[&quot;age&quot;] &gt; 30).count() . 3 . df.where((df[&quot;age&quot;] &gt; 30) &amp; (df[&quot;country&quot;] == &quot;China&quot;)).show() . +-+-+-+--+++ |user_id|country|browser| OS|age|salary| +-+-+-+--+++ | A201| China| Safari|MacOS| 45| 14.56| | A206| China| Chrome|MacOS| 68| 23.45| +-+-+-+--+++ . df.toPandas() . user_id country browser OS age salary . 0 A203 | India | Chrome | WIN | 33 | 12.34 | . 1 A201 | China | Safari | MacOS | 45 | 14.56 | . 2 A205 | UK | Mozilla | Linux | 25 | 16.78 | . 3 A206 | China | Chrome | MacOS | 68 | 23.45 | . &#33258;&#23450;&#20041;&#20989;&#25968; . DataFrame&#23646;&#24615; . from pyspark.sql import dataframe def spark_shape(self): return (self.count(), len(self.columns)) dataframe.DataFrame.shape = spark_shape . df.shape() . (4, 6) . UDF . from pyspark.sql.functions import udf def age_category(age): if 18 &lt;= age &lt; 30: return &quot;A&quot; elif age &lt; 60: return &quot;B&quot; else: return &quot;C&quot; age_udf = udf(age_category, StringType()) df.withColumn(&quot;age_category&quot;, age_udf(df[&quot;age&quot;])).show() . +-+-+-+--++++ |user_id|country|browser| OS|age|salary|age_category| +-+-+-+--++++ | A203| India| Chrome| WIN| 33| 12.34| B| | A201| China| Safari|MacOS| 45| 14.56| B| | A205| UK|Mozilla|Linux| 25| 16.78| A| | A206| China| Chrome|MacOS| 68| 23.45| C| +-+-+-+--++++ . Pandas UDF . min_sal, max_sal = df.agg(F.min(&quot;salary&quot;), F.max(&quot;salary&quot;)).collect()[0] min_sal, max_sal . (12.34, 23.45) . from pyspark.sql.functions import pandas_udf def scaled_salary(salary): scaled_sal = (salary - min_sal) / (max_sal - min_sal) return scaled_sal scaling_udf = pandas_udf(scaled_salary, DoubleType()) . df.select(df[&quot;salary&quot;], scaling_udf(df[&quot;salary&quot;])).show() . . 捕蛇者说 中文python播客，有趣有料 | pandas_profiling EDA可视化报表，支持导出html格式 | pandarallel CPU并行加速，apply、map、groupby与rolling等应用场景 | jax NumPy的GPU加速——谷歌开源，jakavdp参与开发 | cudf Datafame的GPU加速 | koalas Databricks按照pandas实现的pyspark接口 |",
            "url": "/Kivy/jupyter/python/data%20science/2020/05/15/data-etl.html",
            "relUrl": "/jupyter/python/data%20science/2020/05/15/data-etl.html",
            "date": " • May 15, 2020"
        }
        
    
  
    
        ,"post5": {
            "title": "Python数据科学分享——1.jupyter和python",
            "content": ". &#25968;&#25454;&#31185;&#23398;&#65288;&#32479;&#35745;&#23398;+&#35745;&#31639;&#26426;+&#34892;&#19994;&#32463;&#39564;&#65289; . . 统计学家的能力——建立模型和聚合（数量不断增大的）数据 | 计算机科学家的能力——设计并使用算法对数据进行高效存储、分析和可视化 | 专业领域的能力——在细分领域中经过专业的训练，既可以提出正确的问题，又可以作出专业的解答 | 郁彬2020年2月发表论文《Verdical data science（靠谱的数据科学）》提出的数据科学三原则（PCS）: . 可预测性(predictability) | 可计算性（computability） | 稳定性（stability ） | B. Yu and K. Kumbier (2020) Verdical data science PNAS. 117 (8), 3920-3929. QnAs with Bin Yu. . 郁彬：统计学家，美国艺术与科学学院院士、美国国家科学院院士，加州大学伯克利分校统计系和电子工程与计算机科学系终身教授 . REPL &#19982;&#39764;&#27861;&#20989;&#25968; . Jupyter是一个非营利组织，旨在“为数十种编程语言的交互式计算开发开源软件，开放标准和服务”。2014年由Fernando Pérez从IPython中衍生出来。jupyter-console==IPython . | Jupyter主要包括三种交互式计算产品：Jupyter Notebook、JupyterHub和JupyterLab(Jupyter Notebook的下一代版本)。 . | Jupyter Notebook（前身是IPython Notebook）是一个基于Web的交互式计算环境，用于创建Jupyter Notebook文档(JSON文档)，由一组有序的输入/输出单元格列表构成，包含代码、文本（支持Markdown）、数学公式(Mathjax)、图表和富媒体，通常以“.ipynb”结尾扩展。 . | $ begin{align*} y = y(x,t) &amp;= A e^{i theta} &amp;= A ( cos theta + i sin theta) &amp;= A ( cos(kx - omega t) + i sin(kx - omega t)) &amp;= A cos(kx - omega t) + i A sin(kx - omega t) &amp;= A cos Big( frac{2 pi}{ lambda}x - frac{2 pi v}{ lambda} t Big) + i A sin Big( frac{2 pi}{ lambda}x - frac{2 pi v}{ lambda} t Big) &amp;= A cos frac{2 pi}{ lambda} (x - v t) + i A sin frac{2 pi}{ lambda} (x - v t) end{align*}$ . 其中，$ theta = kx - omega t $ . import altair as alt from vega_datasets import data source = data.cars() brush = alt.selection(type=&quot;interval&quot;) points = ( alt.Chart(source) .mark_point() .encode( x=&quot;Horsepower:Q&quot;, y=&quot;Miles_per_Gallon:Q&quot;, color=alt.condition(brush, &quot;Origin:N&quot;, alt.value(&quot;lightgray&quot;)), ) .add_selection(brush) ) bars = ( alt.Chart(source) .mark_bar() .encode(y=&quot;Origin:N&quot;, color=&quot;Origin:N&quot;, x=&quot;count(Origin):Q&quot;) .transform_filter(brush) ) points &amp; bars . from ipywidgets import HBox, VBox, IntSlider, interactive_output from IPython.display import display a = IntSlider() b = IntSlider() out = interactive_output(lambda a, b: print(f&quot;{a} * {b} = {a*b}&quot;), {&quot;a&quot;: a, &quot;b&quot;: b}) display(HBox([VBox([a, b]), out])) . &#29992;&#31526;&#21495;?&#33719;&#21462;&#24110;&#21161;&#25991;&#26723; . Python内置的help()函数可以获取这些信息，并且能打印输出结果。例如，如果要查看内置的sorted函数的文档，可以按照以下步骤操作： . help(sorted) . Help on built-in function sorted in module builtins: sorted(iterable, /, *, key=None, reverse=False) Return a new list containing all items from the iterable in ascending order. A custom key function can be supplied to customize the sort order, and the reverse flag can be set to request the result in descending order. . IPython引入了?符号作为获取这个文档和其他相关信息的缩写： . sorted? # Signature: sorted(iterable, /, *, key=None, reverse=False) # Docstring: # Return a new list containing all items from the iterable in ascending order. # A custom key function can be supplied to customize the sort order, and the # reverse flag can be set to request the result in descending order. # Type: builtin_function_or_method . 也适用于自定义函数或者其他对象！下面定义一个带有docstring的小函数： . def square(a): &quot;&quot;&quot;返回a的平方&quot;&quot;&quot; return a ** 2 . square? . &#36890;&#36807;&#31526;&#21495;??&#33719;&#21462;&#28304;&#20195;&#30721; . Jupyter提供了获取源代码的快捷方式（使用两个问号??）： . square?? . Object `square` not found. . 当查询C语言或其他编译扩展语言实现的函数时，??后缀=?后缀 . sorted?? . &#29992;Tab&#34917;&#20840;&#30340;&#26041;&#24335;&#25506;&#32034;&#27169;&#22359; . Jupyter支持用Tab键自动补全和探索对象、模块及命名空间的内容（下面用&lt;TAB&gt;来表示Tab键） . 对象内容的Tab自动补全 . | 导入时的Tab自动补全 . | 通配符*匹配 | &#23545;&#35937;&#20869;&#23481;&#30340;Tab&#33258;&#21160;&#34917;&#20840; . 每一个Python对象都包含各种属性和方法。Python有一个内置的dir函数，可以返回一个属性和方法的列表。Tab自动补全接口更简便：输入这个对象的名称，再加上一个句点（.）和Tab键： . L = [1, 2, 3] . L.append . File &#34;&lt;ipython-input-9-9b66bc403048&gt;&#34;, line 1 L. ^ SyntaxError: invalid syntax . 为了进一步缩小整个列表，可以输入属性或方法名称的第一个或前几个字符，然后Tab键将会查找匹配的属性或方法： . L.c&lt;TAB&gt; L.clear L.copy L.count L.co&lt;TAB&gt; L.copy L.count . 如果只有一个选项，按下Tab键将会把名称自动补全。例如，下面示例中的内容将会马上被L.count替换： . L.cou&lt;TAB&gt; . Python一般用前置下划线表示私有属性或方法。可以通过明确地输入一条下划线来把这些私有的属性或方法列出来： . L._&lt;TAB&gt; L.__add__ L.__gt__ L.__reduce__ L.__class__ L.__hash__ L.__reduce_ex__ . 为了简洁起见，这里只展示了输出的前两行，大部分是Python特殊的双下划线方法（昵称叫作“dunder方法”）。 . &#23548;&#20837;&#26102;&#30340;Tab&#33258;&#21160;&#34917;&#20840; . Tab自动补全在从包中导入对象时也非常有用。下面用这种方法来查找itertools包中以co开头的所有可导入的对象： . from itertools import co&lt;TAB&gt; combinations compress combinations_with_replacement count . 同样，你也可以用Tab自动补全查看系统中所有可导入的包： import &lt;TAB&gt; import h&lt;TAB&gt; . &#36890;&#37197;&#31526;*&#21305;&#37197; . Jupyter还提供了用*符号来实现的依赖中间或者末尾几个字符查询的通配符匹配方法。 . str.*find*? . 假设寻找一个字符串方法，它的名称中包含find，则可以这样做： . str.*find*? str.find str.rfind . 这里的*符号匹配任意字符串，包括空字符串。 . 在实际应用过程中，灵活的通配符对于找命令非常有用。 . Jupyter shell&#20013;&#30340;&#24555;&#25463;&#38190; . Jupyter通过GNU Readline库实现了四类shell快捷键，在IPython中提高工作效率 . 导航快捷键 . | 文本输入快捷键 . | 命令历史快捷键 | 其他快捷键 | &#23548;&#33322;&#24555;&#25463;&#38190; . 快捷键 动作 . Ctrl + a | 将光标移到本行的开始处 | . Ctrl + e | 将光标移到本行的结尾处 | . Ctrl + b（或左箭头键） | 将光标回退一个字符 | . Ctrl + f（或右箭头键） | 将光标前进一个字符 | . &#25991;&#26412;&#36755;&#20837;&#24555;&#25463;&#38190; . 快捷键 动作 . Backspace键 | 删除前一个字符 | . Ctrl + d | 删除下一个字符 | . Ctrl + k | 从光标开始剪切至行的末尾 | . Ctrl + u | 从行的开头剪切至光标 | . Ctrl + y | Yank（即粘贴）之前剪切的文本 | . Ctrl + t | Transpose（即交换）前两个字符 | . &#21629;&#20196;&#21382;&#21490;&#24555;&#25463;&#38190; . Jupyter的命令历史都保存在配置文件路径下的SQLite数据库中，下面的快捷键实现历史搜索： . 快捷键 动作 . Ctrl + p（或向上箭头） | 获取前一个历史命令 | . Ctrl + n（或向下箭头） | 获取后一个历史命令 | . Ctrl + r | 对历史命令的反向搜索 | . &#20854;&#20182;&#24555;&#25463;&#38190; . 快捷键 动作 . Ctrl + l | 清除终端屏幕的内容 | . Ctrl + c | 中断当前的Python命令 | . Ctrl + d | 退出Jupyter会话 | . Jupyter&#39764;&#27861;&#21629;&#20196; . Jupyter在普通Python语法基础之上的增强功能，被称作Jupyter魔法命令，都以%符号作为前缀。这些魔法命令设计用于解决数据分析中的各种常见问题。魔法命令有两种形式： . 行魔法（line magic）：以单个%字符作为前缀，作用于单行输入； | 单元魔法（cell magic）：以两个%%作为前缀，作用于多行输入。 | &#31896;&#36148;&#20195;&#30721;&#22359;&#65306;%paste&#21644;%cpaste . 当你使用Jupyter解释器时，粘贴多行代码块可能会导致错误，尤其是其中包含缩进和解释符号时。Jupyter的%paste魔法函数可以解决这个包含符号的多行输入问题： . In [1]: %paste . def donothing(x):... return x . ## -- End pasted text -- . %paste命令同时输入并执行该代码，所以你可以看到这个函数现在被应用了： . In [2]: donothing(10) Out[2]: 10 . 另外一个作用类似的命令是%cpaste。该命令打开一个交互式多行输入提示，你可以在这个提示下粘贴并执行一个或多个代码块： . In [3]: %cpaste Pasting code; enter &#39;--&#39; alone on the line to stop or use Ctrl-D. :&gt;&gt;&gt; def donothing(x): :... return x :-- . &#25191;&#34892;&#22806;&#37096;&#20195;&#30721;&#65306;%run . 在Jupyter会话中运行代码文件非常方便，不用在另一个新窗口中运行这些程序代码。通过%run魔法命令来实现。 . 假设你创建了一个myscript.py文件，该文件包含以下内容： . %%file myscript.py def square(x): &quot;&quot;&quot;求平方&quot;&quot;&quot; return x ** 2 for N in range(1, 4): print(N, &quot;squared is&quot;, square(N)) . Overwriting myscript.py . ls myscript.py . myscript.py . %run myscript.py . 1 squared is 1 2 squared is 4 3 squared is 9 . 当你运行了这段代码之后，该代码中包含的所有函数都可以在Jupyter会话中使用： . square(5) . 25 . &#35745;&#31639;&#20195;&#30721;&#36816;&#34892;&#26102;&#38388;&#65306;%timeit . %timeit会自动计算接下来一行的Python语句的执行时间。 . %timeit L = [n ** 2 for n in range(1000)] . 238 µs ± 24.6 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each) . %timeit会自动多次执行命令以获得更稳定的结果。 . 对于多行语句，可以加入第二个%符号将其转变成单元魔法，以处理多行输入。例如，下面是for循环的同等结构： . %%timeit L = [] for n in range(1000): L.append(n ** 2) . 321 µs ± 37.6 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each) . 从以上结果可以立刻看出，列表解析式比同等的for循环结构快约20%。 . %magic . &#39764;&#27861;&#20989;&#25968;&#30340;&#24110;&#21161;&#25991;&#26723;?&#12289;%magic&#21644;%lsmagic . 和普通的Python函数一样，Jupyter魔法函数也有文档字符串，输入以下命令即可查询： . In [10]: %timeit? . 查询魔法函数的描述以及示例，可以输入命令： . In [11]: %magic . 获得所有可用魔法函数的列表，可以输入命令： . In [12]: %lsmagic . 也可以自定义魔法函数，详情查看官方文档。 . &#36755;&#20837;&#21644;&#36755;&#20986;&#21382;&#21490; . Jupyter在shell和Notebook中都提供了几种获得历史命令的输出方式： . Jupyter的输入（In）和输出（Out）对象 | 下划线快捷键和历史输出 | 禁止输出，末尾加分号 . | %history、%rerun和%save . | Jupyter&#30340;&#36755;&#20837;&#21644;&#36755;&#20986;&#23545;&#35937; . Jupyter的In[1]:/Out[1]:形式，并不仅仅是好看的装饰形式，还可以获取输入和输出历史： . import math . math.sin(2) . 0.9092974268256817 . math.cos(2) . -0.4161468365471424 . Jupyter实际上创建了叫作In和Out的Python变量，这些变量自动更新以反映命令历史： . # In . # Out . In对象是一个列表，按照顺序记录所有的命令（列表中的第一项是一个占位符，以便In[1]可以表示第一条命令）： . print(In[1]) . import math . Out对象不是一个列表，而是一个字典。它将输入数字映射到相应的输出（如果有的话）： . print(Out[2]) . 0.9092974268256817 . 不是所有操作都有输出，例如import语句和print语句不会加入Out。因为print函数的返回值是None。任何返回值是None的命令都不会加到Out变量中。 . 如果想利用之前的结果，理解以上内容将大有用处。例如，利用之前的计算结果检查sin(2) ** 2和cos(2) ** 2的和，结果如下： . Out[2] ** 2 + Out[3] ** 2 . 1.0 . &#19979;&#21010;&#32447;&#24555;&#25463;&#38190;&#21644;&#21382;&#21490;&#36755;&#20986; . 标准的Python shell用变量_（单下划线）可以获得前一个命令输出结果，在Jupyter中也适用： . print(_) . 1.0 . Jupyter可以用两条下划线获得倒数第二个历史输出，用三条下划线获得倒数第三个历史输出（跳过任何没有输出的命令）： . print(__) . [&#39;&#39;, &#39;import math&#39;, &#39;math.sin(2)&#39;, &#39;math.cos(2)&#39;, &#39;In&#39;, &#39;Out&#39;, &#39;print(In[1])&#39;, &#39;print(Out[2])&#39;, &#39;Out[2] ** 2 + Out[3] ** 2&#39;, &#39;print(_)&#39;, &#39;print(__)&#39;] . print(___) . -0.4161468365471424 . 另外，Out[X]可以简写成_X（即一条下划线加行号）： . Out[2] . 0.9092974268256817 . _2 . 0.9092974268256817 . &#31105;&#27490;&#36755;&#20986; . 要禁止一个命令的输出，在行末尾处添加一个分号： . math.sin(2) + math.cos(2); . 这个结果被计算后，输出结果既不会显示在屏幕上，也不会存储在Out中： . 25 in Out . False . &#20854;&#20182;&#21382;&#21490;&#39764;&#27861;&#21629;&#20196; . 如果想一次性获取此前所有的输入历史，%history魔法命令会非常有用。在下面的示例中可以看到如何打印前4条输入命令： . %history -n 1-4 . 1: %load ../README.md 2: from ipywidgets import HBox, VBox, IntSlider, interactive_output from IPython.display import display a = IntSlider() b = IntSlider() out = interactive_output(lambda a, b: print(f&#34;{a} * {b} = {a*b}&#34;), {&#34;a&#34;: a, &#34;b&#34;: b}) display(HBox([VBox([a, b]), out])) 3: m = 5.1 if m &lt; 5: print(f&#34;{m}小于5&#34;) elif m % 2 == 1: print(f&#34;{m}是奇数&#34;) elif m % 2 == 0: print(f&#34;{m}是偶数&#34;) else: print(&#34;不是整数&#34;) 4: 5.1 % 2 . 按照惯例，可以输入%history?来查看更多相关信息以及可用选项的详细描述。其他类似的魔法命令还有%rerun（该命令将重新执行部分历史命令）和%save（该命令将部分历史命令保存到一个文件中）。如果想获取更多相关信息，建议你使用?帮助功能（详情请参见1.2节）。 . Jupyter&#21644;shell&#21629;&#20196; . 在Jupyter中使用shell命令 | 在shell中传入或传出值 | 部分自动魔法 | &#22312;Jupyter&#20013;&#20351;&#29992;shell&#21629;&#20196; . Jupyter终端直接执行shell命令的语法，在shell命令前加!，将不会通过Python内核运行，而是通过系统命令运行。 . !ls . jupyter-python 2.data-elt 2019-01-01-kivy-perface.ipynb 2019-02-01-kivy-ch1-clock-app.ipynb 2019-03-01-kivy-ch2-paint-app.ipynb 2019-04-01-kivy-ch3-sound-recorder-for-android.ipynb 2019-05-01-kivy-ch4-chat-app.ipynb 2019-06-01-kivy-ch5-remote-desktop-app.ipynb 2019-07-01-kivy-ch6-2048-app.ipynb 2019-08-01-kivy-ch7-flappy-bird-app.ipynb 2019-09-01-kivy-ch8-shaders-app.ipynb 2019-10-01-kivy-ch9-shmup-app.ipynb 2020-02-20-test.ipynb 2020-05-08-jupyter-python.ipynb 2020-05-15-data-etl.ipynb 2020-05-22-data-viz-1.ipynb 2020-05-29-data-viz-2.ipynb 2020-06-08-data-stats.ipynb 3.data-viz 4.data-stats README.md kbpic my_icons . !pwd . /Users/toddtao/Documents/air/_notebooks . !echo &quot;数据科学&quot; . 数据科学 . &#22312;shell&#20013;&#20256;&#20837;&#25110;&#20256;&#20986;&#20540; . shell命令不仅可以从Jupyter中调用，还可以和Jupyter命名空间进行交互。例如，通过一个赋值操纵符将任何shell命令的输出保存到一个Python列表： . contents = !ls contents . [&#39;1.jupyter和python.ipynb&#39;, &#39;drewconway.png&#39;, &#39;enumerate.png&#39;, &#39;harry_potter&#39;, &#39;HW&#39;, &#39;HW1.jupyter和python.ipynb&#39;, &#39;jupyter.png&#39;, &#39;map.png&#39;, &#39;myscript2.py&#39;, &#39;myscript.py&#39;, &#39;tale-of-two-cities.txt&#39;, &#39;zip.png&#39;, &#39;猜数字.png&#39;] . directory = !pwd directory . [&#39;/home/junjiet/data_science2020/1.jupyter和python&#39;] . 这些结果并不以列表的形式返回，虽然可以像列表一样操作，但是这种类型还有其他功能，例如grep和fields方法以及s、n和p属性，允许你轻松地搜索、过滤和显示结果。 . type(directory) . IPython.utils.text.SList . 另一个方向的交互，即将Python变量传入shell，可以通过{varname}语法实现： . message = &quot;美妙的Python&quot; . !echo {message} . 美妙的Python . 变量名包含在大括号内，在shell命令中用实际的变量替代。 . &#19982;shell&#30456;&#20851;&#30340;&#39764;&#27861;&#21629;&#20196; . 不能通过!cd来切换目录，原因是Notebook中的shell命令是在一个临时的shell中执行的。如果你希望以一种更持久的方式更改工作路径，可以使用%cd魔法命令： . %cd .. . /home/junjiet/data_science2020 . 其实可以直接用cd实现该功能： . cd .. . /home/junjiet . 这种方式称作自动魔法（automagic）函数，可以通过%automagic魔法函数进行调整，默认开启。 . 除了%cd，其他可用的类似shell的魔法函数还有%cat、%cp、%env、%ls、%man、%mkdir、%more、%mv、%pwd、%rm和%rmdir，默认都可以省略%符号。 . &#38169;&#35823;&#21644;&#35843;&#35797; . 代码开发和数据分析经常需要一些调试，Jupyter调试代码工具： . %xmode：控制打印信息进行traceback | %debug：基于ipdb（pdb增强版）专用的调试器进行调试 | %run -d：交互式模式运行脚本，用next命令单步向下交互地运行代码 | 常用调试命令如下: . 命令 描述 . list | 显示文件的当前路径 | . h(elp) | 显示命令列表，或查找特定命令的帮助信息 | . q(uit) | 退出调试器和程序 | . c(ontinue) | 退出调试器，继续运行程序 | . n(ext) | 跳到程序的下一步 | . &lt;enter&gt; | 重复前一个命令 | . p(rint) | 打印变量 | . s(tep) | 步入子进程 | . r(eturn) | 从子进程跳出 | . 在调试器中使用help命令，或者查看ipdb的在线文档获取更多的相关信息 . &#20195;&#30721;&#20998;&#26512;&#19982;&#20248;&#21270; . “过早优化是一切罪恶的根源。”——高德纳 . Jupyter提供了很多执行这些代码计时和分析的操作函数。 . %time:对单个语句的执行时间进行计时 . | %timeit:对单个语句的重复执行进行计时，以获得更高的准确度 . | %prun:利用分析器运行代码 . | %lprun:利用逐行分析器运行代码，需要先安装pip install line_profiler，再导入%load_ext line_profiler . | %memit:测量单个语句的内存使用，需要先安装pip install memory_profiler，再导入%load_ext memory_profiler . | %mprun:通过逐行的内存分析器运行代码 | 详情请参考Python数据科学手册 第 1 章　IPython：超越 Python . Python &#22522;&#30784; . 通过“猜数字”游戏介绍Python编程基础，涉及输入输出、模块、函数、控制流、数据结构等概念。程序流程图如下： . . &#28216;&#25103;&#20195;&#30721; . # 猜数字游戏 import random m, n = 30, 5 # 最大值和猜测次数 x = random.randrange(1, m) name = input(&quot;Hello! 你是谁?&quot;) print(f&quot;欢迎你，{name}同学，我在1到{m}之间选了一个整数，共{n}次机会，你猜猜看？&quot;) for i in range(n): guess = int(input(f&quot;{name}同学猜是：&quot;)) if guess == x: print(f&quot;猜中啦，{name}同学！就是{x}，赶紧去买注大乐透吧！&quot;) break else: print(&quot;猜大了~&quot;, end=&quot;&quot;) if guess &gt; x else print(&quot;猜小了~&quot;, end=&quot;&quot;) print(f&quot;还有{n-i-1}次机会，再猜猜看：&quot;) if i + 1 &lt; n else print(&quot;&quot;) else: print(f&quot;&gt;:&lt;没猜中，我想的是{x}啊！&quot;) . Hello! 你是谁?tutu 欢迎你，tutu同学，我在1到30之间选了一个整数，共5次机会，你猜猜看？ tutu同学猜是：15 猜中啦，tutu同学！就是15，赶紧去买注大乐透吧！ . import&#35821;&#21477;&#19982;random&#27169;&#22359; . 第1行是Python的注释，以#开头，解释器运行时会忽略 #后面的字符 . # 猜数字游戏 . 第2行是import语句，导入了一个random模块（module） . import random . 语句（statement）是执行操作的若干指令，而表达式（expression）会计算并返回值 . 第4行是赋值（assignment）语句，将30、5保存在变量（variable）m、n中 . m, n = 30, 5 # 最大值和猜测次数 . &#23383;&#38754;&#20540;&#65288;Literals&#65289; . 字面值用于表示一些内置类型的常量。 . &#25968;&#23383; . 整型(int)、浮点数(float)和复数(complex)，与计算器一样，输入一个表达式就会有答案 . 3 + 4 * 5 / 6 . 6.333333333333334 . 20 // 3, 20 % 3, 20 ** 3 . (6, 2, 8000) . import sys . sys.float_info . sys.float_info(max=1.7976931348623157e+308, max_exp=1024, max_10_exp=308, min=2.2250738585072014e-308, min_exp=-1021, min_10_exp=-307, dig=15, mant_dig=53, epsilon=2.220446049250313e-16, radix=2, rounds=1) . &#23383;&#31526;&#20018; . 字符串有多种形式，可以使用单引号（&#39;&#39;），双引号（&quot;&quot;），反斜杠 表示转义字符: . print(&quot;C: some name&quot;) . C: some ame . 字符串跨行连续输入。用三重引号：&quot;&quot;&quot;...&quot;&quot;&quot; 或 &#39;&#39;&#39;...&#39;&#39;&#39;。字符串中的回车换行会自动包含到字符串中，如果不想包含，在行尾添加一个 即可。如下例: . print(&quot;&quot;&quot; Usage: thingy [OPTIONS] -h Display this usage message -H hostname Hostname to connect to &quot;&quot;&quot;) . Usage: thingy [OPTIONS] -h Display this usage message -H hostname Hostname to connect to . 字符串可以用 + 进行连接（粘到一起），也可以用 * 进行重复 . 3 * &quot;un&quot; + &quot;ium&quot; . &#39;unununium&#39; . 很长的字符串用括号包裹多个片段即可: . text = (&#39;很长的字符串用括号&#39; &#39;包裹多个片段即可&#39;) text . &#39;很长的字符串用括号包裹多个片段即可&#39; . &#20989;&#25968; . 关键字def创建函数，后面函数名称和带括号的形式参数列表 . 第5行调用了random模块的randrange()函数（function），这个函数会生成一个随机数[1,n]范围的整数x . x = random.randrange(1, m) . # 定义 Fibonacci数列 def fib(n): &quot;&quot;&quot;Print a Fibonacci series up to n.&quot;&quot;&quot; a, b = 0, 1 while a &lt; n: print(a, end=&quot; &quot;) a, b = b, a + b print() . # 调用函数 fib(2000) . 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 . 函数通过return语句返回值，即使没有 return 语句的函数也会返回一个值None . # 定义 Fibonacci数列 def fib_return(n): &quot;&quot;&quot;Print a Fibonacci series up to n.&quot;&quot;&quot; a, b = 0, 1 fib = [] while a &lt; n: fib.append(a) a, b = b, a + b return fib . fib2000 = fib_return(2000) fib2000 . [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597] . random.randrange?? . &#36755;&#20837;&#36755;&#20986; . 第6行input()函数获取用户输入 . name = input(&quot;Hello! 你是谁?&quot;) . Hello! 你是谁?tutu . name . &#39;tutu&#39; . 第7行print()函数打印输出，f字符串可以在{ 和 } 字符之间引用变量或表达式（Python3.6新特性，另外还有C语言%字符串与.format字符串） . print(f&quot;欢迎你，{name}同学，我在1到{m}之间选了一个整数，共{n}次机会，你猜猜看？&quot;) . 欢迎你，tutu同学，我在1到30之间选了一个整数，共5次机会，你猜猜看？ . def mod(a,b): return a % b . import dis . dis.dis(mod) . 2 0 LOAD_FAST 0 (a) 2 LOAD_FAST 1 (b) 4 BINARY_MODULO 6 RETURN_VALUE . mod(&#39;hello%s&#39;,&#39;world&#39;) . &#39;helloworld&#39; . print(f&quot;{1+2*3}&quot;) . 7 . 更常见的还有文件读写操作： . with open(&quot;myscript.py&quot;, &quot;r&quot;) as f: txt = f.read() print(txt) . def square(x): &#34;&#34;&#34;求平方&#34;&#34;&#34; return x ** 2 for N in range(1, 4): print(N, &#34;squared is&#34;, square(N)) . with open(&quot;myscript2.py&quot;, &quot;w&quot;) as f: f.write(txt) . cat myscript2.py . def square(x): &#34;&#34;&#34;求平方&#34;&#34;&#34; return x ** 2 for N in range(1, 4): print(N, &#34;squared is&#34;, square(N)) . with open(&quot;myscript.py&quot;, &quot;r&quot;) as f: txt = f.readlines() txt . [&#39;def square(x): n&#39;, &#39; &#34;&#34;&#34;求平方&#34;&#34;&#34; n&#39;, &#39; return x ** 2 n&#39;, &#39; n&#39;, &#39;for N in range(1, 4): n&#39;, &#39; print(N, &#34;squared is&#34;, square(N)) n&#39;] . with open(&quot;myscript2.py&quot;, &quot;w&quot;) as f: f.writelines(txt) . cat myscript2.py . def square(x): &#34;&#34;&#34;求平方&#34;&#34;&#34; return x ** 2 for N in range(1, 4): print(N, &#34;squared is&#34;, square(N)) . &#25511;&#21046;&#27969; . for...[else]、break、contiue | if...else | while...[else] | for . 第8行-17行是一块for...else循环语句，对序列或其他可迭代对象的每个元素进行迭代: . for i in range(n): ... else: print(f&quot;&gt;:&lt;没猜中，我想的是{x}啊！&quot;) ... . else子句是可选语句，当元素被迭代结束后，else 子句才会被执行 . for i in range(10): print(i ** 2) else: print(&quot;game over&quot;) . 0 1 4 9 16 25 36 49 64 81 game over . for i in range(10): if i &gt; 5: break print(i ** 2) else: print(&quot;game over&quot;) . 0 1 4 9 16 25 . for i in range(10): if i &gt; 5: continue print(i ** 2) else: print(&quot;game over&quot;) . 0 1 4 9 16 25 game over . if...else... . 第10行-13行是if...else条件语句 . if guess == x: print(f&quot;猜中啦，{name}同学！就是{x}，赶紧去买注大乐透吧！&quot;) break else: ... . m = 5.1 if m &lt; 5: print(f&quot;{m}小于5&quot;) elif m % 2 == 1: print(f&quot;{m}是奇数&quot;) elif m % 2 == 0: print(f&quot;{m}是偶数&quot;) else: print(&quot;不是整数&quot;) . 不是整数 . 5.1 % 2 . 1.0999999999999996 . 浮点数精度问题，建议参考decimal标准库 . 鲜为人知的Python特性 https://github.com/satwikkansal/wtfpython . while . 另一种循环语句，支持else可选子句 . i = 0 while i &lt; 10: if i &gt; 5: break print(i ** 2) i += 1 else: print(&quot;game over&quot;) . 0 1 4 9 16 25 . &#36816;&#31639;&#31526;&#65288;Operators&#65289; . + - * ** / // % @（Python3.5新特性） &lt;&lt; &gt;&gt; &amp; | ^ ~ :=（Python3.8新特性） &lt; &gt; &lt;= &gt;= == != . 运算符优先级： . 运算符 . 描述 . . := . | 赋值表达式 . | . lambda . | lambda 表达式 . | . if -- else . | 条件表达式 . | . or . | 布尔逻辑或 OR . | . and . | 布尔逻辑与 AND . | . not x . | 布尔逻辑非 NOT . | . in, not in, is, is not, &lt;, &lt;=, &gt;, &gt;=, !=, == . | 比较运算，包括成员检测和标识号检测 . | . | . | 按位或 OR . | . ^ . | 按位异或 XOR . | . &amp; . | 按位与 AND . | . &lt;&lt;, &gt;&gt; . | 移位 . | . +, - . | 加和减 . | . *, @, /, //, % . | 乘，矩阵乘，除，整除，取余 . | . +x, -x, ~x . | 正，负，按位非 NOT . | . ** . | 乘方 . | . await x . | await 表达式 . | . x[index], x[index:index], x(arguments...), x.attribute . | 抽取，切片，调用，属性引用 . | . (expressions...), . [expressions...], {key: value...}, {expressions...} . | 绑定或加圆括号的表达式，列表显示，字典显示，集合显示 . | . 条件表达式也称三元运算符(ternary operator): . cmp = &quot;2 &gt; 1&quot; if 2 &gt; 1 else &quot;2 &lt; 1&quot; cmp . &#39;2 &gt; 1&#39; . 第14、15行均使用了条件表达式： . print(&quot;猜大了~&quot;, end=&quot;&quot;) if guess &gt; x else print(&quot;猜小了~&quot;, end=&quot;&quot;) print(f&quot;还有{n-i-1}次机会，再猜猜看：&quot;) if i + 1 &lt; n else print(&quot;&quot;) . 猜小了~ . &#25968;&#25454;&#32467;&#26500; . range | list(列表) | tuple(元组) | set(集合) | dict(字典) | range . 第8行中有一个range()函数，返回值是一个range对象，属于Python的基本序列类型，另外两个是list和tuple。range(n)包含[0,n-1]范围内所有整数。range(start, stop[, step]) . range(10) . range(0, 10) . type(range(10)) . range . tuple(range(10)) . (0, 1, 2, 3, 4, 5, 6, 7, 8, 9) . &#21015;&#34920;list . 列表是可变序列，通常用于存放同类项目的集合 . 使用一对方括号来表示空列表: [] | 使用方括号，其中的项以逗号分隔: [a], [a, b, c] | 使用列表推导式: [x for x in iterable] | 使用类型的构造器: list() 或 list(iterable) | harry_potter = [ &quot;魔法石&quot;, &quot;密室&quot;, &quot;阿兹卡班囚徒&quot;, &quot;火焰杯&quot;, &quot;凤凰社&quot;, &quot;混血王子&quot;, &quot;死亡圣器&quot;, &quot;被诅咒的孩子&quot;, ] harry_potter . [&#39;魔法石&#39;, &#39;密室&#39;, &#39;阿兹卡班囚徒&#39;, &#39;火焰杯&#39;, &#39;凤凰社&#39;, &#39;混血王子&#39;, &#39;死亡圣器&#39;, &#39;被诅咒的孩子&#39;] . type(harry_potter) . list . len(harry_potter) . 8 . harry_potter.index(&quot;凤凰社&quot;) . 4 . harry_potter[4] . &#39;凤凰社&#39; . harry_potter.pop() . &#39;被诅咒的孩子&#39; . harry_potter . [&#39;魔法石&#39;, &#39;密室&#39;, &#39;阿兹卡班囚徒&#39;, &#39;火焰杯&#39;, &#39;凤凰社&#39;, &#39;混血王子&#39;, &#39;死亡圣器&#39;] . harry_potter.append(&quot;被诅咒的孩子&quot;) harry_potter . [&#39;魔法石&#39;, &#39;密室&#39;, &#39;阿兹卡班囚徒&#39;, &#39;火焰杯&#39;, &#39;凤凰社&#39;, &#39;混血王子&#39;, &#39;死亡圣器&#39;, &#39;被诅咒的孩子&#39;] . for book in harry_potter: print(f&quot;《哈利·波特与{book}》&quot;) . 《哈利·波特与魔法石》 《哈利·波特与密室》 《哈利·波特与阿兹卡班囚徒》 《哈利·波特与火焰杯》 《哈利·波特与凤凰社》 《哈利·波特与混血王子》 《哈利·波特与死亡圣器》 《哈利·波特与被诅咒的孩子》 . [f&quot;《哈利·波特与{book}》&quot; for book in harry_potter] . [&#39;《哈利·波特与魔法石》&#39;, &#39;《哈利·波特与密室》&#39;, &#39;《哈利·波特与阿兹卡班囚徒》&#39;, &#39;《哈利·波特与火焰杯》&#39;, &#39;《哈利·波特与凤凰社》&#39;, &#39;《哈利·波特与混血王子》&#39;, &#39;《哈利·波特与死亡圣器》&#39;, &#39;《哈利·波特与被诅咒的孩子》&#39;] . tuple(&#20803;&#32452;) . 元组是不可变序列，通常用于储存异构数据集、同构数据集的不可变序列 . 使用一对圆括号来表示空元组: () | 使用一个后缀的逗号来表示单元组: a, 或 (a,) | 使用以逗号分隔的多个项: a, b, c or (a, b, c) | 使用内置的 tuple(): tuple() 或 tuple(iterable) | harry_potter = ( (&quot;哈利·波特&quot;, &quot;魔法石&quot;), (&quot;哈利·波特&quot;, &quot;密室&quot;), (&quot;哈利·波特&quot;, &quot;阿兹卡班囚徒&quot;), (&quot;哈利·波特&quot;, &quot;火焰杯&quot;), (&quot;哈利·波特&quot;, &quot;凤凰社&quot;), (&quot;哈利·波特&quot;, &quot;混血王子&quot;), (&quot;哈利·波特&quot;, &quot;死亡圣器&quot;), (&quot;哈利·波特&quot;, &quot;被诅咒的孩子&quot;), ) . for i, book in enumerate(harry_potter): print(f&quot;第{i+1}本《{&#39;与&#39;.join(book)}》&quot;) . 第1本《哈利·波特与魔法石》 第2本《哈利·波特与密室》 第3本《哈利·波特与阿兹卡班囚徒》 第4本《哈利·波特与火焰杯》 第5本《哈利·波特与凤凰社》 第6本《哈利·波特与混血王子》 第7本《哈利·波特与死亡圣器》 第8本《哈利·波特与被诅咒的孩子》 . . set(&#38598;&#21512;) . 由不重复哈希对象构成的无序容器。用途包括 . 成员检测 | &quot;哈利&quot; in {&quot;哈利&quot;, &quot;波特&quot;} . True . 从序列中去除重复项 | set((&quot;哈利&quot;, &quot;波特&quot;, &quot;哈利&quot;, &quot;波特&quot;)) . {&#39;哈利&#39;, &#39;波特&#39;} . 数学集合交、并、补等运算 | harry_potter_books = set(x for y in harry_potter for x in y) harry_potter_books . {&#39;凤凰社&#39;, &#39;哈利·波特&#39;, &#39;密室&#39;, &#39;死亡圣器&#39;, &#39;混血王子&#39;, &#39;火焰杯&#39;, &#39;被诅咒的孩子&#39;, &#39;阿兹卡班囚徒&#39;, &#39;魔法石&#39;} . magic, secret = set(harry_potter[0]), set(harry_potter[1]) magic, secret . ({&#39;哈利·波特&#39;, &#39;魔法石&#39;}, {&#39;哈利·波特&#39;, &#39;密室&#39;}) . magic &amp; harry_potter_books . {&#39;哈利·波特&#39;, &#39;魔法石&#39;} . harry_potter_books - magic . {&#39;凤凰社&#39;, &#39;密室&#39;, &#39;死亡圣器&#39;, &#39;混血王子&#39;, &#39;火焰杯&#39;, &#39;被诅咒的孩子&#39;, &#39;阿兹卡班囚徒&#39;} . magic | secret . {&#39;哈利·波特&#39;, &#39;密室&#39;, &#39;魔法石&#39;} . magic ^ secret . {&#39;密室&#39;, &#39;魔法石&#39;} . magic.add(&quot;死亡圣器&quot;) magic . {&#39;哈利·波特&#39;, &#39;死亡圣器&#39;, &#39;魔法石&#39;} . frozenset不可变对象，不支持add、remove、pop和update等操作 . magic2 = frozenset(magic) magic2 . frozenset({&#39;哈利·波特&#39;, &#39;死亡圣器&#39;, &#39;魔法石&#39;}) . magic2.add . AttributeError Traceback (most recent call last) &lt;ipython-input-97-02238ce56a10&gt; in &lt;module&gt; -&gt; 1 magic2.add AttributeError: &#39;frozenset&#39; object has no attribute &#39;add&#39; . dict(&#23383;&#20856;) . 映射类型，形式为若干键:值对。键不可重复，列表、字典或其他可变类型不可作为键。 . Python3.6改写字典算法，保持顺序不变。 . harry_potter1 = dict( 魔法石=1997, 密室=1998, 阿兹卡班囚徒=1999, 火焰杯=2000, 凤凰社=2003, 混血王子=2005, 死亡圣器=2007, ) . harry_potter2 = { &quot;魔法石&quot;: 1997, &quot;密室&quot;: 1998, &quot;阿兹卡班囚徒&quot;: 1999, &quot;火焰杯&quot;: 2000, &quot;凤凰社&quot;: 2003, &quot;混血王子&quot;: 2005, &quot;死亡圣器&quot;: 2007, } . harry_potter1 == harry_potter2 . True . harry_potter3 = dict( zip( (&quot;魔法石&quot;, &quot;密室&quot;, &quot;阿兹卡班囚徒&quot;, &quot;火焰杯&quot;, &quot;凤凰社&quot;, &quot;混血王子&quot;, &quot;死亡圣器&quot;,), (1997, 1998, 1999, 2000, 2003, 2005, 2007,), ) ) . . harry_potter1 == harry_potter2 == harry_potter3 . True . harry_potter2[&quot;凤凰社&quot;] . 2003 . for book, year in harry_potter2.items(): print(f&quot;《哈利·波特与{book}》出版于{year}年&quot;) . 《哈利·波特与魔法石》出版于1997年 《哈利·波特与密室》出版于1998年 《哈利·波特与阿兹卡班囚徒》出版于1999年 《哈利·波特与火焰杯》出版于2000年 《哈利·波特与凤凰社》出版于2003年 《哈利·波特与混血王子》出版于2005年 《哈利·波特与死亡圣器》出版于2007年 . harry_potter2[&quot;被诅咒的孩子&quot;] = 2016 harry_potter2 . {&#39;魔法石&#39;: 1997, &#39;密室&#39;: 1998, &#39;阿兹卡班囚徒&#39;: 1999, &#39;火焰杯&#39;: 2000, &#39;凤凰社&#39;: 2003, &#39;混血王子&#39;: 2005, &#39;死亡圣器&#39;: 2007, &#39;被诅咒的孩子&#39;: 2016} . harry_potter2.pop(&quot;被诅咒的孩子&quot;) . 2016 . harry_potter2 . {&#39;魔法石&#39;: 1997, &#39;密室&#39;: 1998, &#39;阿兹卡班囚徒&#39;: 1999, &#39;火焰杯&#39;: 2000, &#39;凤凰社&#39;: 2003, &#39;混血王子&#39;: 2005, &#39;死亡圣器&#39;: 2007} . &#20989;&#25968;&#24335;&#32534;&#31243; . 借助Python的不可变对象和高阶函数，进行更简洁的表达，实现快速并行计算。 . 可变与不可变对象 | max、min、sum、any、all、sorted、reversed | filter、map、reduce | multiprocessing与concurrent.futures | 第三方高阶函数包：cytoolz、fn与fancy | &#21487;&#21464;&#19982;&#19981;&#21487;&#21464;&#23545;&#35937; . Python中一切皆对象，对象有两种：可变（mutable ）与不可变（immutable） | 对象被实例化（instantiate）之后获得唯一id，可变对象可以改变状态或内容，而不可变不能修改 | 不可变对象：int、float、bool、string/unicode、tuple*、nametuple、frozenset，读取速度快，节省内存 | 可变对象：list、dict、set、自定义类 | tuple例外 | tup = ([3, 4, 5], &#39;two&#39;) . tup[0][-1] = 1 . tup . ([3, 4, 1], &#39;two&#39;) . collections.nametuple . symbol name current percent pe_ttm current_year_percent volume . 0 SH601398 | 工商银行 | 5.17 | 0.39 | 5.855 | -12.07 | 104063910 | . 1 SH601939 | 建设银行 | 6.43 | 0.16 | 5.939 | -11.07 | 51089825 | . 2 SH600519 | 贵州茅台 | 1265.70 | -0.72 | 36.908 | 6.99 | 2466087 | . 3 SH601318 | 中国平安 | 74.46 | 0.62 | 10.474 | -12.87 | 48625473 | . 4 SH601288 | 农业银行 | 3.46 | 0.58 | 5.631 | -6.23 | 118473509 | . 5 SH601988 | 中国银行 | 3.48 | 0.58 | 5.420 | -5.69 | 79563490 | . 6 SH600036 | 招商银行 | 35.09 | 0.20 | 9.274 | -6.63 | 71533247 | . 7 SH601857 | 中国石油 | 4.44 | 1.37 | 42.328 | -23.84 | 85973295 | . 8 SH601628 | 中国人寿 | 28.54 | -0.73 | 16.348 | -18.15 | 16644522 | . 9 SH600028 | 中国石化 | 4.46 | 0.45 | 23.430 | -12.72 | 119640204 | . data = [{&quot;symbol&quot;: &quot;SH601398&quot;,&quot;name&quot;: &quot;工商银行&quot;,&quot;current&quot;: 5.17,&quot;percent&quot;: 0.39,&quot;pe_ttm&quot;: 5.855,&quot;current_year_percent&quot;: -12.07,&quot;volume&quot;: 104063910,&quot;industry&quot;: &quot;银行&quot;,}, {&quot;symbol&quot;: &quot;SH601939&quot;,&quot;name&quot;: &quot;建设银行&quot;,&quot;current&quot;: 6.43,&quot;percent&quot;: 0.16,&quot;pe_ttm&quot;: 5.939,&quot;current_year_percent&quot;: -11.07,&quot;volume&quot;: 51089825,&quot;industry&quot;: &quot;银行&quot;,}, {&quot;symbol&quot;: &quot;SH600519&quot;,&quot;name&quot;: &quot;贵州茅台&quot;,&quot;current&quot;: 1265.7,&quot;percent&quot;: -0.72,&quot;pe_ttm&quot;: 36.908,&quot;current_year_percent&quot;: 6.99,&quot;volume&quot;: 2466087,&quot;industry&quot;: &quot;白酒&quot;,}, {&quot;symbol&quot;: &quot;SH601318&quot;,&quot;name&quot;: &quot;中国平安&quot;,&quot;current&quot;: 74.46,&quot;percent&quot;: 0.62,&quot;pe_ttm&quot;: 10.474,&quot;current_year_percent&quot;: -12.87,&quot;volume&quot;: 48625473,&quot;industry&quot;: &quot;保险&quot;,}, {&quot;symbol&quot;: &quot;SH601288&quot;,&quot;name&quot;: &quot;农业银行&quot;,&quot;current&quot;: 3.46,&quot;percent&quot;: 0.58,&quot;pe_ttm&quot;: 5.631,&quot;current_year_percent&quot;: -6.23,&quot;volume&quot;: 118473509,&quot;industry&quot;: &quot;银行&quot;,}, {&quot;symbol&quot;: &quot;SH601988&quot;,&quot;name&quot;: &quot;中国银行&quot;,&quot;current&quot;: 3.48,&quot;percent&quot;: 0.58,&quot;pe_ttm&quot;: 5.42,&quot;current_year_percent&quot;: -5.69,&quot;volume&quot;: 79563490,&quot;industry&quot;: &quot;银行&quot;,}, {&quot;symbol&quot;: &quot;SH600036&quot;,&quot;name&quot;: &quot;招商银行&quot;,&quot;current&quot;: 35.09,&quot;percent&quot;: 0.2,&quot;pe_ttm&quot;: 9.274,&quot;current_year_percent&quot;: -6.63,&quot;volume&quot;: 71533247,&quot;industry&quot;: &quot;银行&quot;,}, {&quot;symbol&quot;: &quot;SH601857&quot;,&quot;name&quot;: &quot;中国石油&quot;,&quot;current&quot;: 4.44,&quot;percent&quot;: 1.37,&quot;pe_ttm&quot;: 42.328,&quot;current_year_percent&quot;: -23.84,&quot;volume&quot;: 85973295,&quot;industry&quot;: &quot;石化&quot;,}, {&quot;symbol&quot;: &quot;SH601628&quot;,&quot;name&quot;: &quot;中国人寿&quot;,&quot;current&quot;: 28.54,&quot;percent&quot;: -0.73,&quot;pe_ttm&quot;: 16.348,&quot;current_year_percent&quot;: -18.15,&quot;volume&quot;: 16644522,&quot;industry&quot;: &quot;保险&quot;,}, {&quot;symbol&quot;: &quot;SH600028&quot;,&quot;name&quot;: &quot;中国石化&quot;,&quot;current&quot;: 4.46,&quot;percent&quot;: 0.45,&quot;pe_ttm&quot;: 23.43,&quot;current_year_percent&quot;: -12.72,&quot;volume&quot;: 119640204,&quot;industry&quot;: &quot;石化&quot;,}] . from collections import namedtuple . Stocks = namedtuple( &quot;Stocks&quot;, [ &quot;symbol&quot;, &quot;name&quot;, &quot;current&quot;, &quot;percent&quot;, &quot;pe_ttm&quot;, &quot;current_year_percent&quot;, &quot;volume&quot;, &quot;industry&quot;, ], ) . Stocks . __main__.Stocks . icbc = Stocks( symbol=&quot;SH601398&quot;, name=&quot;工商银行&quot;, current=5.17, percent=0.39, pe_ttm=5.855, current_year_percent=-12.07, volume=104063910, industry=&quot;银行&quot;, ) . icbc . Stocks(symbol=&#39;SH601398&#39;, name=&#39;工商银行&#39;, current=5.17, percent=0.39, pe_ttm=5.855, current_year_percent=-12.07, volume=104063910, industry=&#39;银行&#39;) . icbc.name . &#39;工商银行&#39; . icbc.name = &#39;dd&#39; . AttributeError Traceback (most recent call last) &lt;ipython-input-118-74e3a93185c6&gt; in &lt;module&gt; -&gt; 1 icbc.name = &#39;dd&#39; AttributeError: can&#39;t set attribute . stocks = tuple(Stocks(**_) for _ in data) . stocks . (Stocks(symbol=&#39;SH601398&#39;, name=&#39;工商银行&#39;, current=5.17, percent=0.39, pe_ttm=5.855, current_year_percent=-12.07, volume=104063910, industry=&#39;银行&#39;), Stocks(symbol=&#39;SH601939&#39;, name=&#39;建设银行&#39;, current=6.43, percent=0.16, pe_ttm=5.939, current_year_percent=-11.07, volume=51089825, industry=&#39;银行&#39;), Stocks(symbol=&#39;SH600519&#39;, name=&#39;贵州茅台&#39;, current=1265.7, percent=-0.72, pe_ttm=36.908, current_year_percent=6.99, volume=2466087, industry=&#39;白酒&#39;), Stocks(symbol=&#39;SH601318&#39;, name=&#39;中国平安&#39;, current=74.46, percent=0.62, pe_ttm=10.474, current_year_percent=-12.87, volume=48625473, industry=&#39;保险&#39;), Stocks(symbol=&#39;SH601288&#39;, name=&#39;农业银行&#39;, current=3.46, percent=0.58, pe_ttm=5.631, current_year_percent=-6.23, volume=118473509, industry=&#39;银行&#39;), Stocks(symbol=&#39;SH601988&#39;, name=&#39;中国银行&#39;, current=3.48, percent=0.58, pe_ttm=5.42, current_year_percent=-5.69, volume=79563490, industry=&#39;银行&#39;), Stocks(symbol=&#39;SH600036&#39;, name=&#39;招商银行&#39;, current=35.09, percent=0.2, pe_ttm=9.274, current_year_percent=-6.63, volume=71533247, industry=&#39;银行&#39;), Stocks(symbol=&#39;SH601857&#39;, name=&#39;中国石油&#39;, current=4.44, percent=1.37, pe_ttm=42.328, current_year_percent=-23.84, volume=85973295, industry=&#39;石化&#39;), Stocks(symbol=&#39;SH601628&#39;, name=&#39;中国人寿&#39;, current=28.54, percent=-0.73, pe_ttm=16.348, current_year_percent=-18.15, volume=16644522, industry=&#39;保险&#39;), Stocks(symbol=&#39;SH600028&#39;, name=&#39;中国石化&#39;, current=4.46, percent=0.45, pe_ttm=23.43, current_year_percent=-12.72, volume=119640204, industry=&#39;石化&#39;)) . stocks[0].name . &#39;工商银行&#39; . max&#12289;min&#12289;sum&#12289;any&#12289;all&#12289;sorted&#12289;reversed . max(stocks) . Stocks(symbol=&#39;SH601988&#39;, name=&#39;中国银行&#39;, current=3.48, percent=0.58, pe_ttm=5.42, current_year_percent=-5.69, volume=79563490, industry=&#39;银行&#39;) . max(stocks, key=lambda _: _.current) . Stocks(symbol=&#39;SH600519&#39;, name=&#39;贵州茅台&#39;, current=1265.7, percent=-0.72, pe_ttm=36.908, current_year_percent=6.99, volume=2466087, industry=&#39;白酒&#39;) . min(stocks) . Stocks(symbol=&#39;SH600028&#39;, name=&#39;中国石化&#39;, current=4.46, percent=0.45, pe_ttm=23.43, current_year_percent=-12.72, volume=119640204, industry=&#39;石化&#39;) . min(stocks, key=lambda _: _.current) . Stocks(symbol=&#39;SH601288&#39;, name=&#39;农业银行&#39;, current=3.46, percent=0.58, pe_ttm=5.631, current_year_percent=-6.23, volume=118473509, industry=&#39;银行&#39;) . sum((1, 2, 3, 0)) . 6 . any((1, 2, 3, 0)) . True . all((1, 2, 3, 0)) . False . sorted(stocks, key=lambda _: _.current) . [Stocks(symbol=&#39;SH601288&#39;, name=&#39;农业银行&#39;, current=3.46, percent=0.58, pe_ttm=5.631, current_year_percent=-6.23, volume=118473509, industry=&#39;银行&#39;), Stocks(symbol=&#39;SH601988&#39;, name=&#39;中国银行&#39;, current=3.48, percent=0.58, pe_ttm=5.42, current_year_percent=-5.69, volume=79563490, industry=&#39;银行&#39;), Stocks(symbol=&#39;SH601857&#39;, name=&#39;中国石油&#39;, current=4.44, percent=1.37, pe_ttm=42.328, current_year_percent=-23.84, volume=85973295, industry=&#39;石化&#39;), Stocks(symbol=&#39;SH600028&#39;, name=&#39;中国石化&#39;, current=4.46, percent=0.45, pe_ttm=23.43, current_year_percent=-12.72, volume=119640204, industry=&#39;石化&#39;), Stocks(symbol=&#39;SH601398&#39;, name=&#39;工商银行&#39;, current=5.17, percent=0.39, pe_ttm=5.855, current_year_percent=-12.07, volume=104063910, industry=&#39;银行&#39;), Stocks(symbol=&#39;SH601939&#39;, name=&#39;建设银行&#39;, current=6.43, percent=0.16, pe_ttm=5.939, current_year_percent=-11.07, volume=51089825, industry=&#39;银行&#39;), Stocks(symbol=&#39;SH601628&#39;, name=&#39;中国人寿&#39;, current=28.54, percent=-0.73, pe_ttm=16.348, current_year_percent=-18.15, volume=16644522, industry=&#39;保险&#39;), Stocks(symbol=&#39;SH600036&#39;, name=&#39;招商银行&#39;, current=35.09, percent=0.2, pe_ttm=9.274, current_year_percent=-6.63, volume=71533247, industry=&#39;银行&#39;), Stocks(symbol=&#39;SH601318&#39;, name=&#39;中国平安&#39;, current=74.46, percent=0.62, pe_ttm=10.474, current_year_percent=-12.87, volume=48625473, industry=&#39;保险&#39;), Stocks(symbol=&#39;SH600519&#39;, name=&#39;贵州茅台&#39;, current=1265.7, percent=-0.72, pe_ttm=36.908, current_year_percent=6.99, volume=2466087, industry=&#39;白酒&#39;)] . tuple(reversed(stocks)) . (Stocks(symbol=&#39;SH600028&#39;, name=&#39;中国石化&#39;, current=4.46, percent=0.45, pe_ttm=23.43, current_year_percent=-12.72, volume=119640204, industry=&#39;石化&#39;), Stocks(symbol=&#39;SH601628&#39;, name=&#39;中国人寿&#39;, current=28.54, percent=-0.73, pe_ttm=16.348, current_year_percent=-18.15, volume=16644522, industry=&#39;保险&#39;), Stocks(symbol=&#39;SH601857&#39;, name=&#39;中国石油&#39;, current=4.44, percent=1.37, pe_ttm=42.328, current_year_percent=-23.84, volume=85973295, industry=&#39;石化&#39;), Stocks(symbol=&#39;SH600036&#39;, name=&#39;招商银行&#39;, current=35.09, percent=0.2, pe_ttm=9.274, current_year_percent=-6.63, volume=71533247, industry=&#39;银行&#39;), Stocks(symbol=&#39;SH601988&#39;, name=&#39;中国银行&#39;, current=3.48, percent=0.58, pe_ttm=5.42, current_year_percent=-5.69, volume=79563490, industry=&#39;银行&#39;), Stocks(symbol=&#39;SH601288&#39;, name=&#39;农业银行&#39;, current=3.46, percent=0.58, pe_ttm=5.631, current_year_percent=-6.23, volume=118473509, industry=&#39;银行&#39;), Stocks(symbol=&#39;SH601318&#39;, name=&#39;中国平安&#39;, current=74.46, percent=0.62, pe_ttm=10.474, current_year_percent=-12.87, volume=48625473, industry=&#39;保险&#39;), Stocks(symbol=&#39;SH600519&#39;, name=&#39;贵州茅台&#39;, current=1265.7, percent=-0.72, pe_ttm=36.908, current_year_percent=6.99, volume=2466087, industry=&#39;白酒&#39;), Stocks(symbol=&#39;SH601939&#39;, name=&#39;建设银行&#39;, current=6.43, percent=0.16, pe_ttm=5.939, current_year_percent=-11.07, volume=51089825, industry=&#39;银行&#39;), Stocks(symbol=&#39;SH601398&#39;, name=&#39;工商银行&#39;, current=5.17, percent=0.39, pe_ttm=5.855, current_year_percent=-12.07, volume=104063910, industry=&#39;银行&#39;)) . filter&#12289;map&#12289;reduce . tuple(filter(lambda s: s.current &gt; 5, stocks)) . (Stocks(symbol=&#39;SH601398&#39;, name=&#39;工商银行&#39;, current=5.17, percent=0.39, pe_ttm=5.855, current_year_percent=-12.07, volume=104063910, industry=&#39;银行&#39;), Stocks(symbol=&#39;SH601939&#39;, name=&#39;建设银行&#39;, current=6.43, percent=0.16, pe_ttm=5.939, current_year_percent=-11.07, volume=51089825, industry=&#39;银行&#39;), Stocks(symbol=&#39;SH600519&#39;, name=&#39;贵州茅台&#39;, current=1265.7, percent=-0.72, pe_ttm=36.908, current_year_percent=6.99, volume=2466087, industry=&#39;白酒&#39;), Stocks(symbol=&#39;SH601318&#39;, name=&#39;中国平安&#39;, current=74.46, percent=0.62, pe_ttm=10.474, current_year_percent=-12.87, volume=48625473, industry=&#39;保险&#39;), Stocks(symbol=&#39;SH600036&#39;, name=&#39;招商银行&#39;, current=35.09, percent=0.2, pe_ttm=9.274, current_year_percent=-6.63, volume=71533247, industry=&#39;银行&#39;), Stocks(symbol=&#39;SH601628&#39;, name=&#39;中国人寿&#39;, current=28.54, percent=-0.73, pe_ttm=16.348, current_year_percent=-18.15, volume=16644522, industry=&#39;保险&#39;)) . tuple(s for s in stocks if s.current &gt; 5) . (Stocks(symbol=&#39;SH601398&#39;, name=&#39;工商银行&#39;, current=5.17, percent=0.39, pe_ttm=5.855, current_year_percent=-12.07, volume=104063910, industry=&#39;银行&#39;), Stocks(symbol=&#39;SH601939&#39;, name=&#39;建设银行&#39;, current=6.43, percent=0.16, pe_ttm=5.939, current_year_percent=-11.07, volume=51089825, industry=&#39;银行&#39;), Stocks(symbol=&#39;SH600519&#39;, name=&#39;贵州茅台&#39;, current=1265.7, percent=-0.72, pe_ttm=36.908, current_year_percent=6.99, volume=2466087, industry=&#39;白酒&#39;), Stocks(symbol=&#39;SH601318&#39;, name=&#39;中国平安&#39;, current=74.46, percent=0.62, pe_ttm=10.474, current_year_percent=-12.87, volume=48625473, industry=&#39;保险&#39;), Stocks(symbol=&#39;SH600036&#39;, name=&#39;招商银行&#39;, current=35.09, percent=0.2, pe_ttm=9.274, current_year_percent=-6.63, volume=71533247, industry=&#39;银行&#39;), Stocks(symbol=&#39;SH601628&#39;, name=&#39;中国人寿&#39;, current=28.54, percent=-0.73, pe_ttm=16.348, current_year_percent=-18.15, volume=16644522, industry=&#39;保险&#39;)) . tuple(map(lambda s: (s.name, round(s.volume / 10000, 1)), stocks)) . ((&#39;工商银行&#39;, 10406.4), (&#39;建设银行&#39;, 5109.0), (&#39;贵州茅台&#39;, 246.6), (&#39;中国平安&#39;, 4862.5), (&#39;农业银行&#39;, 11847.4), (&#39;中国银行&#39;, 7956.3), (&#39;招商银行&#39;, 7153.3), (&#39;中国石油&#39;, 8597.3), (&#39;中国人寿&#39;, 1664.5), (&#39;中国石化&#39;, 11964.0)) . tuple((s.name, round(s.volume / 10000, 1)) for s in stocks) . ((&#39;工商银行&#39;, 10406.4), (&#39;建设银行&#39;, 5109.0), (&#39;贵州茅台&#39;, 246.6), (&#39;中国平安&#39;, 4862.5), (&#39;农业银行&#39;, 11847.4), (&#39;中国银行&#39;, 7956.3), (&#39;招商银行&#39;, 7153.3), (&#39;中国石油&#39;, 8597.3), (&#39;中国人寿&#39;, 1664.5), (&#39;中国石化&#39;, 11964.0)) . from functools import reduce . reduce? . reduce(lambda acc, v: acc + v.volume, stocks, 0) . 698073562 . from itertools import accumulate . tuple(accumulate(s.volume for s in stocks)) . (104063910, 155153735, 157619822, 206245295, 324718804, 404282294, 475815541, 561788836, 578433358, 698073562) . groupby . def box(acc, v): acc[v.industry].append(v.name) return acc . stocks_industry = reduce(box, stocks, {&quot;银行&quot;: [], &quot;保险&quot;: [], &quot;白酒&quot;: [], &quot;石化&quot;: []}) stocks_industry . {&#39;银行&#39;: [&#39;工商银行&#39;, &#39;建设银行&#39;, &#39;农业银行&#39;, &#39;中国银行&#39;, &#39;招商银行&#39;], &#39;保险&#39;: [&#39;中国平安&#39;, &#39;中国人寿&#39;], &#39;白酒&#39;: [&#39;贵州茅台&#39;], &#39;石化&#39;: [&#39;中国石油&#39;, &#39;中国石化&#39;]} . from collections import defaultdict . stocks_industry = reduce(box, stocks, defaultdict(list)) stocks_industry . defaultdict(list, {&#39;银行&#39;: [&#39;工商银行&#39;, &#39;建设银行&#39;, &#39;农业银行&#39;, &#39;中国银行&#39;, &#39;招商银行&#39;], &#39;白酒&#39;: [&#39;贵州茅台&#39;], &#39;保险&#39;: [&#39;中国平安&#39;, &#39;中国人寿&#39;], &#39;石化&#39;: [&#39;中国石油&#39;, &#39;中国石化&#39;]}) . stocks_industry = reduce( lambda acc, v: {**acc, **{v.industry: acc[v.industry] + [v.name]}}, stocks, {&quot;银行&quot;: [], &quot;白酒&quot;: [], &quot;保险&quot;: [], &quot;石化&quot;: []}, ) stocks_industry . NameError Traceback (most recent call last) &lt;ipython-input-53-1a6f22b9366d&gt; in &lt;module&gt; 1 stocks_industry = reduce( 2 lambda acc, v: {**acc, **{v.industry: acc[v.industry] + [v.name]}}, -&gt; 3 stocks, 4 {&#34;银行&#34;: [], &#34;白酒&#34;: [], &#34;保险&#34;: [], &#34;石化&#34;: []}, 5 ) NameError: name &#39;stocks&#39; is not defined . from itertools import groupby . { k: [_.name for _ in s] for k, s in groupby( sorted(stocks, key=lambda s: s.industry), key=lambda s: s.industry ) } . {&#39;保险&#39;: [&#39;中国平安&#39;, &#39;中国人寿&#39;], &#39;白酒&#39;: [&#39;贵州茅台&#39;], &#39;石化&#39;: [&#39;中国石油&#39;, &#39;中国石化&#39;], &#39;银行&#39;: [&#39;工商银行&#39;, &#39;建设银行&#39;, &#39;农业银行&#39;, &#39;中国银行&#39;, &#39;招商银行&#39;]} . multiprocessing&#19982;concurrent.futures . import time import os import multiprocessing . def cmpt_open(x): print(f&quot;进程：{os.getpid()} 正在计算 {x.name}&quot;) time.sleep(1) rst = {&quot;name&quot;: x.name, &quot;open&quot;: x.current / (1 + x.percent * 0.01)} print(f&quot;进程：{os.getpid()} 完成计算 {x.name}&quot;) return rst . %%time result = tuple(map(cmpt_open, stocks)) result . 进程：81395 正在计算 工商银行 进程：81395 完成计算 工商银行 进程：81395 正在计算 建设银行 进程：81395 完成计算 建设银行 进程：81395 正在计算 贵州茅台 进程：81395 完成计算 贵州茅台 进程：81395 正在计算 中国平安 进程：81395 完成计算 中国平安 进程：81395 正在计算 农业银行 进程：81395 完成计算 农业银行 进程：81395 正在计算 中国银行 进程：81395 完成计算 中国银行 进程：81395 正在计算 招商银行 进程：81395 完成计算 招商银行 进程：81395 正在计算 中国石油 进程：81395 完成计算 中国石油 进程：81395 正在计算 中国人寿 进程：81395 完成计算 中国人寿 进程：81395 正在计算 中国石化 进程：81395 完成计算 中国石化 CPU times: user 18.9 ms, sys: 2.09 ms, total: 21 ms Wall time: 10 s . ({&#39;name&#39;: &#39;工商银行&#39;, &#39;open&#39;: 5.149915330212172}, {&#39;name&#39;: &#39;建设银行&#39;, &#39;open&#39;: 6.419728434504791}, {&#39;name&#39;: &#39;贵州茅台&#39;, &#39;open&#39;: 1274.8791297340854}, {&#39;name&#39;: &#39;中国平安&#39;, &#39;open&#39;: 74.00119260584377}, {&#39;name&#39;: &#39;农业银行&#39;, &#39;open&#39;: 3.4400477232054083}, {&#39;name&#39;: &#39;中国银行&#39;, &#39;open&#39;: 3.459932392125671}, {&#39;name&#39;: &#39;招商银行&#39;, &#39;open&#39;: 35.019960079840324}, {&#39;name&#39;: &#39;中国石油&#39;, &#39;open&#39;: 4.379994081089079}, {&#39;name&#39;: &#39;中国人寿&#39;, &#39;open&#39;: 28.749874080789763}, {&#39;name&#39;: &#39;中国石化&#39;, &#39;open&#39;: 4.440019910403186}) . %%time pool = multiprocessing.Pool() result = pool.map(cmpt_open, stocks) result . 进程：47440 正在计算 建设银行 进程：47443 正在计算 农业银行 进程：47447 正在计算 招商银行 进程：47444 正在计算 中国银行 进程：47451 正在计算 中国人寿 进程：47442 正在计算 中国平安 进程：47452 正在计算 中国石化 进程：47439 正在计算 工商银行 进程：47450 正在计算 中国石油 进程：47441 正在计算 贵州茅台 进程：47440 完成计算 建设银行 进程：47443 完成计算 农业银行 进程：47447 完成计算 招商银行 进程：47442 完成计算 中国平安 进程：47439 完成计算 工商银行 进程：47444 完成计算 中国银行 进程：47451 完成计算 中国人寿 CPU times: user 40 ms, sys: 159 ms, total: 199 ms Wall time: 1.19 s 进程：47450 完成计算 中国石油 进程：47441 完成计算 贵州茅台 进程：47452 完成计算 中国石化 . [{&#39;name&#39;: &#39;工商银行&#39;, &#39;open&#39;: 5.149915330212172}, {&#39;name&#39;: &#39;建设银行&#39;, &#39;open&#39;: 6.419728434504791}, {&#39;name&#39;: &#39;贵州茅台&#39;, &#39;open&#39;: 1274.8791297340854}, {&#39;name&#39;: &#39;中国平安&#39;, &#39;open&#39;: 74.00119260584377}, {&#39;name&#39;: &#39;农业银行&#39;, &#39;open&#39;: 3.4400477232054083}, {&#39;name&#39;: &#39;中国银行&#39;, &#39;open&#39;: 3.459932392125671}, {&#39;name&#39;: &#39;招商银行&#39;, &#39;open&#39;: 35.019960079840324}, {&#39;name&#39;: &#39;中国石油&#39;, &#39;open&#39;: 4.379994081089079}, {&#39;name&#39;: &#39;中国人寿&#39;, &#39;open&#39;: 28.749874080789763}, {&#39;name&#39;: &#39;中国石化&#39;, &#39;open&#39;: 4.440019910403186}] . import concurrent.futures . %%time with concurrent.futures.ProcessPoolExecutor() as pool: result = pool.map(cmpt_open, stocks) tuple(result) . 进程：48625 正在计算 工商银行 进程：48626 正在计算 建设银行 进程：48628 正在计算 中国平安 进程：48627 正在计算 贵州茅台 进程：48631 正在计算 招商银行 进程：48629 正在计算 农业银行 进程：48634 正在计算 中国石化 进程：48630 正在计算 中国银行 进程：48633 正在计算 中国人寿 进程：48632 正在计算 中国石油 进程：48625 完成计算 工商银行 进程：48626 完成计算 建设银行 进程：48628 完成计算 中国平安 进程：48627 完成计算 贵州茅台 进程：48629 完成计算 农业银行 进程：48631 完成计算 招商银行 进程：48632 完成计算 中国石油 进程：48634 完成计算 中国石化 进程：48633 完成计算 中国人寿 进程：48630 完成计算 中国银行 CPU times: user 32.1 ms, sys: 192 ms, total: 224 ms Wall time: 1.22 s . ({&#39;name&#39;: &#39;工商银行&#39;, &#39;open&#39;: 5.149915330212172}, {&#39;name&#39;: &#39;建设银行&#39;, &#39;open&#39;: 6.419728434504791}, {&#39;name&#39;: &#39;贵州茅台&#39;, &#39;open&#39;: 1274.8791297340854}, {&#39;name&#39;: &#39;中国平安&#39;, &#39;open&#39;: 74.00119260584377}, {&#39;name&#39;: &#39;农业银行&#39;, &#39;open&#39;: 3.4400477232054083}, {&#39;name&#39;: &#39;中国银行&#39;, &#39;open&#39;: 3.459932392125671}, {&#39;name&#39;: &#39;招商银行&#39;, &#39;open&#39;: 35.019960079840324}, {&#39;name&#39;: &#39;中国石油&#39;, &#39;open&#39;: 4.379994081089079}, {&#39;name&#39;: &#39;中国人寿&#39;, &#39;open&#39;: 28.749874080789763}, {&#39;name&#39;: &#39;中国石化&#39;, &#39;open&#39;: 4.440019910403186}) . %%time with concurrent.futures.ThreadPoolExecutor() as pool: result = pool.map(cmpt_open, stocks) tuple(result) . 进程：81395 正在计算 工商银行 进程：81395 正在计算 建设银行 进程：81395 正在计算 贵州茅台 进程：81395 正在计算 中国平安 进程：81395 正在计算 农业银行 进程：81395 正在计算 中国银行 进程：81395 正在计算 招商银行 进程：81395 正在计算 中国石油 进程：81395 正在计算 中国人寿进程：81395 正在计算 中国石化 进程：81395 完成计算 工商银行 进程：81395 完成计算 建设银行 进程：81395 完成计算 贵州茅台 进程：81395 完成计算 中国平安 进程：81395 完成计算 农业银行 进程：81395 完成计算 中国银行进程：81395 完成计算 招商银行 进程：81395 完成计算 中国石油 进程：81395 完成计算 中国人寿进程：81395 完成计算 中国石化 CPU times: user 19.2 ms, sys: 8.83 ms, total: 28 ms Wall time: 1.01 s . ({&#39;name&#39;: &#39;工商银行&#39;, &#39;open&#39;: 5.149915330212172}, {&#39;name&#39;: &#39;建设银行&#39;, &#39;open&#39;: 6.419728434504791}, {&#39;name&#39;: &#39;贵州茅台&#39;, &#39;open&#39;: 1274.8791297340854}, {&#39;name&#39;: &#39;中国平安&#39;, &#39;open&#39;: 74.00119260584377}, {&#39;name&#39;: &#39;农业银行&#39;, &#39;open&#39;: 3.4400477232054083}, {&#39;name&#39;: &#39;中国银行&#39;, &#39;open&#39;: 3.459932392125671}, {&#39;name&#39;: &#39;招商银行&#39;, &#39;open&#39;: 35.019960079840324}, {&#39;name&#39;: &#39;中国石油&#39;, &#39;open&#39;: 4.379994081089079}, {&#39;name&#39;: &#39;中国人寿&#39;, &#39;open&#39;: 28.749874080789763}, {&#39;name&#39;: &#39;中国石化&#39;, &#39;open&#39;: 4.440019910403186}) . cytoolz&#12289;fn &#19982;fancy . 借助第三方包实现大量高阶函数，可以增强Python函数式编程功能，包括纯函数、curry柯里化（偏函数）、lazy惰性计算、并行化... . 下面以cytoolz为例演示双城记词频统计： . from cytoolz import map, concat, frequencies # cytoolz 的 map 默认惰性计算 . %%time frequencies( concat(map(str.upper, open(&quot;tale-of-two-cities.txt&quot;, &quot;r&quot;, encoding=&quot;utf-8-sig&quot;))) ) . CPU times: user 79.4 ms, sys: 2.53 ms, total: 82 ms Wall time: 89.1 ms . {&#39;T&#39;: 54050, &#39;H&#39;: 38974, &#39;E&#39;: 74839, &#39; &#39;: 126957, &#39;P&#39;: 9960, &#39;R&#39;: 37212, &#39;O&#39;: 46537, &#39;J&#39;: 714, &#39;C&#39;: 13899, &#39;G&#39;: 12547, &#39;U&#39;: 16738, &#39;N&#39;: 42385, &#39;B&#39;: 8422, &#39;K&#39;: 4787, &#39;F&#39;: 13563, &#39;A&#39;: 48167, &#39;L&#39;: 22048, &#39;W&#39;: 14121, &#39;I&#39;: 41016, &#39;S&#39;: 37587, &#39;,&#39;: 13274, &#39;Y&#39;: 12185, &#39;D&#39;: 28046, &#39; n&#39;: 16271, &#39;M&#39;: 15296, &#39;V&#39;: 5204, &#39;.&#39;: 6815, &#39;-&#39;: 2431, &#39;:&#39;: 269, &#39;1&#39;: 63, &#39;9&#39;: 18, &#39;4&#39;: 10, &#39;[&#39;: 2, &#39;#&#39;: 1, &#39;8&#39;: 16, &#39;]&#39;: 2, &#39;2&#39;: 14, &#39;0&#39;: 20, &#39;7&#39;: 14, &#39;3&#39;: 13, &#39;*&#39;: 90, &#39;X&#39;: 723, &#34;&#39;&#34;: 1269, &#39;Q&#39;: 666, &#39;;&#39;: 1108, &#39;Z&#39;: 215, &#39;(&#39;: 151, &#39;)&#39;: 151, &#39;&#34;&#39;: 5681, &#39;!&#39;: 955, &#39;?&#39;: 913, &#39;_&#39;: 182, &#39;É&#39;: 2, &#39;6&#39;: 9, &#39;5&#39;: 13, &#39;/&#39;: 24, &#39;%&#39;: 1, &#39;@&#39;: 2, &#39;$&#39;: 2} . from collections import Counter . %%time Counter( map(str.upper, open(&quot;tale-of-two-cities.txt&quot;, &quot;r&quot;, encoding=&quot;utf-8-sig&quot;).read()) ) . CPU times: user 190 ms, sys: 2.68 ms, total: 193 ms Wall time: 190 ms . Counter({&#39;T&#39;: 54050, &#39;H&#39;: 38974, &#39;E&#39;: 74839, &#39; &#39;: 126957, &#39;P&#39;: 9960, &#39;R&#39;: 37212, &#39;O&#39;: 46537, &#39;J&#39;: 714, &#39;C&#39;: 13899, &#39;G&#39;: 12547, &#39;U&#39;: 16738, &#39;N&#39;: 42385, &#39;B&#39;: 8422, &#39;K&#39;: 4787, &#39;F&#39;: 13563, &#39;A&#39;: 48167, &#39;L&#39;: 22048, &#39;W&#39;: 14121, &#39;I&#39;: 41016, &#39;S&#39;: 37587, &#39;,&#39;: 13274, &#39;Y&#39;: 12185, &#39;D&#39;: 28046, &#39; n&#39;: 16271, &#39;M&#39;: 15296, &#39;V&#39;: 5204, &#39;.&#39;: 6815, &#39;-&#39;: 2431, &#39;:&#39;: 269, &#39;1&#39;: 63, &#39;9&#39;: 18, &#39;4&#39;: 10, &#39;[&#39;: 2, &#39;#&#39;: 1, &#39;8&#39;: 16, &#39;]&#39;: 2, &#39;2&#39;: 14, &#39;0&#39;: 20, &#39;7&#39;: 14, &#39;3&#39;: 13, &#39;*&#39;: 90, &#39;X&#39;: 723, &#34;&#39;&#34;: 1269, &#39;Q&#39;: 666, &#39;;&#39;: 1108, &#39;Z&#39;: 215, &#39;(&#39;: 151, &#39;)&#39;: 151, &#39;&#34;&#39;: 5681, &#39;!&#39;: 955, &#39;?&#39;: 913, &#39;_&#39;: 182, &#39;É&#39;: 2, &#39;6&#39;: 9, &#39;5&#39;: 13, &#39;/&#39;: 24, &#39;%&#39;: 1, &#39;@&#39;: 2, &#39;$&#39;: 2}) .",
            "url": "/Kivy/jupyter/python/data%20science/2020/05/08/jupyter-python.html",
            "relUrl": "/jupyter/python/data%20science/2020/05/08/jupyter-python.html",
            "date": " • May 8, 2020"
        }
        
    
  
    
        ,"post6": {
            "title": "Fastpages Notebook 博客示例",
            "content": "&#31616;&#20171; . 以下内容演示fastpages处理notebook的能力 . 在你的fastpages代码仓库中，将jupyter notebook保存到_notebooks文件夹并提交到master分支，就可以借助GitHub的actions自己生成Jekyll博客啦！ . Front matter&#27169;&#26495;&#35774;&#32622; . Jupyter Notebook第一个单元格，或markdown文件的最前面需要配置metadata。示例如下： . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master- badges: true- comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . toc: true 自动生成目录 | badges: true 自动配置带徽章的GitHub、ninder和Google Colab链接 | comments: true 支持github issue评论，借助utterances实现 | . 如果标题中包含特殊字符（如冒号），可以用双引号括起来。关于Front matter的更多详情参考front matter section的README文件。 . Markdown&#24555;&#25463;&#26041;&#24335; . 在单元格上方加#hide，可以在博客中同时隐藏输入和输出 . 在单元格上方加#hide_input在博客中仅隐藏输入 . The comment #hide_input was used to hide the code that produced this. . 在单元格上方加#collapse-hide可以实现默认隐藏内容的控件，点击按钮可以显示： . #collapse-hide import pandas as pd import altair as alt . . 在单元格上方加#collapse-show可以实现默认显示内容的控件，点击按钮可以隐藏： . #collapse-show cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . &#19982;Altair&#20132;&#20114; . Altair支持交互图形，下面示例取自项目，都在这个notebook里面。 . &#31034;&#20363; 1: DropDown . # single-value selection over [Major_Genre, MPAA_Rating] pairs # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(movies).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . &#31034;&#20363; 2: Tooltips . alt.Chart(movies).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=alt.Y(&#39;IMDB_Rating:Q&#39;, axis=alt.Axis(minExtent=30)), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=600, height=400 ) . &#31034;&#20363; 3: More Tooltips . # select a point for which to provide details-on-demand label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=700, height=400 ) . &#34920;&#26684; . notebook代码生成表格可以直接在博客中显示： . movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; df = pd.read_json(movies) # display table with pandas df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . &#22270;&#20687; . &#26412;&#22320;&#22270;&#20687; . 可以引用本地图片，它们会被自动复制并在博客中渲染。可以用markdown实现： . ![](my_icons/fastai_logo.png) . . &#36828;&#31243;&#22270;&#29255; . 远程图片语法如下： . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Gif&#21160;&#30011; . Gif动画，当日没问题！ . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . &#22270;&#29255;&#35828;&#26126;&#65288;Caption&#65289; . 图片说明可以用下面markdown语法实现： . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . &#20854;&#20182;&#20803;&#32032; . GitHub Flavored Emojis . 输入 I give this post two :+1:! 渲染颜文字： . I give this post two :+1:! . Tweet&#21345;&#29255; . 输入 &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 渲染推文： Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube&#35270;&#39057; . 输入 &gt; youtube: https://youtu.be/XfoYk_Z5AkI 渲染视频： . &#25552;&#31034;&#25991;&#23383;&#65288;Boxes / Callouts &#65289; . 输入 &gt; Warning: There will be no second warning! 效果： . Warning: There will be no second warning! . 输入 &gt; Important: Pay attention! It&#39;s important. 效果： . Important: Pay attention! It&#8217;s important. . 输入 &gt; Tip: This is my tip. 效果： . Tip: This is my tip. . 输入 &gt; Note: Take note of this. 效果： . Note: Take note of this. . 输入 &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. 效果： . Note: A doc link to an example website: fast.ai should also work fine. . &#23614;&#27880; . 可以在notebook里加尾注，但不是用markdown语法实现，具体语法请看说明。 . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "/Kivy/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post7": {
            "title": "Kivy指南-9-射击app",
            "content": "前面提到过，在这一章我们来做射击（shoot-em-up，简写shmup）app，一个快节奏的射击游戏，比魂斗罗简单许多。 . . 做一个在屏幕上同时移动不同内容的游戏，需要大量的渲染来实现，在移动端（或多平台支持）也是如此。这一章我们就来做这些事情，上一章的知识和源代码已经带我们入了门。 . 教学大纲如下： . 用Kivy的纹理图集（Texture atlases）完成本来需要用底层代码实现的纹理坐标值的设置工作 | 继续用GLSL开发一个质点原型，然后用这个原型做不同的游戏角色 | 实现二维射击游戏的——一个控件，鼠标和触摸屏，基本冲突发现子弹 | . 后面会涉及到大量细节，如果看不明白就运行一下文末的源代码。 . &#39033;&#30446;&#30340;&#38480;&#21046; . 我们做的app比较简单，功能有限，至少有以下限制： . 为了简化，忽略了奖惩机制，2048里面也是这样 | 这个游戏只有一个敌人角色，简单模式 | 许多优化被忽略了，可以少写一些代码 | . 如果感兴趣可以自己做。下面我们来看一下Kivy的纹理处理相关内容，后面会用到。 . &#32441;&#29702;&#22270;&#38598;&#31616;&#20171; . 纹理图集（也叫sprite sheets）是一种应用开发中把图象组合成更大纹理的方法。与只是把一堆单个图象载入应用相比，这么做有些好处： . 应用打开更快，读一个大文件比读许多小文件要快。如果你有几百个这样的图片，用这种方法性能提升会很明显——网页上更是如此：图片太多会严重占用HTTP请求资源，在移动设备上这点更加明显 | 一次性渲染也会很更快。用纹理映射可以只改变需要变化的纹理坐标，而不需要引起其他内容的变化 | 当有一个大的模型时，像GLSL类的渲染，用纹理图集方法更适合。另外，纹理的坐标值更容易获取，也不需要二次绑定纹理 | . 在HTML和CSS里面常用类似的方法，叫CSS图片合并（CSS sprites）。原理是一样的。网页app通常是获取网络资源，如果大量图片存在会占用HTTP请求数，用CSS图片合并可以很好的降低HTTP请求占用。 . 这一章，我们要介绍以下内容： . 用Kivy的CLI工具创建纹理映射 | 文件格式化和.atlas文件结构 | Kivy应用纹理图集的用法 | . 如果你已经掌握了相关内容，可以直接跳到GLSL使用纹理图集一节。 . &#21019;&#24314;&#19968;&#20010;&#22270;&#38598; . 和网页开发不同，那里没有标准工具处理这个任务，Kivy框架用一个命令行工具处理图集映射。 . python –m kivy.atlas &lt;atlas_name&gt; &lt;texture_size&gt; &lt;images…&gt; . 在Mac系统上，把python替换成kivy，因为安装的时候Kivy.app会调用Python解释器。 . 这样会创建至少两个文件，由所有的图像是否满足一个设定大小的纹理来决定。本章假设texture_size的值足够包含所有图像。 . 所有输出文件都是atlas_name开头的参数： . 图集的索引称作&lt;atlas_name&gt;.atlas | 纹理有一个后缀&lt;atlas_name&gt;-0.png（这个文件总是存在的），&lt;atlas_name&gt;-1.png等等 | . &#22270;&#38598;&#32467;&#26500; . .atlas是JSON格式的文件，用来描述纹理映射的位置。 . { &quot;game-0.png&quot;: { &quot;player&quot;: [2, 170, 78, 84], &quot;bullet&quot;: [82, 184, 24, 16] } } . 纹理的名称就是其源文件的文件名，没有后缀，foo.png就是foo。后面的数值对应的是[x, y, width, height]，所有值都是像素。 . 组合纹理就是把一堆图片合并起来获得想要的内容，如下图所示。通常，为了利用空间会紧密排在一起。 . 创建图集的时候，Kivy谨慎会处理每个图集的边框，同时考虑图片可能因渲染后效果引起尺寸改变的情况。这就是为什么你需要为图片组合边距留出充分的像素。这样做效果并不可见，但是很有必要。 . . 在Kivy代码里面用图集的方法和http方式类似，atlas://后面跟图集的路径。如下所示： . Image: source: &#39;flags/Israel.png&#39; . Image: source: &#39;atlas://flags/Israel&#39; . Kivy&#20351;&#29992;&#22270;&#38598;&#30340;&#31616;&#26131;&#26041;&#27861; . 要演示上面的方法，我们用前面用过的图标icon_clock.png和icon_paint.png来试试： . . 要创建图集，我们用下面的命令： . kivy -m kivy.atlas icons 512 icon_clock.png icon_paint.png . 如果不是Mac系统，用python命令。运行之后会出现如下提示： . [INFO] Kivy v1.9.1 [INFO] [Atlas] create an 512x512 rgba image (&#39;Atlas created at&#39;, &#39;icons.atlas&#39;) 1 image have been created . 之后就会出现两个文件icons.atlas和icons-0.png。 . 现在可以删除源图片文件。不过最好还是保留，有可能后面更新图集的时候还会用到。 . 图集准备好以后，我们来做一个简单的app。basic.py文件代码如下： . from kivy.app import App class BasicApp(App): pass if __name__ == &quot;__main__&quot;: BasicApp().run() . 在basic.kv文件里面加载布局很简单： . BoxLayout: orientation: &#39;horizontal&#39; Image: source: &#39;atlas://icons/icon_clock&#39; Image: source: &#39;atlas://icons/icon_paint&#39; . 运行代码，效果如下图所示： . . &#22312;GLSL&#20195;&#30721;&#20351;&#29992;&#22270;&#38598; . Kivy对图集的支持非常简单，但是GLSL应用里面没这么容易。好在.atlas是JSON格式，所以我们可以用Python的json模块来处理。然后，我们可以将像素坐标值转换成OpenGL的UV坐标值。 . 由于我们知道每个纹理的绝对尺寸，我们可以计算出每个图片组合的顶点与中心的相对位置。这样就可以实现对图集按照其原始形式进行渲染，保持等比例变化。 . UV&#26144;&#23556;&#30340;&#25968;&#25454;&#32467;&#26500; . 每个图集都有很多数据，为了方便管理数据，我们需要一个数据结构： . from collections import namedtuple UVMapping = namedtuple(&quot;UVMapping&quot;, &quot;u0 v0 u1 v1 su sv&quot;) . 这个数据类型和C语言的结构体类似，和下面的代码差不多： . class UVMapping: def __init__(self, u0, v0, u1, v1, su, sv): self.u0 = u0 # top left corner self.v0 = v0 # self.u1 = u1 # bottom right corner self.v1 = v1 # self.su = su # equals to 0.5 * width self.sv = sv # equals to 0.5 * height . 注意，这些代码只是演示命名数组的原理，并不是完全相同。每个属性的定义如下： . 属性 定义 . u0, v0 | 图集左上角的UV坐标 | . u1, v1 | 图集右下角的UV坐标 | . su | 图集宽度一半，在建立顶点数组的时候用 | . sv | 图集高度一半，在建立顶点数组的时候用 | . 这样做让代码可读性更好，原来的tup[3]就可以用tup.v1表示。同时，UVMapping是元组类型，一种不可变的、内存结构合理的数据结构，可以通过索引连接所有属性。 . &#22270;&#38598;&#21152;&#36733;&#22120; . 现在，让我们写一个函数来描述图集加载的过程，包括处理JSON，确定坐标值等等。这个函数在程序的最后使用： . import json from kivy.core.image import Image def load_atlas(atlas_name): with open(atlas_name, &quot;rb&quot;) as f: atlas = json.loads(f.read().decode(&quot;utf-8&quot;)) tex_name, mapping = atlas.popitem() tex = Image(tex_name).texture tex_width, tex_height = tex.size uvmap = {} for name, val in mapping.items(): x0, y0, w, h = val x1, y1 = x0 + w, y0 + h uvmap[name] = UVMapping( x0 / tex_width, 1 - y1 / tex_height, x1 / tex_width, 1 - y0 / tex_height, 0.5 * w, 0.5 * h, ) return tex, uvmap . 记住我们现在处理的是最简单的情况：一个图集由一个纹理构成。这也可能是最有效的配置方式，所以这个限制应该不会影响我们的代码，尤其是因为图集的生成完全在我们控制之下。 . 因为坐标值是通过Kivy的坐标系统实现的，所有我们需要把纵坐标调整一下，用OpenGL的左上角为原点的坐标系统。否则，图集就会颠倒（不过，在我们的小游戏里面这不是什么大问题。这种bug可能要在代码里长期存在，虽然没被注意到，也没什么大碍）。 . load_atlas(&#39;icons.atlas&#39;)函数返回的是icons-0.png加载的纹理，和图集里每个纹理的UV描述，类似下面的结果： . &gt;&gt;&gt; load_atlas(&#39;icons.atlas&#39;) (&lt;Texture size=(512, 512)...&gt;, {&#39;icon_paint&#39;:UVMapping(u0=0.2578125, v0=0.00390625, u1=0.5078125, v1=0.25390625, su=64.0, sv=64.0), &#39;icon_clock&#39;: UVMapping(...)}) . 有了这个数据格式，我们就可以从纹理中挑出每个合并图形然后渲染到屏幕上，下面就来实现。 . &#20174;&#22270;&#38598;&#20013;&#28210;&#26579;&#21512;&#24182;&#22270;&#24418; . 把上面的内容放到一起，我们用类似前面的GLSL纹理映射例子来实现一个新版本。 . 这里的tex_atlas.py文件与上一章的内容类似。通过load_atlas()函数来生成订单数组： . from kivy.graphics import Mesh from kivy.graphics.instructions import RenderContext from kivy.uix.widget import Widget # ...... class GlslDemo(Widget): def __init__(self, **kwargs): Widget.__init__(self, **kwargs) self.canvas = RenderContext(use_parent_projection=True) self.canvas.shader.source = &quot;tex_atlas.glsl&quot; fmt = ( (b&quot;vCenter&quot;, 2, &quot;float&quot;), (b&quot;vPosition&quot;, 2, &quot;float&quot;), (b&quot;vTexCoords0&quot;, 2, &quot;float&quot;), ) texture, uvmap = load_atlas(&quot;icons.atlas&quot;) a = uvmap[&quot;icon_clock&quot;] vertices = ( 128, 128, -a.su, -a.sv, a.u0, a.v1, 128, 128, a.su, -a.sv, a.u1, a.v1, 128, 128, a.su, a.sv, a.u1, a.v0, 128, 128, -a.su, a.sv, a.u0, a.v0, ) indices = (0, 1, 2, 2, 3, 0) b = uvmap[&quot;icon_paint&quot;] vertices += ( 256, 256, -b.su, -b.sv, b.u0, b.v1, 256, 256, b.su, -b.sv, b.u1, b.v1, 256, 256, b.su, b.sv, b.u1, b.v0, 256, 256, -b.su, b.sv, b.u0, b.v0, ) indices += (4, 5, 6, 6, 7, 4) with self.canvas: Mesh( fmt=fmt, mode=&quot;triangles&quot;, vertices=vertices, indices=indices, texture=texture, ) . 这点代码除了通常的GLSL初始化过程，就是把load_atlas()结果复制到vertices数组。我们选了两个不同的记录：icon_clock（用变量a表示）和icon_paint（用变量b表示），然后把它们放到顶点数组里。 . 顶点数据格式包含以下内容： . vCenter：这是合并图片在屏幕上的位置，应该和指定合并图片的所有顶点有相同的值 | vPosition：顶点与合并图片中心的相对位置，与vCenter无关 | vTexCoords0：每个顶点的UV坐标值，决定纹理要渲染的部分 | . 只有合并图片的位置（数组的前两个数值）不能从UV映射关系中找到，其他数值都可以从load_atlas()获得。 . tex_atlas.glsl相关文件着色器代码如下： . vertex $HEADER$ attribute vec2 vCenter; void main(void) { tex_coord0 = vTexCoords0; mat4 move_mat = mat4 (1.0, 0.0, 0.0, vCenter.x, 0.0, 1.0, 0.0, vCenter.y, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0); vec4 pos = vec4(vPosition.xy, 0.0, 1.0) * move_mat; gl_Position = projection_mat * modelview_mat * pos; } fragment $HEADER$ void main(void) { gl_FragColor = texture2D(texture0, tex_coord0); } . 这里只有最简单的功能——定位和显示纹理。类似的着色器可以用在游戏最后，那时将增加一个控制相对大小的属性，vScale。 . 如果你不理解这段代码，请看看上一章的内容。 . 最后运行程序的效果如下图所示： . . 下面，我们来开发一个粒子系统作为整个游戏其他对象的基础。 . &#35774;&#35745;&#37325;&#29992;&#31890;&#23376;&#31995;&#32479; . 当我们有很多类似的对象时，写一个具有简单功能的粒子系统是通用的做法。后面我们的飞船、子弹等等都用这个粒子系统来扩展。 . 其实，上一章的屏保程序整个就是一个很好的粒子系统，不过还缺少一个配置能力，也不能轻易重用。因此，这里我们要改变这些GLSL代码。 . 值得一提的是，这里用的方法——每个粒子的四周用纹理渲染——并非底层渲染的最佳方案。但是，这么做非常直截了当，容易理解，而且与任何支持GLSL语言OpenGL的实现兼容。 . 如果你打算更系统的学习OpenGL，你可能会用把纹理的四周渲染改为点渲染，或者类似的概念，这已经超出的本书的范围。 . &#31867;&#32487;&#32493;&#20851;&#31995; . 粒子系统的API由两个类构成：PSWidget执行渲染，Particle类表示每个粒子。 . 这两个类将与设计紧密耦合，在通常的OOP理论中这么做很有问题，但是可以改善我们app的性能：粒子可以直接连接渲染模块的顶点数组，来改变mesh网格——复制次数更少，考虑到需要同时处理很多粒子，这么做可以大大提升性能。 . 粒子系统部件的实现和GLSL部件没什么不同，除了现在它是一个子类。PSWidget和Particle类都是抽象基类，也就是说，它们不能直接通过调用PSWidget()来实例化。 . 增强这个现在有很多不同的方法。我们可以用Python标准模块abc来创建true抽象类（abc其实就是抽象类）。虽然这对Java程序员很有用，但是对Python程序员来说并不常用。 . 为了简化，我们为所有需要改写的方法添加NotImplementedError异常处理。这使得基类没有元类和复杂的继承关系就不能使用，就像abc模块说明的那样。 . PSWidget&#28210;&#26579;&#31867; . 下面是PSWidget类代码： . class PSWidget(Widget): indices = [] vertices = [] particles = [] def __init__(self, **kwargs): Widget.__init__(self, **kwargs) self.canvas = RenderContext(use_parent_projection=True) self.canvas.shader.source = self.glsl self.vfmt = ( (b&quot;vCenter&quot;, 2, &quot;float&quot;), (b&quot;vScale&quot;, 1, &quot;float&quot;), (b&quot;vPosition&quot;, 2, &quot;float&quot;), (b&quot;vTexCoords0&quot;, 2, &quot;float&quot;), ) self.vsize = sum(attr[1] for attr in self.vfmt) self.texture, self.uvmap = load_atlas(self.atlas) . 这和前面的GLSL初始化类似，有一些属性尚未定义。self.glsl属性将加载着色器的文件名，self.atlas是纹理映射的文件名，被当作是纹理为渲染实例提供的唯一来源。 . 这么我们还没有生成顶点数组：这件事留给子类去做。但是，我们应该提供一个简单的方式为派生类处理内部数据结构。因此，make_particles方法可以容易的加入大量类似粒子： . def make_particles(self, Cls, num): count = len(self.particles) uv = self.uvmap[Cls.tex_name] for i in range(count, count + num): j = 4 * i self.indices.extend((j, j + 1, j + 2, j + 2, j + 3, j)) self.vertices.extend( ( 0, 0, 1, -uv.su, -uv.sv, uv.u0, uv.v1, 0, 0, 1, uv.su, -uv.sv, uv.u1, uv.v1, 0, 0, 1, uv.su, uv.sv, uv.u1, uv.v0, 0, 0, 1, -uv.su, uv.sv, uv.u0, uv.v0, ) ) p = Cls(self, i) self.particles.append(p) . 这Cls类的质点数量（num），把它们增加到部件的self.particles列表，然后同时生成self.vertices。每个粒子类型应该显示一个tex_name属性，用来在UV映射中查找出正确的合并图片，这个数据结构由前面的图集（PSWidget.uvmap）派生出来。 . 其实，这个辅助函数是可选的，但是很有用。部件的具体类的在渲染之前的初始化阶段调用这个函数。 . 这个部件基类的最后部分就是渲染函数： . def update_glsl(self, nap): for p in self.particles: p.advance(nap) p.update() self.canvas.clear() with self.canvas: Mesh( fmt=self.vfmt, mode=&quot;triangles&quot;, indices=self.indices, vertices=self.vertices, texture=self.texture, ) . 从canvas.clear()调用开始的代码和前面的GLSL例子类似。前面这段代码是在迭代所有粒子时调用两个方法：advance()方法计算粒子的新状态（由粒子决定），update()保持顶点数组中必要的数据的同步。 . 这里主要是为了代码的可读性，并没有过多考虑性能，如果需要优化性能，有如下建议： . 循环部分可以并行处理 | 代码还可以完全用另一个线程，不用每一帧都升级（优化可能应用到粒子选择的类，比如，不影响主程序背景色的填充物） | . 这个方法更多的实现细节会在后面介绍。 . Particle&#31867; . 下面的代码就是Particle类，表示每个合并图片。源自满天星app的Star类，没有运动部分（后面的子类会实现）： . class Particle: x = 0 y = 0 size = 1 def __init__(self, parent, i): self.parent = parent self.vsize = parent.vsize self.base_i = 4 * i * self.vsize self.reset(created=True) def update(self): for i in range(self.base_i, self.base_i + 4 * self.vsize, self.vsize): self.parent.vertices[i : i + 3] = (self.x, self.y, self.size) def reset(self, created=False): raise NotImplementedError() def advance(self, nap): raise NotImplementedError() . self.parent保存一个引用到父类PSWidget中，方便后面的信息交互。前面也出现过的update()方法，让多边形四个顶点的变化与粒子位置和比例保持同步（x，y和size属性）。 . 这里还有一个方法没有出现在Star里面，就是advance()，它应该被改写，因为没有为屏幕改变设置默认的动作，完全由粒子决定如何变化。后面你会看到，粒子系统可以用来创建不同的效果。 . reset()方法是在粒子的生命周期的最后重新初始化粒子（比如，已经离开屏幕或用完TTL的粒子）。虽然这里都是粒子系统，但是任何系统都会有一些要被恢复到原始状态的粒子。另外，这里也没有设置默认的行为让我们调用，所有这个函数什么也没有。 . 从一个虚拟方法触发NotImplementedError错误是提醒开发者，可以在派生类里定义该方法的内容。我们也可以忽略后面两个方法，但是这样做有可能引发AttributeError错误。保留方法的定义，即使没有实现，也是很好的做法，可以减少其他开发者的猜测（或者过段时间再看代码的时候，会感觉一头雾水，不知道自己怎么写的）。 . reset()方法里面的created参数。一些粒子系统在第一次生成的时候可能需要额外的（或不同的）初始化过程。前面也有过类似的情况，如满天星app里面，星星在屏幕的右手边生成。如果我们不考虑已生成状态，所有的星星都会出现的屏幕的最右侧，而且有同样的横坐标x，看起来就是一条直线。这样的结果肯定不是我们想要的，所以我们让通过将created变量设置成True使得星星的位置完全随机，这样就会看到漂亮的初始分布了。 . 调用reset()方法意味着后面重生的粒子会比第一次生成的多很多，所以把created变量设置成False。 . 现在基类的工作都完成了。后面你会看到，游戏的实现会变得很简单。下面我们就用粒子系统来创建游戏的角色。 . &#21046;&#20316;&#28216;&#25103; . 我们的app将用前面做好的模块来构建：根部件是PSWidget的子类叫Game，所有的游戏角色都由粒子系统Particle类派生出来。 . from kivy.base import EventLoop from kivy.clock import Clock class Game(PSWidget): glsl = &quot;game.glsl&quot; atlas = &quot;game.atlas&quot; def initialize(self): pass class GameApp(App): def build(self): EventLoop.ensure_window() return Game() def on_start(self): self.root.initialize() Clock.schedule_interval(self.root.update_glsl, 60 ** -1) . 这里用的两个文件解释如下： . game.glsl着色器和starfield.glsl是一样的 | game.atlas纹理映射包含下列纹理： star：和上一章的星星一样 | player：朝向右边的飞船 | trail：飞船发射的火球 | bullet：飞船发射的炮弹 | ufo：外星人朝向左边 | . | . 上面的代码还没有在屏幕上显示出来，因为我们还没有生成顶点数组，下面我们来实现它们。 . &#23454;&#29616;&#26143;&#26143; . 现在我再建一个简单的星空。这次它从右向左运动，和前面的Kivy Bird游戏一样。 . 要创建一个简单的平行视差效果，我们把星星分成三个平面，然后让它们有不同的速度。一个平面上的星星比较多也比较大，快速移动，另一个比较少慢速移动。一旦星星飞出屏幕就在左边的随机位置重生。 . 下面我们来实现： . from random import randint, random class Star(Particle): plane = 1 tex_name = &quot;star&quot; def reset(self, created=False): self.plane = randint(1, 3) if created: self.x = random() * self.parent.width else: self.x = self.parent.width self.y = random() * self.parent.height self.size = 0.1 * self.plane def advance(self, nap): self.x -= 20 * self.plane * nap if self.x &lt; 0: self.reset() . tex_name是必须有的，引用game.atlas里面的纹理。 . 随机生成一个星星的位置和所属的平面，无论初始化（created=True）是否被调用。 . advance()方法就是一旦星星飞出屏幕就重生。 . 为了使用粒子系统，我们需要用PSWidget类的make_particles()方法来增加一些星星。在Game.initialize()里面： . def initialize(self): self.make_particles(Star, 200) . 下面就可以看到效果图： . . &#23454;&#29616;&#23431;&#23449;&#39134;&#33337; . 我们只需要一个宇宙飞船（单人模式），用一个粒子就可以实现了。这么做是为了和后面的代码统一，这个对象的构建和其他对象没什么区别。 . 飞船一直粘在鼠标位置，要实现这个效果，我们把鼠标的位置储存到Game属性里，用player_x和player_y来表示，然后把飞船图片加载到里面。代码如下所示： . from kivy.core.window import Window class Game(PSWidget): def update_glsl(self, nap): self.player_x, self.player_y = Window.mouse_pos PSWidget.update_glsl(self, nap) . 由于飞船实在用户的控制之下，没有其他逻辑要实现，只要把图片移动到鼠标位置就可以了： . class Player(Particle): tex_name = &quot;player&quot; def reset(self, created=False): self.x = self.parent.player_x self.y = self.parent.player_y advance = reset . 你会发现reset()和advance()方法是一样的。还有飞船的初始化： . def initialize(self): self.make_particles(Star, 200) self.make_particles(Player, 1) . 下面就是效果图： . . &#23454;&#29616;&#39134;&#33337;&#30340;&#23614;&#24052;&#25110;&#28779;&#28976; . 科幻小说里面的飞船都跟着一个尾巴。这个尾巴用下面的算法实现： . 粒子在引擎附件生成，尺寸是随机的。粒子的尺寸也是它的存活时间（time to live，TTL） | 它以一个恒定的速度飞离飞船，尺寸不断减小 | 最终粒子的尺寸会比原来小10% | 当有很多粒子来时，这个效果会很好看。不过截屏是看不出来了，你可以运行一下代码试试。代码如下所示： . class Trail(Particle): tex_name = &quot;trail&quot; def reset(self, created=False): self.x = self.parent.player_x + randint(-30, -20) self.y = self.parent.player_y + randint(-10, 10) if created: self.size = 0 else: self.size = random() + 0.6 def advance(self, nap): self.size -= nap if self.size &lt;= 0.1: self.reset() else: self.x -= 120 * nap . 其实现方式很简单，用同样的player_x和player_y属性来决定飞船的位置。在初始化阶段，添加许多粒子来实现效果： . def initialize(self): self.make_particles(Star, 200) self.make_particles(Trail, 200) self.make_particles(Player, 1) . 截图效果如下所示： . . 还有敌人和子弹两个粒子系统没有实现。和前面看到的角色不同，它们都是在某个时间立刻出现，而敌人和子弹不是立刻出现的，两者都需要等一个特定的事件发生，然后逐渐增加数量，发射一颗子弹或者生成一个敌人。 . 但是，之前我们需要分配固定数量的粒子，因为顶点数组的增减会让代码变得复杂，这不是我们想要的。 . 方法是给粒子增加一个新的布尔变量属性，决定粒子是否属于激活状态，然后激活需要的粒子。这个方法后面会提到。 . &#23454;&#29616;&#23376;&#24377; . 我们想让飞船的大炮在我们单击鼠标或触摸屏幕的时候能够发射子弹。用firing属性就可以实现： . class Game(PSWidget): firing = False fire_delay = 0 def on_touch_down(self, touch): self.firing = True self.fire_delay = 0 def on_touch_up(self, touch): self.firing = False . 要在两次射击之间增加延迟，我们引入一个变量fire_delay。这个变量会按帧递减到0，然后一个新的子弹生成，fire_delay开始增大。在firing变量为True的时候循环： . def update_glsl(self, nap): self.player_x, self.player_y = Window.mouse_pos if self.firing: self.fire_delay -= nap PSWidget.update_glsl(self, nap) . 现在，让我们看看这个粒子的状态。开始的时候，所有的子弹都没激活（active=False），移出屏幕（坐标值x=-100, y=-100设置子弹位置，可以在渲染的时候不让它们出现）。代码如下： . class Bullet(Particle): active = False tex_name = &quot;bullet&quot; def reset(self, created=False): self.active = False self.x = -100 self.y = -100 . 当遍历所有子弹之后，我们跳过那些没激活的子弹，保留firing_delay不是0的子弹。这时，我们激活一个子弹，然后把它放到玩家面前，启动firing_delay变量到倒计时。 . 激活的子弹想星星一样移动，与星星方向相反。不像星星，子弹飞出屏幕后不会重生。它们回到不激活状态，从屏幕上消失。代码如下： . def advance(self, nap): if self.active: self.x += 250 * nap if self.x &gt; self.parent.width: self.reset() elif self.parent.firing and self.parent.fire_delay &lt;= 0: self.active = True self.x = self.parent.player_x + 40 self.y = self.parent.player_y self.parent.fire_delay += 0.3333 . fire_delay属性设置为1/3秒，子弹发射的频率是每秒三发（3 rounds per second，RPS）。效果如下图所示： . . &#23454;&#29616;&#25932;&#20154; . 敌人的概念和子弹类似，但是它们是连续出现的，我们不需要firing这样的标记，用一个spawn_delay就够了。代码实现如下： . class Game(PSWidget): spawn_delay = 1 def update_glsl(self, nap): self.player_x, self.player_y = Window.mouse_pos if self.firing: self.fire_delay -= nap self.spawn_delay -= nap PSWidget.update_glsl(self, nap) . 在初始化阶段，我们创建了一个预定义数量的敌人，开始不激活。为了实现后面对子弹的碰撞检测，我们需要存储一个子弹列表（Game.particles）： . def initialize(self): self.make_particles(Star, 200) self.make_particles(Trail, 200) self.make_particles(Player, 1) self.make_particles(Enemy, 25) self.make_particles(Bullet, 25) self.bullets = self.particles[-25:] . 这些代码看着很复杂，因为这里涉及到很多不同的运动状态。为了固定x方向的速度，每个敌人还带一个随机垂直运动矢量v。当这样的粒子从屏幕边上的顶部到底部离开屏幕时，粒子的v属性不断改变，在屏幕上看到的是敌人又回到屏幕的效果。 . 其他的规则与子弹类似：当敌人到达屏幕的底部，它重置然后消失再重生。代码如下： . class Enemy(Particle): active = False tex_name = &quot;ufo&quot; v = 0 def reset(self, created=False): self.active = False self.x = -100 self.y = -100 self.v = 0 def advance(self, nap): if self.active: if self.check_hit(): snd_hit.play() self.reset() return self.x -= 200 * nap if self.x &lt; -50: self.reset() return self.y += self.v * nap if self.y &lt;= 0: self.v = abs(self.v) elif self.y &gt;= self.parent.height: self.v = -abs(self.v) elif self.parent.spawn_delay &lt;= 0: self.active = True self.x = self.parent.width + 50 self.y = self.parent.height * random() self.v = randint(-100, 100) self.parent.spawn_delay += 1 . 这段代码的设计思路很简单： . 检查是否被一个子弹击中，或者要重置 | 水平移动，检查是否离开了屏幕，然后重置 | 垂直移动，检查是否离开了屏幕，改变速度矢量 | 如果spawn_delay已经到0，就重生一个敌人，然后启动spawn_delay | &#30896;&#25758;&#26816;&#27979; . 我们还没实现的Enemy类的另一个有趣功能是check_hit()方法。有两种情况敌人会撞到：飞船和子弹。为了简化，我们设定玩家是无敌的，敌人碰到任何物体都会被消灭： . def check_hit(self): if math.hypot(self.parent.player_x - self.x, self.parent.player_y - self.y) &lt; 60: return True for b in self.parent.bullets: if not b.active: continue if math.hypot(b.x - self.x, b.y - self.y) &lt; 30: b.reset() return True . math.hypot()是计算两物体中心距离，我们假设所有的物体都以这个方法监测。不能用没激活的子弹碰撞（if not b.active），因为没激活的子弹在屏幕上是看不到的。因此，它们不会在屏幕上撞击任何物体。 . 这样游戏就完成了。 . . &#25913;&#21892;&#21151;&#33021; . 游戏有很多地方可以改进，尤其是游戏玩法上。当然这只是一个原型，不是商品，可以慢慢改进。 . 如果你感兴趣，下面的建议留给你完成： . 游戏需要一个“Game Over”状态。胜利的状态不一定有，失败必须有，和上一章的类似 | 增加角色，实现多种敌人，更多攻击的方式，也可以让敌人攻击飞船，增加关卡的难度，照着街机雷电游戏去做就行 | 增加声音效果，可以仿照Kivy Bird那一章的内容。MultiAudio类也可以重用 | . &#24635;&#32467; . 这章的重点是用粒子系统来实现不同的游戏角色。这可能不是你了解的最好方法，但还是让我们把细节放下，来总结一下整本书的重点。 . 一路走来，我们基本上学完了Python和Kivy游戏开发的过程，能胜任的领域很多： . 桌面和移动应用开发 | 文字、图像、声音合成内容等应用的开发 | 网络聊天应用的开发，以及社交网络，远程控制等程序 | 视频游戏开发 | . 通过这本书，我们还为如何有效使用新技术提供了一些基本原则： . 把其他领域的经验迁移过来。Kivy虽然不一样，但并非完全不同，很多其他领域的方法都可以在这里重用 | 努力探索实现的过程。理解框架工作的内部原理可以为调试提供极大帮助。 | 如果文档缺失，请读源代码。毕竟，它是Python。 | 遇到问题请用搜索引擎。你遇到的问题别人也遇到过。 | . 总之，我们衷心希望你能喜欢这次旅程。 .",
            "url": "/Kivy/jupyter/kivy/android/ios/2019/10/01/kivy-ch9-shmup-app.html",
            "relUrl": "/jupyter/kivy/android/ios/2019/10/01/kivy-ch9-shmup-app.html",
            "date": " • Oct 1, 2019"
        }
        
    
  
    
        ,"post8": {
            "title": "Kivy指南-8-着色器app",
            "content": "恭喜你Hold到现在！最后两章我们准备讨论一些OpenGL的底层细节，与Kivy完全不同的内容，比如OpenGL着色器语言（OpenGL Shading Language，GLSL）。这个语言可以让我们轻松写出高性能的代码。 . 我们将通过一个屏幕保护程序来介绍OpenGL的特性，然后做一个射击游戏（shoot-em-up game，shmup）app。本章的代码是准备工作，和其他项目都是一章不同，射击游戏在下一章做。 . 本章会讨论很多复杂的问题，不过由于篇幅不能面面俱到，建议阅读OpenGL最新文档，因为OpenGL是一个标准，更新很快，新特性不断被加入，希望你在阅读的时候及时留意OpenGL相关的进展。 . 首先要讨论的是高性能着色器方法，尽管和普通的Kivy代码差别不大，而且两者大部分都相互兼容，在很多部件中都可以互相替代。因此，这种方法主要是用GLSL实现于资源消耗很大、性能要求很高的部分，消除性能的瓶颈。 . OpenGL&#31616;&#20171; . 现在让我们简单介绍下OpenGL。OpenGL是一个底层的图像API，其标准被广泛采用。桌面系统和移动系统均支持（在移动系统上是OpenGL ES，Embedded Systems，嵌入式系统）。现代浏览器也支持OpenGL ES的一个分支版本，就是大名鼎鼎的WebGL。 . OpenGL的广泛采用使其具有良好的跨平台能力，尤其在视频游戏和图形编程方面。Kivy的跨平台着色器同样依赖于OpenGL。 . &#24182;&#34892;&#26041;&#24335; . OpenGL可以操纵基本的图形元素，如单个的点和屏幕上的每个像素。我们可以画三个点，然后构成一个三角形，计算每个像素的应该填充的颜色。你可能认为这种做法是非常麻烦的。这正是像kivy这样的高级图形框架出现的原因：它们都隐藏了OpenGL的管线（pipeline）的一堆细节，提供组件和布局来简化操作。复杂底层的管线功能如下图所示： . . 这个复杂的图形包括以下四个方面： . 应用给OpenGL一个点数组（vertices），可以重用这些点的索引数组（indices），以及其他数值（uniforms） | 对每个点进行点着色器（vertex shader），根据需要做一系列计算。然后输出到片段着色器（fragment shader） | 对每个像素进行分段着色器（也叫像素着色器，pixel shader），计算像素的颜色。有时除了点着色器的输出结果，还要考虑一个颜色常量 | 像素被着色器到屏幕上，其他的一些任务被完成，这些任务我们暂不讨论 | . 上面使用的一组点称为模型（model）或网格（mesh）。它们不一定是连续的，也可能是离散的多边形；这些模型的理论基础后面会介绍。 . OpenGL超快速度的背后是大量并行计算方法的使用。上面提到的点着色器和像素着色器可能不会自动飞快运行，但是当通过GPU加速的瞬间，着色器造成的延迟并不会随着着色复杂度的增加呈指数级增长；在正常的硬件上其增速基本是线性的。 . 对应到现实中，我们讨论的，就是今天用2-16核CPU的电脑进行多任务、并行编程的个人电脑。一般的中档显卡，也有几千个GPU核心，可以并行处理更多的计算。 . 每个任务都是独立运行的，不像一般程序里面的线程，着色器不能等待其他任务完成再运行，这样会出现阻塞且严重影响性能，除了使用管线命令的时候（就像前面提到的，先进行点着色器，再运行像素着色器）。这种限制在你刚刚接触GLSL的时候，可能有点难理解。 . 这就是为什么有些算法可以在GPU上面非常高效。现代加密算法像bcrypt就是用来限制这种高并发性能的——通过限制暴力破解能力来保障安全性。 . &#24615;&#33021;&#24471;&#22833; . 并非只有原始的OpenGL才可以获得极快的性能。很多时候，像Kivy这样的高级框架也可以如此。比如，当你在屏幕上着色器多边形的时候，下面的一系列动作就会发生： . 用python定义多边形的形状和位置 | 点，索引数组和相关的资源（如花纹）都上传到图像接口 | 调用点着色器功能，进行定位、着色、缩放等变换 | 最后，调用像素着色器功能，返回一个栅格图像显示到屏幕上 | . 无论你是要Kivy部件还是用原始的OpenGL命令和GLSL着色器，两种方式的性能都是一样的。这是因为Kivy底层和OpenGL类似。 . 也就是说，底层优化其实没多大必要，这就是由几个矩形构成的Kivy Bird游戏，可以直接通过高级接口实现的原因。基本上，我们可以在Kivy Bird里优化一两个部件，但是其性能很难被察觉。 . &#25913;&#21892;&#24615;&#33021; . 那么，性能到底如何改善呢？答案就是减少Python代码，精简着色器内容。假如我们要着色9,000个相似的多边形（比如秋天的落叶或漫天的行程）。如果每个多边形都用一个Kivy部件，那我们就要做很多个Python对象，要被单独序列化成OpenGL指令。另外，每个部件都有点集合相关的图像接口，必然产生大量的API调用，还有许多类似的匹配（mesh）。 . 我们可以做两件事来优化： . 避免大量Python类实例，把它们放在一个数值中即可。如果储存成一个适合OpenGL处理的格式中，就可以免掉序列化的步骤 | 把所有的图形组合到一起作为一个单独模型处理，这样可以减少API调用。批处理通常是很好的优化方法，因为它让OpenGL以并行方式更好的运行。 | . 在本章结束的时候我们会实现这些方法。 . GLSL&#20171;&#32461; . GLSL作为一门语言，与C语法类似，是一个静态强类型。如果你不熟悉C语言，下面是参考。C与Python不同，不在乎缩进，句末要用分号，逻辑代码块要用括号。 . GLSL同时支持C和C++的注释方式： . /* ANSI C-style comment */ // C++ one-line comment . 变量声明方式为[type] [name] [= optional value];： . float a; // this has no direct Python equivalent int b = 1; . 函数定义方式为[type] [name] ([arguments]) { [body of function] }： . float pow2(float x) { return x * x; } . 控制结构形式为： . if (x &lt; 9.0) { x = 9.0; } . 差不多就这些了，即使没有学过C，你现在也可以读GLSL代码了。 . 着色器代码的起点是main()函数。后面，我们把点着色器和像素着色器放在一个文件中，因此，在一个文件里面会有两个main()函数。其结构如下： . void main(void) { // code } . 这里的void类型表示函数没有返回值，和Python的NoneType不一样，你不能把变量声明为void类型。这里的两个main()函数返回值和参数都被忽略了，所以写成void main(void)。着色器会根据需要把结果写到内部变量，gl_Position，gl_FragColor和其他变量里面，不需要返回数据结果，输入参数为空也是同理。 . GLSL类型系统完全反映了它的作用。不像C语言，它为点和矩阵准备了专门的类型，这些类型支持数学运算（所以你可以直接对矩阵变量进行乘法mat1 * mat2，多简单啊！C一个试试就知道C多麻烦了）。在计算机图形学里，矩阵计算不可或缺，后面会介绍。 . 下面，我们就来写几个GLSL的例子。 . &#22312;Kivy&#20013;&#33258;&#23450;&#20041;&#30528;&#33394;&#22120; . 首先我们需要用Python代码实现窗口、加载着色器等等。代码如下： . from kivy.app import App from kivy.base import EventLoop from kivy.graphics import Mesh from kivy.graphics.instructions import RenderContext from kivy.uix.widget import Widget class GlslDemo(Widget): def __init__(self, **kwargs): Widget.__init__(self, **kwargs) self.canvas = RenderContext(use_parent_projection=True) self.canvas.shader.source = &quot;basic.glsl&quot; # Set up geometry here. class GlslApp(App): def build(self): EventLoop.ensure_window() return GlslDemo() if __name__ == &quot;__main__&quot;: GlslApp().run() . 这么我们创建了一个部件GlslDemo；用来管理所有的渲染。RenderContext是Canvas的子类用来轻松替换着色器。basic.glsl文件包含点着色器和像素着色器，后面会实现。 . 注意我们没用Kivy语言，因为没有布局要使用，所以这里不是glsl.kv文件，我们通过GlslApp.build()方法配置根部件。 . EventLoop.ensure_window()是必须的，因为我们需要接入OpenGL特性，包括在运行GlslDemo.__init__()方法时，调用GLSL编译器。如果此时没有应用窗口（更重要的是，没有相关的OpenGL内容），程序就会崩溃。 . &#24314;&#31435;&#20960;&#20309;&#22270;&#24418; . 写着色器之前，我们还需要渲染一些东西——一系列点模型。我们用两个等斜边的直角三角形构成一个简单的矩形（这么分是因为基本多边形是三角形）。 . Kivy更偏向于二维图形，所以在二维设计中不会强加任何限制。而OpenGL是源自三维图形，所以你可以用生动的模型来创建视频游戏，也可以结合Kivy的部件来创建UI。本书不做介绍，但是两者底层的机制是一样的。 . 这里需要升级GlslDemo部件里的__init__()方法： . def __init__(self, **kwargs): Widget.__init__(self, **kwargs) self.canvas = RenderContext(use_parent_projection=True) self.canvas.shader.source = &quot;basic.glsl&quot; fmt = ((b&quot;vPosition&quot;, 2, &quot;float&quot;),) # Step 1 vertices = ( # Step 2 0, 0, 255, 0, 255, 255, 0, 255, ) indices = (0, 1, 2, 2, 3, 0) # Step 3 with self.canvas: Mesh(fmt=fmt, mode=&quot;triangles&quot;, indices=indices, vertices=vertices) # Step 4 . 方法解释如下： . 写OpenGL代码时需要注意点对象没有标准的格式，因此，我们需要定义一个。简单的做法就是用点的位置vPosition。我们的矩形是二维的，因此我们就传递两个坐标，默认是浮点型数值。因此，定义是(b&#39;vPosition&#39;, 2, &#39;float&#39;) | 确定了点的格式之后，我们把这些点放到一个数组里，如vertices = (...)行所示。这个元组只有一层，后面会单独定义记录的格式，然后再把所有值聚合在一起，没有用分隔符或其他类似好记的名称。这是C语言结构体的经典方式 | 索引数组用来复用那些顶点。通常，一个顶点被多个三角形同时使用。我们使用索引数组里的index来重复使用这些顶点——这样顶点数增加时内存占用相对更少 | 有了这些数据结构之后，我们就用类似Kivy画布指令的Mesh把它们组合起来。它按照通常部件渲染的方式进行渲染，和其他Kivy部件有很好的兼容性。GLSL代码可以用来连接所有的部分 | . 这章提到了一个C语言概念，array（数组）——存放同类数据的连续内存区域。Python数据结构里也有，不过，Python通常用tuple（元组）或list（列表）。 . &#35299;&#37322;&#32034;&#24341; . 要理解OpenGL的索引（index），让我们举个例子。用前面代码里面的顶点，是按照(x, y)存放的： . vertices = ( 0, 0, 255, 0, 255, 255, 0, 255, ) . 一个索引就是顶点列表里面的顶点数据，原点是(0, 0)。如下图所示： . . 现在顶点还没有连起来，所以显示出来就是一些点，而不是一个多边形。我们定义一个indices列表来组合它们。三个点两组构成两个三角形： . indices = ( 0, 1, 2, # 三个点构成一个三角形 2, 3, 0, # 另一个三角形 ) . 这两个三角形中，第一个是由顶点0，1，2构成，第二个是由订单2，3，0构成。如下图所示，颜色是展示用的，我们还没有设置颜色，后面会补上。 . . OpenGL代码里面的索引就是这样使用的。 . OpenGL数据结构内存优化方法中很少是专门用来减少RAM的——很多时候视频接口吞吐量是性能的瓶颈，所以优化的目标都是每帧传递更多的内容，而不是通过压缩数据来节省内存。这点自始至终没有改变过。 . &#20889;GLSL&#20195;&#30721; . 下面我们就来写可以在GPU上执行的GLSL代码，它和C语言一样快。 . Kviy要求点着色器和像素着色器代码在一个文件里，代码用&#39;vertex&#39;和&#39;fragment&#39;分割，$HEADER$语句由Kivy指定，这并非任何标准，只在这里用： . vertex $HEADER$ void main(void) { // vertex shader gl_Position = ... } fragment $HEADER$ void main(void) { // fragment shader gl_FragColor = ... } . 为了节省篇幅，后面的代码会忽略这些样本代码，希望你看代码的时候记得它们是存在的。 . $HEADER$宏变量是上下文相关的，表示不同类型的着色器。 . 在点着色器里面，$HEADER$是下面代码： . varying vec4 frag_color; varying vec2 tex_coord0; attribute vec2 vPosition; attribute vec2 vTexCoords0; uniform mat4 modelview_mat; uniform mat4 projection_mat; uniform vec4 color; uniform float opacity; . 在像素着色器里面，$HEADER$是下面代码： . varying vec4 frag_color; varying vec2 tex_coord0; uniform sampler2D texture0; . 有点啰嗦，以后的Kivy版本应该会简化它们。 . &#23384;&#20648;&#31867;&#19982;&#31867;&#22411; . 在前面的代码里，不仅有数据类型，还有一个存储类： . 存储类（Storage classes） attribute：由点数据格式指定对应每个点的属性，由应用传递 | uniform：GLSL全局变量，同样由应用传递，但是不会随点变化 | varying：有点着色器传递到像素着色器 | . | 常用数据类型（Commonly used data types） float：浮点类型 | vec2, vec3, vec4：长度为2，3，4的元组类型，内部值为浮点类型。可以表示点、颜色等等 | mat2, mat3, mat4：规模为 2 × 2，3 × 3，4 × 4的矩阵类型， | sampler2D：表示一个用来装饰的纹理（texture）类型 | . | . &#22522;&#26412;&#30528;&#33394;&#22120; . 现在，让我们来写一个简单的着色器： . void main(void) { vec4 pos = vec4(vPosition.xy, 0.0, 1.0); gl_Position = projection_mat * modelview_mat * pos; } . 把每个点的坐标值转换成Kivy系统的坐标值，其原点在左下角。 . 这里不演示坐标变换的细节，作为入门教程有点复杂。其实也没必要完全理解这些细节，或者读完整本书。 如果你很感兴趣，可以去看看OpenGL的坐标空间和矩阵用法 最简单的像素着色器就是一个返回固定颜色的函数： . void main(void) { gl_FragColor = vec4(1.0, 0.0, 0.5, 1.0); } . 这里为每个点返回一个RGBA颜色值#FF007F。 . 如果你运行程序，你会看到输出结果如下图所示： . . 聊胜于无，折腾这么久，终于有点儿成果了，下面我们调整一下看看变化。 . &#31243;&#24207;&#30340;&#39068;&#33394; . 除了显示一种颜色外，颜色还有可以通过另一个方法让像素着色器显示出来。 . 假设我们想要计算每个像素的RGB颜色： . R通道值与x轴坐标成正比 | G通道值与y轴坐标成正比 | B通道值等于R与G均值 | . 对应最简单像素着色器的算法如下： . void main(void) { float r = gl_FragCoord.x / 255.0; float g = gl_FragCoord.y / 255.0; float b = 0.5 * (r + g); gl_FragColor = vec4(r, g, b, 1.0); } . gl_FragCoord变量包括相对于应用窗口的像素坐标值（并非实际屏幕的坐标值）。这里除以255.0是为了简化计算，让所有的值都落在[0，1]区间内。 . 效果图像如下： . . &#24425;&#33394;&#39030;&#28857; . 类似的彩色效果可以通过给点增加颜色数据来实现。因此，我们需要扩展点的数据格式，增加一个带颜色的属性vColor： . fmt = ( (b&quot;vPosition&quot;, 2, &quot;float&quot;), (b&quot;vColor&quot;, 3, &quot;float&quot;), ) vertices = ( 0, 0, 0.462, 0.839, 1, 255, 0, 0.831, 0.984, 0.474, 255, 255, 1, 0.541, 0.847, 0, 255, 1, 0.988, 0.474, ) indices = (0, 1, 2, 2, 3, 0) . 更新之后，每个点都有5个维度，后面三个是RGB颜色值。对应的vertices也要做修改。 . vColor属性是一个RGB颜色值，而点着色器用的是RGBA颜色，这里并没有每个点的alpha通道值，我们需要对点着色器做一些调整： . attribute vec3 vColor; void main(void) { frag_color = vec4(vColor.rgb, 1.0); vec4 pos = vec4(vPosition.xy, 0.0, 1.0); gl_Position = projection_mat * modelview_mat * pos; } . 在GLSL中，vColor.rgb和vPosition.xy表示法叫混合（swizzling）。它们可以有效的获取矢量的一部分，类似于Python的切片（slice）。 . 这里的vColor.rgb表示“取矢量的前三个值”，在Python里面就是vColor[:3]。还可以颠倒顺序，如vColor.bgr，甚至重复，如vColor.ggg（取三个G通道值），样式很灵活。 同理，可以取矢量的四个值，如.xyzw，.rgba或.stpq。 . 那么，像素着色器就很简单了： . void main(void) { gl_FragColor = frag_color; } . 让点与点之间的颜色插值计算，就呈现平滑渐变的效果了，这就是OpenGL的工作方式，如下图所示： . . &#32441;&#29702;&#26144;&#23556; . 下面再给我们的矩形增加一些纹理。我们还要扩展点数据格式的定义，给每个点增加纹理坐标值： . fmt = ( (b&quot;vPosition&quot;, 2, &quot;float&quot;), (b&quot;vTexCoords0&quot;, 2, &quot;float&quot;), ) vertices = ( 0, 0, 0, 1, 255, 0, 1, 1, 255, 255, 1, 0, 0, 255, 0, 0, ) . 纹理坐标值通常都在[0,1]区间内，原点在左上角，这和Kivy的左下角原点是不同的。使用过程中，需要注意这个差别。 . 下面是Python加载纹理并传递给渲染的过程： . from kivy.core.image import Image with self.canvas: Mesh( fmt=fmt, mode=&quot;triangles&quot;, indices=indices, vertices=vertices, texture=Image(&quot;kivy.png&quot;).texture, ) . 这样就把当前文件夹内的kivy.png文件转换成纹理了。如下图所示： . . 这和前面的着色器没啥不同。点着色器传递纹理的坐标值： . void main(void) { tex_coord0 = vTexCoords0; vec4 pos = vec4(vPosition.xy, 0.0, 1.0); gl_Position = projection_mat * modelview_mat * pos; } . 像素着色器用修改过的tex_coord0坐标值来装饰在texture0位置的纹理，于是返回对应的颜色： . void main(void) { gl_FragColor = texture2D(texture0, tex_coord0); } . 把代码放到一起就看可以到如下效果： . . 通过着色器的实现经历，你可以去做一些相关程序了。如果有的地方不明白不用郁闷，GLSL确实比较复杂，系统的学习它得费一番功夫。 . 但是，它可以让你更清楚底层的工作细节。即使你日常工作中没写过底层代码，你也可以掌握这些知识，以避免性能瓶颈，改善程序的架构。 . &#20570;&#28385;&#22825;&#26143;app . 学习了一堆GLSL的知识后，我们来做一个满天星屏保的app，星星会从屏幕的中央向四边飞来，给人一种穿越星空的快感。 . 动态效果用图片没法展示，你可以直接运行实例代码看看效果。 . 每颗星都会做如下动作： . 在屏幕中央随机生成 | 从屏幕中央向四周飞去直到看不见为止 | 然后从屏幕中央重新生成 | 我们还会让星星的尺寸在飞行中不断变大。如下图所示： . . &#24212;&#29992;&#26550;&#26500; . 新应用类的架构借用前面章节的内容即可。这里同样不用Kivy语言描述部件层级，所以没有starfield.kv。Python代码如下： . from kivy.base import EventLoop from kivy.clock import Clock class StarfieldApp(App): def build(self): EventLoop.ensure_window() return Starfield() def on_start(self): Clock.schedule_interval(self.root.update_glsl, 60 ** -1) . 这里build()方法创建并返回根部件Starfield；它将控制所有的数学和渲染应用中的内容。 . on_start()事件handler在程序启动后，让根部件通过update_glsl()方法实现每秒更新60次。 . Starfield类还分成两部分：__init__()方法用来创建数据结构，update_glsl()方法呈现图像（计算每颗星的位置）并渲染星星。 . &#25968;&#25454;&#32467;&#26500;&#19982;&#21021;&#22987;&#21270; . 初始化代码如下： . from kivy.core.image import Image from kivy.graphics.instructions import RenderContext from kivy.uix.widget import Widget NSTARS = 1000 class Starfield(Widget): def __init__(self, **kwargs): Widget.__init__(self, **kwargs) self.canvas = RenderContext(use_parent_projection=True) self.canvas.shader.source = &quot;starfield.glsl&quot; self.vfmt = ( (b&quot;vCenter&quot;, 2, &quot;float&quot;), (b&quot;vScale&quot;, 1, &quot;float&quot;), (b&quot;vPosition&quot;, 2, &quot;float&quot;), (b&quot;vTexCoords0&quot;, 2, &quot;float&quot;), ) self.vsize = sum(attr[1] for attr in self.vfmt) self.indices = [] for i in range(0, 4 * NSTARS, 4): self.indices.extend((i, i + 1, i + 2, i + 2, i + 3, i)) self.vertices = [] for i in range(NSTARS): self.vertices.extend( ( 0, 0, 1, -24, -24, 0, 1, 0, 0, 1, 24, -24, 1, 1, 0, 0, 1, 24, 24, 1, 0, 0, 0, 1, -24, 24, 0, 0, ) ) self.texture = Image(&quot;star.png&quot;).texture self.stars = [Star(self, i) for i in range(NSTARS)] . NSTARS是星星的总数，调整它会改变星星的密度。一个带Intel集成显卡的中档电脑可以轻松支持几千个星星。再高档点的显卡带几万个星星也没问题。 . 和前面的例子不同，这次我们不在最后实现索引和点的数组。在初始化阶段我们就设置好，方便后面update_glsl()方法更新。 . vfmt顶点格式包括四个属性，如下表所示： . 属性 功能 . vCenter | 星星中点在屏幕上的坐标值 | . vScale | 星星的尺寸，1表示（48 × 48 像素） | . vPosition | 每个顶点与星星中点的相对位置 | . vTexCoords0 | 纹理坐标值 | . 还有个属性vsize是顶点数组vfmt里的单个顶点的总长度。它计算顶点格式vfmt中间列的总和。 . vertices列表包含需要的数据；但它没有层次，不方便操作。这里就做了一个Star辅助类来实现，它把细节封装起来，在顶点数组外加了一个类，这样可以省不少事儿。 . Star类还会持续跟踪不属于顶点数据格式的一些属性，极坐标（以中心为原点的angle角度和distance距离）和不断增大的size。 . Star类定义如下： . import math from random import random class Star: angle = 0 distance = 0 size = 0.1 def __init__(self, sf, i): self.sf = sf self.base_idx = 4 * i * sf.vsize self.reset() def reset(self): self.angle = 2 * math.pi * random() self.distance = 90 * random() + 10 self.size = 0.05 * random() + 0.05 . base_idx是星星点数组的第一个顶点，还要加一个引用sf，方便Starfield实例连接vertices。 . reset()调用之后把星星的属性复原。 . &#25512;&#21160;&#22270;&#20687; . Starfield.update_glsl()方式实现了星星运动的算法，被on_start()事件handler的Kivy时钟程序频繁调用。源代码如下： . from kivy.graphics import Mesh def update_glsl(self, nap): x0, y0 = self.center max_distance = 1.1 * max(x0, y0) for star in self.stars: star.distance *= 2 * nap + 1 star.size += 0.25 * nap if star.distance &gt; max_distance: star.reset() else: star.update(x0, y0) self.canvas.clear() with self.canvas: Mesh( fmt=self.vfmt, mode=&quot;triangles&quot;, indices=self.indices, vertices=self.vertices, texture=self.texture, ) . 首先星星从屏幕中央产生之后，我们计算最大距离max_distance。然后，我们重复星星列表，让它们运动起来，然后不断放大。超出屏幕的星星被重置。 . 函数的最后看着很熟悉，那是前面讲过的渲染技巧。调用canvas.clear()是必须的，但是每次调用都增加一个新的匹配（Mesh），极快的推送到显卡上进行处理。 . 代码的最后内容是Star.update()方法。它更像星星的四个顶点，把新的坐标值写到vertices数值中： . def iterate(self): return range(self.j, self.j + 4 * self.sf.vsize, self.sf.vsize) def update(self, x0, y0): x = x0 + self.distance * math.cos(self.angle) y = y0 + self.distance * math.sin(self.angle) for i in self.iterate(): self.sf.vertices[i : i + 3] = (x, y, self.size) . iterate()辅助函数用来提高代码可读性，看着有点多，其实读起来更方便。 . 为了完成程序迭代，整个内存映射进程会把序列化每一帧里大量的对象作为一个重要目标来处理，这会提高性能。 . &#20889;GLSL&#20195;&#30721; . 着色器代码和前面类似。点着色器代码： . attribute vec2 vCenter; attribute float vScale; void main(void) { tex_coord0 = vTexCoords0; mat4 move_mat = mat4 (1.0, 0.0, 0.0, vCenter.x, 0.0, 1.0, 0.0, vCenter.y, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0); vec4 pos = vec4(vPosition.xy * vScale, 0.0, 1.0) * move_mat; gl_Position = projection_mat * modelview_mat * pos; } . 我们通过vScale因子与顶点坐标值相乘来等比例放大，然后用vCenter属性把它们变换成位置。move_mat矩阵是变换矩阵，线性代数里的一种放射变换方法。 . 像素着色器代码： . void main(void) { gl_FragColor = texture2D(texture0, tex_coord0); } . 最终的效果如下图所示： . . 这样，满天星app就完成了，感受一下穿越的乐趣吧。 . &#24635;&#32467; . 这一章我们介绍了底层的OpenGL硬件加速方式，用GLSL实现了点，索引和着色器。 . GPU直接编程是一个极其强大的概念，这种强大也需要大量付出。着色器比普通的Python代码要难得多，调试工作就更复杂了，也没有一个像Python的REPL那样方便的交互开发环境。也就是说，做应用的时候，写原始的GLSL代码是否必要并没有答案，只能因地制宜。 . 这章的例子只是一个简单教程，并不是能力测试。因为 GLSL非常难学，大量的书籍和在线教程都已经介绍过它，这里的内容不足以完整的介绍OpenGL的内容，若感兴趣可以看看。 . 现在，我们算是入门了。下一章我们利用这章的代码来做一个更好玩的应用，一个酷炫的射击游戏。 .",
            "url": "/Kivy/jupyter/kivy/android/ios/2019/09/01/kivy-ch8-shaders-app.html",
            "relUrl": "/jupyter/kivy/android/ios/2019/09/01/kivy-ch8-shaders-app.html",
            "date": " • Sep 1, 2019"
        }
        
    
  
    
        ,"post9": {
            "title": "Kivy指南-7-飞翔的小鸟app",
            "content": "上一章，通过制作2048app，我们已经掌握了游戏开发的简单技巧。这一章，我们继续游戏开发，做一个同样很受欢迎的游戏，飞翔的小鸟（Flappy Bird），重点学习一下游戏开发中的横向卷轴模式（Side-Scrolling）。 . 这是一款由越南独立开发者阮哈东（Dong Nguyen）2013年开发的手机游戏，短时间竟占领了全球各大App Store免费排行榜首位，2014年年末的时候，下载量已经 iOS App Store第一。其设计思路非常有趣，游戏操作就是一个人点击屏幕（或者空格键）保持飞翔，穿过重重障碍。这种简单重复的设计思路现在越来越流行，后面会详细介绍。 . 移动游戏设计的荆棘之路 . 经典的二维街机游戏风格在手机上复活了。有大量的经典游戏商业改造版，和30年前唯一不同的就是价签——包括Dizzy，Sonic，Double Dragon和R-Type等等。 . 这些游戏一个共同的不足就是控制方式感受很差，毕竟触摸屏和陀螺仪目前还不能完全替代摇杆的效果。这也给新游戏提供了卖点——发挥触摸屏的特点，设计一种新的控制方式就能获得成功。 . 一些开发者通过简单的设计来赢得客户，因为简单游戏有巨大的市场，尤其是低成本和免费的游戏。 . 那些操作简单的游戏确实很受欢迎，飞翔的小鸟就是如此。这一章，我们将用Kivy来实现这种简单的设计方法。教学大纲如下： . 模拟简单的街机游戏 | 用Kivy部件开发游戏，完成方向控制和二维变换，比如旋转 | 实现简单的碰撞检测 | 实现游戏的声音效果 | . 这个游戏没有获胜条件，最小的碰撞都会失败。在原版游戏中，玩家以分数高低论输赢。和上一章类似，如果感兴趣，记分板可以当作练习。 . &#39033;&#30446;&#20171;&#32461; . 我们要做一个与飞翔的小鸟差不多的版本，姑且取名叫Kivy bird吧。游戏最终界面如下： . . 我们的游戏包括下面三个部分： . 背景图案：背景是由一些以不同速度移动哦图层构成，给人一种视差效果。运动速度是不变的，也没有其他游戏事件。背景比较容易做，我们将从这里开始。 | 障碍物（管道）：这是一个单独的图层，也是以固定的速度向玩家移动。与背景不同的是，管道的高度会不断变化，中间留出一段空间让玩家通过。碰到管道游戏失败。 | 游戏角色（小鸟）：小鸟一直往下掉，只能垂直飞翔。玩家点击屏幕，小鸟就向上飞。如果小鸟掉到地上，碰到天花板或管道，游戏都失败。 | . 这就是游戏的基本设计思路。 . &#21046;&#20316;&#32972;&#26223;&#21160;&#30011; . 我们将用下面的图片来做背景图案： . . 这些图片都可以无缝平铺在一起——这并不是必须的，只是看着会更好看。 . 如上所述，背景一直是运动的。这种效果可以通过两种方法实现： . 直接的方法就是在背景上移动一个大的多边形（或者几个多边形）。只是创建循环的动画需要费点功夫 | 更有效的方法是创建一些静态多边形（一个是一层）占据整个屏幕，然后让花纹图案动起来。用一个平铺的花纹图案，这个方法可以流畅的实现动画效果，也省不少功夫——不需要重新定位背景上的对象。 | . 我们要第二种方法来实现，因为这更简单有效。首先让我们把kivybird.kv文件做出来： . FloatLayout: Background: id: background canvas: Rectangle: pos: self.pos size: (self.width, 96) texture: self.tx_floor Rectangle: pos: (self.x, self.y + 96) size: (self.width, 64) texture: self.tx_grass Rectangle: pos: (self.x, self.height - 144) size: (self.width, 128) texture: self.tx_cloud . 这里的数字都是花纹的尺寸：96是地面高度，64是草的高度，144是云的高度。在实际开发中写这些代码很费劲，不过我们应该尽量简化代码，降低工作量。 . 你会看到，这里没有移动的部分，就是三个矩形在屏幕的底部和顶部。动画效果需要花纹用Background类中带tx_的属性来实现，下面我们就是。 . &#21152;&#36733;&#24179;&#38138;&#30340;&#33457;&#32441; . 让我们建一个辅助函数来加载平铺的花纹，这个函数在后面经常用到，所以把它放在最上面。 . 首先创建一个Widget类，作为自定义部件的基类，main.py中代码如下： . from kivy.core.image import Image from kivy.uix.widget import Widget class BaseWidget(Widget): def load_tileable(self, name): t = Image(&quot;%s.png&quot; % name).texture t.wrap = &quot;repeat&quot; setattr(self, &quot;tx_%s&quot; % name, t) . 创建辅助函数的语句就是t.wrap = &#39;repeat&#39;。我们要把它应用到每一块花纹上。 . 我们还需要储存新加载的花纹，用tx_加图片名称来命名。比如，load_tileable(&#39;grass&#39;)就会把grass.png加载到self.tx_grass属性。 . &#32972;&#26223;&#37096;&#20214; . 现在我们来实现Background部件： . from kivy.properties import ObjectProperty class Background(BaseWidget): tx_floor = ObjectProperty(None) tx_grass = ObjectProperty(None) tx_cloud = ObjectProperty(None) def __init__(self, **kwargs): super(Background, self).__init__(**kwargs) for name in (&quot;floor&quot;, &quot;grass&quot;, &quot;cloud&quot;): self.load_tileable(name) . 如果现在执行代码，你会看到花纹被拉伸填充矩形，这是因为还没有指定花纹的坐标。改变每块花纹的uvsize属性就可以了，这样就计算出覆盖多边形需要多少块花纹了。比如，uvsize设为(2, 2)表示填充一个矩形需要4块花纹。 . 辅助函数可以用来设置uvsize的值，这样我们的花纹就不会变形了： . def set_background_size(self, tx): tx.uvsize = (self.width / tx.width, -1) . 这里负坐标值表示花纹可以被切割。Kivy用这种效果来避免高成本的栅格操作，把负担转给GPU（显卡），这样处理起来更轻松。 . 这个方法依赖于背景的宽度，所以每次size属性变化之后可以用on_size()调用一次。这样就可以在屏幕发生变化的时候保持uvsize属性及时更新了： . def on_size(self, *args): for tx in (self.tx_floor, self.tx_grass, self.tx_cloud): self.set_background_size(tx) . 现在背景图案就变成这样了： . &#32972;&#26223;&#21160;&#30011; . 下面我们要让背景动起来。首先，我们要在KivyBirdApp类增加一个每秒60下的运动计时器： . from kivy.app import App from kivy.clock import Clock class KivyBirdApp(App): def on_start(self): self.background = self.root.ids.background Clock.schedule_interval(self.update, 0.016) def update(self, nap): self.background.update(nap) . update()方法就是把控制传递给Background部件的update()。当我们需要更多移动的时候，我们再扩展这个方法。 . 在Background.update()里面，我们改变花纹来模拟运动状态： . def update(self, nap): self.set_background_uv(&quot;tx_floor&quot;, 2 * nap) self.set_background_uv(&quot;tx_grass&quot;, 0.5 * nap) self.set_background_uv(&quot;tx_cloud&quot;, 0.1 * nap) def set_background_uv(self, name, val): t = getattr(self, name) t.uvpos = ((t.uvpos[0] + val) % self.width, t.uvpos[1]) self.property(name).dispatch(self) . 辅助函数里面的set_background_uv()作用是： . 增加uvpos属性的横坐标，水平移动花纹 | 花纹的属性调用dispatch()表示花纹位置已经改变了 | . kivybird.kv的画布指令会监听这个变化并及时反馈，把花纹重新渲染出来，这样就会看到流畅的动画了。 . set_background_uv()里面控制不同图层速度的因子是随意选择的，可以自定义。 . 这样背景就完成了，下面我们来做管道。 . &#21046;&#20316;&#31649;&#36947; . 管道分成两部分：高的和低的。中间会留出一个孔给小鸟飞过。每一部分都是有不同长度的管体和管头构成。 . . kivybird.kv文件里的布局部件给我们一个好起点： . &lt;Pipe&gt;: canvas: Rectangle: pos: (self.x + 4, self.FLOOR) size: (56, self.lower_len) texture: self.tx_pipe tex_coords: self.lower_coords Rectangle: pos: (self.x, self.FLOOR + self.lower_len) size: (64, self.PCAP_HEIGHT) texture: self.tx_pcap Rectangle: pos: (self.x + 4, self.upper_y) size: (56, self.upper_len) texture: self.tx_pipe tex_coords: self.upper_coords Rectangle: pos: (self.x, self.upper_y - self.PCAP_HEIGHT) size: (64, self.PCAP_HEIGHT) texture: self.tx_pcap size_hint: (None, 1) width: 64 . 其实很简单，就是把管道从下到上分成四个矩形： . 底部管体 | 底部管头 | 顶部管体 | 顶部管头 | . . 与Background部件的实现过程类似，这些属性都要连接到部件图形显示算法的Python代码中。 . &#31649;&#36947;&#23646;&#24615;&#20171;&#32461; . pipe部件有趣的属性是： . from kivy.properties import AliasProperty, ListProperty, NumericProperty, ObjectProperty class Pipe(BaseWidget): FLOOR = 96 PCAP_HEIGHT = 26 PIPE_GAP = 120 tx_pipe = ObjectProperty(None) tx_pcap = ObjectProperty(None) ratio = NumericProperty(0.5) lower_len = NumericProperty(0) lower_coords = ListProperty((0, 0, 1, 0, 1, 1, 0, 1)) upper_len = NumericProperty(0) upper_coords = ListProperty((0, 0, 1, 0, 1, 1, 0, 1)) upper_y = AliasProperty( lambda self: self.height - self.upper_len, None, bind=[&quot;height&quot;, &quot;upper_len&quot;] ) . 首先，常量都放在ALL_CAPS里面： . FLOOR：地面花纹的高度 | PCAP_HEIGHT：管头高度 | PIPE_GAP：留给小鸟飞过的小孔高度 | . 然后就是花纹的属性tx_pipe和tx_pcap。它们和那些在Background类里面花纹的用法一样 . class Pipe(BaseWidget): def __init__(self, **kwargs): super(Pipe, self).__init__(**kwargs) for name in (&quot;pipe&quot;, &quot;pcap&quot;): self.load_tileable(name) . ratio属性定义空的位置：0.5表示出现在中间（默认值），0表示出现在屏幕底部（地上），1表示出现在屏幕顶部（天空）。 . upper_y是减少输入次数的辅助函数，它是用来计算height - upper_len值的。 . 还有两个重要的属性lower_coords和upper_coords，用来设置花纹的坐标。 . &#35774;&#32622;&#33457;&#32441;&#30340;&#22352;&#26631;&#20540; . 在Background部件的实现过程中，我们调整了花纹的属性，像uvsize和uvpos来控制渲染效果。这个方法的问题是这么做会影响花纹的所有实例。 . 只要花纹没有在不同的几何形状中使用这么做就没问题。但是，现在我们需要在所有形状中都控制花纹的属性，因此我们就不能调整uvsize和uvpos了。我们需要用Rectangle.tex_coords。 . Rectangle.tex_coords属性接受一个8个数字的列表或元组，把花纹的坐标匹配到矩形的四个角落。tex_coords这种匹配方式如下图所示： . . 花纹匹配通常用u和v，不用x和y。这样可以把几何位置与花纹坐标值区分开，经常容易混淆。 . &#23454;&#29616;&#31649;&#36947; . 这个主题看着有点混乱，让我们一点点来推进：我们要垂直固定管道上的砖块，只需要调整tex_coords的第5和第7个元素。另外，tex_coords的值和uvsize里面的值是一个意思。基于管道高度调整砖块的坐标如下所示： . def set_coords(self, coords, len): len /= 16 # height of the texture coords[5:] = (len, 0, len) # set the last 3 items . 然后就是用ratio和屏幕高度来计算管道的长度： . def on_size(self, *args): pipes_length = self.height - (Pipe.FLOOR + Pipe.PIPE_GAP + 2 * Pipe.PCAP_HEIGHT) self.lower_len = self.ratio * pipes_length self.upper_len = pipes_length - self.lower_len self.set_coords(self.lower_coords, self.lower_len) self.set_coords(self.upper_coords, self.upper_len) . 这段on_size()代码用来使所有的属性与屏幕尺寸保持同步。要反映ratio的变化，需要这样： . self.bind(ratio=self.on_size) . 你可能发现在代码中我们没改变这个属性。这是因为管道的整个生命周期将通过KivyBirdApp类来处理，马上你就会看到。 . &#29983;&#25104;&#31649;&#36947; . 要创建一堆望不到头的管道森林，我们需要把它们摆满屏幕，用循环队列就可以实现。 . 我们让两个管道的间距是半屏宽，这样可以给玩家充分的准备时间，这样屏幕上同时会出现最多3个管道。为了方便测量，我们需要做4个管道。 . 实现代码如下： . class KivyBirdApp(App): pipes = [] def on_start(self): self.spacing = 0.5 * self.root.width # ... def spawn_pipes(self): for p in self.pipes: self.root.remove_widget(p) self.pipes = [] for i in range(4): p = Pipe(x=self.root.width + (self.spacing * i)) p.ratio = random.uniform(0.25, 0.75) self.root.add_widget(p) self.pipes.append(p) . pipes列表的使用应该考虑实现细节。我们可以遍历子部件列表来连接管道，但是只是更好看一点儿。 . spawn_pipes()方法开始部分的清除代码允许我们后面重启程序更方便。 . 我们还用随机分布来控制ratio参数。这里用[0.25, 0.75]作为随机范围，而不是常用的[0, 1]，是为了让小孔生成的位置更容易一些。 . &#24490;&#29615;&#31227;&#21160;&#31649;&#36947; . 与背景图案通过改变uvpos属性模拟运动的方式不同，管道真正移动。更新KivyBirdApp.update()方法来实现管道的循环更新： . def update(self, nap): self.background.update(nap) for p in self.pipes: p.x -= 96 * nap if p.x &lt;= -64: # pipe gone off screen p.x += 4 * self.spacing p.ratio = random.uniform(0.25, 0.75) . 和之前的动画一样，96是随机的移动速度因子；因子越大速度越快。 . 每个管道的ratio数值都是随机生成的，这样就为玩家创建一个新的管子。界面如下图所示： . . &#21046;&#20316;&#23567;&#40479; . 下面我们来制作小鸟： . 这个很简单，直接用Kivy的Image部件（kivy.uix.image.Image）实现Bird类就行。 . kivybird.kv文件里面，我们需要几个属性来处理小鸟图片： . Bird: id: bird pos_hint: {&#39;center_x&#39;: 0.3333, &#39;center_y&#39;: 0.6} size: (54, 54) size_hint: (None, None) source: &#39;bird.png&#39; . 这是Bird类的Python实现： . from kivy.uix.image import Image as ImageWidget class Bird(ImageWidget): pass . 在实现细节之前，我们需要完成一些基础工作。 . &#28216;&#25103;&#29609;&#27861;&#22238;&#39038; . 现在，让我们回忆一下游戏的过程： . 首先，在没有任何管道和重力的时候，确定鸟的初始位置。这个状态用playing = False代码表示 | 只要玩家开始了游戏（点击屏幕或者用键盘敲空格键），代码就变成playing = True，管道开始生成，重力开始影响小鸟的状态。玩家需要持续的动作保持小鸟不掉下来 | 如果发生碰撞，游戏重回playing = False，每个物体都会静止下来，等待玩家重新启动，然后回到步骤2重新开始 | 为了实现这些，我们需要获取玩家输入的内容，很容易做到，因为我们只关心事件是否发生，不关心在哪里发生，整个屏幕就是一个大的按钮。 . &#25509;&#21463;&#29992;&#25143;&#36755;&#20837; . 下面是实现代码： . from kivy.core.window import Window, Keyboard class KivyBirdApp(App): playing = False def on_start(self): # ... Window.bind(on_key_down=self.on_key_down) self.background.on_touch_down = self.user_action def on_key_down(self, window, key, *args): if key == Keyboard.keycodes[&quot;spacebar&quot;]: self.user_action() def user_action(self, *args): if not self.playing: self.spawn_pipes() self.playing = True . 这就是用户输入处理方式：on_key_down事件处理键盘输入，检查玩家是否敲了空格键。on_touch_down事件处理其他事件。最后都调用user_action()方法，执行spawn_pipes()，并把playing设置成True。 . &#23454;&#29616;&#23567;&#40479;&#19978;&#19979;&#39134;&#34892; . 紧接着，我们要实现重力让小鸟在一个方向上飞行。这里，我们引入Bird.speed属性和一个新常量——加速度。每一帧的速度矢量都向下增加，造成一种匀加速下降运行。如下面的代码所示： . class Bird(ImageWidget): ACCEL_FALL = 0.25 speed = NumericProperty(0) def gravity_on(self, height): # Replace pos_hint with a value self.pos_hint.pop(&quot;center_y&quot;, None) self.center_y = 0.6 * height def update(self, nap): self.speed -= Bird.ACCEL_FALL self.y += self.speed . 当playing变成True时，gravity_on()方法会被调用。把self.bird.gravity_on(self.root.height)插入到KivyBirdApp.user_action()方法中： . if not self.playing: self.bird.gravity_on(self.root.height) self.spawn_pipes() self.playing = True . 这个方法可以有效的重置鸟的初始位置，从pos_hint里面把&#39;center_y&#39;移除。 . self.bird类似前面的self.background。下面的代码应该放在KivyBirdApp.on_start()里面： . self.background = self.root.ids.background self.bird = self.root.ids.bird . 我们还得从KivyBirdApp.update()方法里面调用Bird.update()。这样做有个好处，可以在不玩游戏的时候为升级游戏对象加一个防护： . def update(self, nap): self.background.update(nap) if not self.playing: return # don&#39;t move bird or pipes self.bird.update(nap) # rest of the code omitted . 你会发现，任何时候Background.update()方法都可以被调用；其他方法都是必要的时候才调用。 . 这里没有实现保持小鸟在空中的能力，下面会实现。 . &#20445;&#25345;&#22312;&#31354;&#20013; . 要让飞翔的小鸟跳着飞行也很简单。我们改写Bird.speed就行，把它设置一个正数值，当小鸟持续跌落的时候让它正常延迟。让我们在Bird类里面增加方法： . ACCEL_JUMP = 5 def bump(self): self.speed = Bird.ACCEL_JUMP . 现在，我们需要在KivyBirdApp.user_action()方法的最后调用self.bird.bump()就可以了，只要重复点击屏幕或按空格键都可以保持在空中。 . &#26059;&#36716;&#23567;&#40479; . 旋转小鸟是为了让游戏更生动，当它飞行的时候，沿着它的飞行轨迹旋转，看着很生动。向上飞行的时候朝着右上角旋转，向下飞行的时候朝着左下角旋转。 . 角度计算的方法如下： . class Bird(ImageWidget): speed = NumericProperty(0) angle = AliasProperty(lambda self: 5 * self.speed, None, bind=[&quot;speed&quot;]) . 这里的速度因子5是随意设置的。 . 现在，要让小鸟旋转起来，我们要在kivybird.kv里面加入： . &lt;Bird&gt;: canvas.before: PushMatrix Rotate: angle: root.angle axis: (0, 0, 1) origin: root.center canvas.after: PopMatrix . 这个操作会改变OpenGL使用的局部坐标系统，影响后面所有的渲染。不要忘了保存（PushMatrix）和恢复（PopMatrix）坐标系统的状态，否则致命的错误可能会发生，导致整个画面变形。 . 如果您遇到莫名的app渲染问题，看看OpenGL的底层指令。 . 这样，小鸟就可以沿着既定的轨道飞行了。 . &#30896;&#25758;&#30417;&#27979; . 这个游戏最重要的事情之一就是碰撞监测，当鸟碰到地板、天花板和管道都要结束游戏。 . 用地面和屏幕高度与小鸟的高度bird.y对比，就可以轻松确认小鸟是否已经碰到。在KivyBirdApp实现如下： . def test_game_over(self): if self.bird.y &lt; 90 or self.bird.y &gt; self.root.height - 50: return True return False . 监测是否碰到管道有点困难。我们要分两步来监测：首先，我们用Kivy的collide_widget()方法来测试横坐标，然后检查纵坐标是否在合理的范围之内（管道上下两段的lower_len和upper_len属性）。KivyBirdApp.test_game_over()方法最终实现如下： . def test_game_over(self): screen_height = self.root.height if self.bird.y &lt; 90 or self.bird.y &gt; screen_height - 50: return True for p in self.pipes: if not p.collide_widget(self.bird): continue # The gap between pipes if self.bird.y &lt; p.lower_len + 116 or self.bird.y &gt; screen_height - ( p.upper_len + 75 ): return True return False . 如果监测失败就会返回False，游戏会结束。 . &#28216;&#25103;&#32467;&#26463; . 当碰撞发生是回发生什么呢？我们只要把self.playing改为False就行。监测结果可以在所有的计算完成后增加到KivyBirdApp.update()最后： . def update(self, nap): # ... if self.test_game_over(): self.playing = False . 这个状态要等用户重新开始游戏才会消失。写碰撞监测代码最给力的部分就是边玩边测试，就是可以同时出现不同的游戏失败状态： . . 虽然游戏失败，效果还是很Q的。 . &#21046;&#20316;&#22768;&#25928; . 这部分和Kivy开发没啥关系了，就是演示一些制作游戏和应用声效的工具。 . 声效的最大问题都不是技术上的。创建高质量的声效不是简单的事儿，软件工程师毕竟没有音乐和声乐工程师专业。另外，很多应用实际上没用声效，所以声效通常是被忽略了。 . 不过制作声效的简便工具还是不少的。Bfxr就是一个很棒的免费电子合成器。用法很简单，就是单击一些设置按钮配置好音效，然后点击Save to Disk保存到电脑上就行了，用Bfxr可以很轻松地为app创建声效。 . . Kivy&#22768;&#38899;&#25773;&#25918; . 在程序处理时，Kivy提供了声音播放的API： . from kivy.core.audio import SoundLoader snd = SoundLoader.load(&quot;sound.wav&quot;) snd.play() . 用play()方法就开始播放。不过这个简单的方法在游戏里面使用有点问题。 . 很多时候，你需要让声音随着你的动作不断的重复。Kivy的sound类的问题就是只能在指定的时间内播放一次。 . 可行方式如下： . 等前一个播放终止（默认的行为，后面的事件都会静音） | 为每个事件停止播放然后重启播放，还是有问题（可能引起延迟） | . 要解决这个问题，我们需要创建一个sound对象的队列，这样每次调用play()就产生一个Sound对象。当队列结束时，我们可以从头开始。只要队列足够长，我们就可以完全不用担心Sound的限制了。实际上，长度为10就可以。实现代码如下： . class MultiAudio: _next = 0 def __init__(self, filename, count): self.buf = [SoundLoader.load(filename) for i in range(count)] def play(self): self.buf[self._next].play() self._next = (self._next + 1) % len(self.buf) . 用法如下： . snd = MultiAudio(&quot;sound.wav&quot;, 5) snd.play() . 上面第二个参数就是队列的长度。看看我们是如何改写Sound API的play()方法的。这样在简单的程序里直接替换Sound就可以。 . &#28155;&#21152;&#22768;&#25928; . 下面让我们把声效添加到kivy Bird游戏里。 . 有两个地方需要使用声音文件，一个是小鸟向上飞，一个是撞到东西。 . 第一个事件，通过单击和切换来初始化，在速度快的时候重复很频繁，我们用一个队列。第二个事件，游戏结束，不会频繁的发生，所以就用一个Sound对象： . snd_bump = MultiAudio(&quot;bump.wav&quot;, 4) snd_game_over = SoundLoader.load(&quot;game_over.wav&quot;) . 用前面加载过的MultiAudio类就行。剩下的事情就是把play()添加到适当的位置： . if self.test_game_over(): snd_game_over.play() self.playing = False def user_action(self, *args): snd_bump.play() . 这样，飞翔的小鸟就有声音了，希望你喜欢。 . &#24635;&#32467; . 这一章，我们做了一个Kivy小游戏，用到了画布指令和部件。 . 作为UI工具包，Kivy提供了很多好东西，允许我们自由的组合、新建任何部件，可以做微信客户端和视频游戏等等。Kivy属性实现的一个特别值得称赞的地方就是可以无限制的组织数据，帮助我们充分消除不必要的内容（比如在属性没有发生变化的时候重新刷屏）。 . Kivy的另一个令人惊奇也是反直觉的特点就是它的性能很好——虽然Python并不以性能著称。部分原因是因为Kivy底层系统是Cython写的，被编译成机器码，性能和C语言有一拼。另外，如果配置合适，显卡加速也可以用来保证动画流程运行。 . 下一章我们将继续提供图形渲染性能。 .",
            "url": "/Kivy/jupyter/kivy/android/ios/2019/08/01/kivy-ch7-flappy-bird-app.html",
            "relUrl": "/jupyter/kivy/android/ios/2019/08/01/kivy-ch7-flappy-bird-app.html",
            "date": " • Aug 1, 2019"
        }
        
    
  
    
        ,"post10": {
            "title": "Kivy指南-6-2048 app",
            "content": "后面的章节，我们将逐步加深难度来介绍Kivy在游戏领域的开发过程，包括状态的管理，角色控制，音效和图象快速渐变的实现等。 . 这里提到的内容都是当今游戏开发中不可或缺的，因此有很多软件可以基于同样的算法和性能来实现这些功能，就像视频游戏一样。 . 但是，不积跬步，无以至千里。我们要踏出的第一步就是实现老少皆宜的2048游戏。 . 教学大纲如下： . 创建具有可视化的外观和行为的Kivy部件 | 用自带的图形命令在画板上绘制 | 用屏幕上的绝对位置随意排列部件（非结构化布局） | 用Kivy自带的动画支持平滑移动部件 | . 在前面用过布局部件之后，用绝对坐标放置部件听着像是一种倒退，但是在需要很多交互的应用和游戏里面，实乃必要之举。例如，虽然在很多游戏里面的矩形块可以用GridLayout部件来表示，但是要实现从一个位置到了一个位置的简单移动都很麻烦。这是由于部件要不断重新绘制，用固定的布局来实现效率极低。 . &#28216;&#25103;&#20171;&#32461; . 2048游戏是一个数学游戏，在一个4x4的表格里玩。里面有2，4，8，...，2048，4096，8192共13种方块（可以调节难度，一般玩到2048，所以游戏叫2048），每次随机出现一种方块，可以通过上、下、左、右四个方向把所有方块直线移动最大范围，对把相同的相邻方块相加，数字翻倍，然后消除旧方块，同时出现新方块，循环往复，直到所有的表格都被填满，且没有相邻的数字可以相加为止，游戏结束。 . 纸上得来终觉浅，绝知此事要躬行。说那么多不如玩一把，如下图所示： . &#28216;&#25103;&#27010;&#24565;&#31616;&#20171; . 游戏有很多不同的状态：通过一系列的状态完成，像开始界面，地图界面，塔防界面等等，不同的游戏都有具体的界面组合。每个游戏都不一样，也没有多少共性。 . 但有一个基本特性是大多数游戏都是关于输赢的。这虽然微不足道，但是玩家对游戏的感知最终是通过游戏的界面和输赢来体现的。 . 很多游戏并不注重“GAME OVER”的设计，有的甚至没有，这会给玩家留下很不好的感受。这样的游戏通常也提供了一个强大的本土优势和劣势状态来弥补。 比如，如果你在魔兽世界或其他MMPRPG(Massive Multiplayer Online Role Playing Game，大型多人在线角色扮演游戏)里面不能赢也不会彻底挂掉，那你一定会在线复活或者修理设备这样的任务来回血。 如果你的游戏确实非常棒，时间久了以后，你也会获得一群游戏达人，这在只论输赢的游戏里面是没有的（也免不了菜鸟玩家）。这就需要不断的提供大BOSS，保持挑战性。 . 2048这个游戏的设计挺好，随着方块的出现，越来越多的方块不能被合并，游戏的难度几何级增大。 . 刚开始的时候很简单，玩家可以随意移动不需要动脑子。随着游戏的继续，更多的方块沉淀下来，没有找到合并的机会，可用空间不断减少，危机感来了，合理的合并策略就是必须深思熟虑的了。 . 2048的游戏理念非常值得借鉴：开始的时候很容易，让人爱不释手，游戏的难度不断增加，引人入胜。 . &#38543;&#26426;&#24615; . 由于每次所有的16个方块都会移动，玩家如果不注意可能结果是难以预料的。尽管是完全确定的，算法还会被认为是有一点随机性。这就让2048看起来更像街机游戏，有点靠运气，也会带来惊喜。 . 随机性的好处就是永远不知道下一个巧克力是什么味道的，这让游戏变得更好玩。 . 2048&#35774;&#35745;&#24605;&#36335; . 我们的设计思路如下： . 一个4x4的网格 | 每一回合都会执行下面的动作： 玩家只可以沿一个方向移动所有方块 | 把相同的两个方块相加生成一个新方块 | 新的2个方块在空白的格子里面产生 | . | 玩家得到一个2048就赢了 | 当网格中没有空白，也不能合并时就输了 | . 上述几条就是2048的设计思路，后面我们就一步一步来实现它。 . &#36873;2048&#30340;&#29702;&#30001; . 有人可能会问，我们为什么要做一个已经家喻户晓的游戏，而不是做个新的。下面说说这么做的道理： . 这里先说点儿软件开发的事情，虽然有点离题，但重建一个知名项目的合理性并不是每个人都知道。如果这里不把事情说清楚，下一章依然跳不过这道坎。 . 重建2048（可谓重做轮子）的根本原因是游戏开发实在太复杂，具体解释如下： . 好的游戏方案很难得到，因为那需要一堆创意 | 好游戏不能太复杂，要能快速上手，但是又不能太简单无聊，要有后劲。这一点更难了 | 不同算法实现难易程度迥异。在静态的二维网格里查找路径，比在动态的三维空间里做难度要小得多；用AI（artificial intelligence，人工智能）来做射击游戏虽然很简单，还是可以取得不错的成果。如果用AI来做策略游戏，那就可以让电脑更聪明、更难以捉摸，让游戏呈现出足够的挑战性和多样性 | 注重细节和不断优化是好游戏不可或缺的，这需要大量的专业人员来共同努力 | . 这里只是抛砖引玉，并不是要吓唬大家远离游戏开发，但是游戏开发中有太多地方会出错了，所以不要犹豫把搞不定的部分外包出去。这会大大降低你的投入成本，提高产品发布的效率。 . 一个务实的游戏开发项目（特别是像本书这种零预算的项目）就应该是避免高成本的创造性探索，特别是在游戏内容设计方面。如果你不能为这个项目获得投资，它的独创性就没什么价值了。这就是为什么做游戏的时候首先考虑已有的项目。 . 不过，也没必要完全抄袭别人的创意——调整游戏的一些部分可以更好玩，同时也能锻炼自己的能力。 . 实际上，大多数游戏都是借用其他人的创意，玩法，有时候游戏场景都和以前的游戏类似，甚至没什么多样性（无论质量孰优孰劣，这总不是什么好事，就如今天的工业产品一般）。 . &#31616;&#21270;&#29305;&#24615; . 回到2048游戏，值得注意的是，它的规则非常简单，看着十分普通。但是它好玩的地方就是它也非常的难；2048一直很流行，在许多应用商店和网页上都有。 . 2048的流行实在太流行了，从头开始重建很有价值，不仅仅只是为了学习它。现在，你应该相信做2048是一个多么酷的事情了吧，那就让我们开始吧。 . &#23454;&#29616;2048&#32593;&#26684; . 到目前为止，我们都是用Kivy自带的部件，这一章我们打算建造自己的部件：Board（2048的网格）和Tile（里面的方块，像地上的瓷砖）。 . 让我们从创建背景色这些简单任务入手。一种做法可能是用背景图片，这种方法会遇到屏幕尺寸的问题（我们前面说过）。 . 我们要用的方法是创建一个Board部件，在画布上绘制网格。这样，网格的位置和大小就可以通过Kivy来定义，这和我们前面学过的文本框和按钮一样。 . 最简单的起点就是设置网格的尺寸和位置。有效的做法是用FloatLayout部件；这是Kivy提供的一个布局类，支持尺寸和位置的设置。建立game.kv文件，其代码如下： . #:set padding 20 FloatLayout: Board: id: board pos_hint: {&#39;center_x&#39;: 0.5, &#39;center_y&#39;: 0.5} size_hint: (None, None) center: root.center size: [min(root.width, root.height) - 2 * padding] * 2 . Board部件位于整个屏幕的正中间的正方形，上下、左右边距分别对称。为了尽可能的占有屏幕空间，我们在屏幕的宽和高中选择最小值，然后去掉左右边距。 . 要看到结果，就需要在Python文件中定义Board部件，然后加载一些内容（空部件也是看不见的）。在main.py文件中添加代码： . from kivy.graphics import BorderImage from kivy.uix.widget import Widget spacing = 15 class Board(Widget): def __init__(self, **kwargs): super(Board, self).__init__(**kwargs) self.resize() def resize(self, *args): self.cell_size = (0.25 * (self.width - 5 * spacing),) * 2 self.canvas.before.clear() with self.canvas.before: BorderImage(pos=self.pos, size=self.size, source=&quot;board.png&quot;) on_pos = resize on_size = resize . 类似于game.kv里面的padding定义，我们在Python文件的开头定义了spacing。这是网格内构成格子的网的厚度，用来表示后面出现方块的边距，这样在视觉上就显得轻松一些，不那么拥挤。因为是4x4的网格，自然代码里面要剪掉5条边距。 . resize()方法在Board部件初始化阶段（__init__()）创建，或者由on_pos和on_size事件调用。当部件绘制完成后，就计算方块的大小cell_size： . $$方块尺寸(cell size) = frac {{ 网格尺寸 - (方块数量 + 1) times 边距 }} {{方块数量}}$$ . 这里的尺寸（size）是指宽度或高度，因为它们都是方块，用哪个都一样。 . 然后我们渲染背景色，先清除之前的图象指令组canvas.before，然后用元素填充（暂时先用BorderImage）。canvas.before与canvas.after和canvas相反，是在部件渲染之前执行的。这样就做是为了让背景色处于所有元素的下面。 . 画布指令组是Kivy组织底层图形操作的方式，比如在画布上复制图象，画线，执行OpenGL命令等。关于画布的介绍可以参见第二章画图app。 每个画布指令都在kivy.graphics命名空间里面，都是canvas对象的子类，如canvas.before与canvas.after，类似于子部件与容器部件或根部件的继承关系。 这种子部件的不同在于其具有一个复杂的生命周期，可以布置在屏幕上，响应事件和其他一些动作。但是，渲染指令却相反，就是用来绘制图形的，功能单一。比如，Color指令就是改变颜色，Image指令就是画图形等等。 . 这里的背景图片是一个有圆角矩形，因为BorderImage指令渲染用的背景图片board.png是第一章介绍过的9-patch图，类似于按钮是有的图形。 . &#26500;&#24314;&#25152;&#26377;&#26684;&#23376; . 我们的网格是二维的，通过两个for构建二维数组可以实现： . for x in range(4): for y in range(4): # code that uses cell at (x, y) . 这样的代码需要两次缩进不太好看，而且程序里面经常用到，这里我们用Python生成器来改善一下： . # In main.py def all_cells(): for x in range(4): for y in range(4): yield (x, y) . 这样每次用到的时候就直接调用函数即可： . for x, y in all_cells(): # code that uses cell at (x, y) . 这和在两个循环内执行代码基本一致，只是隐藏了细节，让代码更简洁，而且用起来更加灵活。 . 下面，我们就使用网格坐标board_x和board_y，这是用来定位每一个格子的，不是屏幕上的像素坐标。 . &#29983;&#25104;&#31354;&#26684;&#23376; . 网格的大小和位置都由Board部件决定，但是每个格子的位置是不确定的。下面，我们就计算每个格子在屏幕上的坐标值，并把它们在画布上画出来。 . 屏幕上的一个格子的位置需要考虑spacing，计算如下： . # In main.py class Board(Widget): def cell_pos(self, board_x, board_y): return ( self.x + board_x * (self.cell_size[0] + spacing) + spacing, self.y + board_y * (self.cell_size[1] + spacing) + spacing, ) . 画布操作通常都是绝对坐标值，所以我们计算的时候要增加Board的位置（self.x和self.y）。 . 现在我们重复算法就可以算出所有格子的位置，之后就是在画布上画出来。调整一下canvas.before就可以了： . from kivy.graphics import Color, BorderImage from kivy.utils import get_color_from_hex with self.canvas.before: BorderImage(pos=self.pos, size=self.size, source=&quot;board.png&quot;) Color(*get_color_from_hex(&quot;CCC0B4&quot;)) for board_x, board_y in all_cells(): BorderImage( pos=self.cell_pos(board_x, board_y), size=self.cell_size, source=&quot;cell.png&quot; ) . 渲染图片时，Color指令和第二章画图app里面取色功能一样：可以用同样的白色图片或者底色把每个方块涂成不同的颜色。 . 还要注意cell_pos和cell_size的使用——都是真实屏幕的坐标值。它们会随着窗口的尺寸改变而变化，经过计算再画到屏幕上。这里我们用更简单的board_x和board_y坐标。网格截图如下： . . &#32593;&#26684;&#25968;&#25454;&#32467;&#26500; . 根据游戏的设计思路，现在我们需要让网格保持一个自动的内部实现，要实现它，我们可以用一个简单的二维数组来表示： . [ [None, None, None, None], [None, None, None, None], [None, None, None, None], [None, None, None, None], ] . 这里None表示格子里面是空的，没有方块。这个数据结构可以通过嵌套的for循环来实现： . class Board(Widget): b = None def reset(self): self.b = [[None for i in range(4)] for j in range(4)] . 我们把reset()函数放在前面的位置，除了可以初始化游戏的状态，还可以在游戏失败之后生成一个新游戏。 . 这里，用Python的列表综合（list comprehension）并不是必须的；只是为了让代码显得紧凑点。如果你不喜欢这种方式，也可以用带缩进的两个带for语句来实现。 . &#21464;&#37327;&#30340;&#21629;&#21517;&#26041;&#24335; . 在这里，变量b是可以的，因为这个变量是类的属性，不会在API上用。后面的代码里还会经常出现这个变量，这么用可以少敲几次键盘。类似的做法还有在for循环里面用i和j。 . 在Python里面，私有属性一般在前面加一个下划线，_name。我们这么不这么用，因为这里变量很短，加下划线显得累赘。整个类都是在app内部使用，基本上就是一个独立的模块。 . 把Board.b当作是一个局部变量，尤其因为Board在我们的app里面是一个单独的部件：任何时候都应该只有一个实例。 . reset()&#20989;&#25968;&#35843;&#29992; . 在游戏初始化阶段应该调用Board.reset()来复位整个网格。做这件事的事件是on_start，如下所示： . # In main.py from kivy.app import App class GameApp(App): def on_start(self): board = self.root.ids.board board.reset() . &#31283;&#23450;&#24615;&#27979;&#35797; . 我们还没有为网格添加任何内容，但我们也写一个稳定性测试，can_move()。这个辅助函数用来测试是否我们可以把方块放在具体的格子里面。 . 这个测试有两部分。首先，我们需要保证坐标值都是可用的（不会超出网格），这部分检查放在valid_cell()函数里。然后，我们检查网格上的格子，看看它是不是空的（等于None）。如果可以移动过去，而且格子是空的就返回True，否则就返回False。代码如下： . # In main.py, under class Board: def valid_cell(self, board_x, board_y): return board_x &gt;= 0 and board_y &gt;= 0 and board_x &lt;= 3 and board_y &lt;= 3 def can_move(self, board_x, board_y): return self.valid_cell(board_x, board_y) and self.b[board_x][board_y] is None . 这些方法在实现方块移动的时候会用到，现在我们来创建方块。 . &#23454;&#29616;&#26041;&#22359; . 这节是介绍实现方块的Tile部件。方块比Board部件更动态化。我们要为Tile类创建一个Kivy属性，来实现方块因任何变化而引起的自动重新绘制。 . Kivy属性不同于Python的地方就是：Python的属性基本上就是绑定到一个类的实例上，可能再加上getter和setter函数。Kivy的属性还有一个功能，那就是它们发出的事件改变时，你就可以观察到有趣的属性，并相应调整其他相关变量，或者重绘屏幕。 . 这些工作绝大部分都是在自动完成的：让你做出一个改变，比如部件的pos或size属性，事件on_pos或on_size就被触发。 . 有趣的是，.kv文件里面的所有属性都是自动传播的。比如，你写了如下代码： . Label: pos: root.pos . 当root.pos属性改变时，pos值也发生了变化，它们会一直保持同步。我们创建Tile部件时要用这个特性。首先，我们声明渲染部件需要用到的属性： . # In main.py from kivy.properties import ListProperty, NumericProperty class Tile(Widget): font_size = NumericProperty(24) number = NumericProperty(2) # Text shown on the tile color = ListProperty(get_color_from_hex(tile_colors[2])) number_color = ListProperty(get_color_from_hex(&quot;776E65&quot;)) . 这就是我们画一个方块需要的代码；属性名称应该足够清楚了，color属性是方块的背景色，number属性是方块的显示的数值。 . 如果你们想现在就运行代码，请把tile_colors[2]替换成一个可用的颜色值，比如&#39;#EEE4DA&#39;，后面我们会实现这个列表。 . 然后，在game.kv里面，我们定义部件： . &lt;Tile&gt;:canvas: Color: rgb: self.color BorderImage: pos: self.pos size: self.size source: &#39;cell.png&#39; Label: pos: root.pos size: root.size bold: True color: root.number_color font_size: root.font_size text: str(root.number) . Label的后三个属性是自定义属性。canvas里面的self是指&lt;Tile&gt;，并不是canvas自己。这是因为canvas只是部件的一个属性。另外，Label是一个内嵌的部件，所以它用root.XXX来表示&lt;Tile&gt;的属性。这里，&lt;Tile&gt;是一个顶层的定义，所以可以运行。 . &#26041;&#22359;&#21021;&#22987;&#21270; . 在2048游戏里面，不同数值的方块颜色是不一样的，我们也要可以实现这种效果，这需要一个颜色-数值映射关系，下面是原始2048的颜色： . # In main.py colors = ( &quot;EEE4DA&quot;, &quot;EDE0C8&quot;, &quot;F2B179&quot;, &quot;F59563&quot;, &quot;F67C5F&quot;, &quot;F65E3B&quot;, &quot;EDCF72&quot;, &quot;EDCC61&quot;, &quot;EDC850&quot;, &quot;EDC53F&quot;, &quot;EDC22E&quot;, ) . 为了把颜色匹配到数值，可以用指数计算来实现： . tile_colors = {2 ** i: color for i, color in enumerate(colors, start=1)} . 这样就可以获得我们想要的效果了： . {2: &#39;EEE4DA&#39;, 4: &#39;EDE0C8&#39;, # ... 1024: &#39;EDC53F&#39;, 2048: &#39;EDC22E&#39;} . 颜色完成之后，我们就可以实现Tile类的初始化Tile.__init__方法了。 . class Tile(Widget): font_size = NumericProperty(24) number = NumericProperty(2) color = ListProperty(get_color_from_hex(tile_colors[2])) number_color = ListProperty(get_color_from_hex(&quot;776E65&quot;)) def __init__(self, number=2, **kwargs): super(Tile, self).__init__(**kwargs) self.font_size = 0.5 * self.width self.number = number self.update_colors() def update_colors(self): self.color = get_color_from_hex(tile_colors[self.number]) if self.number &gt; 4: self.number_color = get_color_from_hex(&quot;F9F6F2&quot;) . 简单解释一下： . font_size：设置成cell_size的一半，这是随意设置的。当然也不能放一个绝对字号在这里，因为屏幕传递尺寸是不统一的，所有最好的办法是保持字号的弹性 | number：方块的数值，默认值为2 | color：方块的背景色，是由前面number映射得到的 | number_color：这也是基于数值number的属性，但是变化更少。只有两种颜色，一种深色的用于浅色背景，一种浅色的用于亮色背景；因此需要检查if self.number &gt; 4 | . 其他的属性都是通过kwargs参数传递到父类的，包括位置和尺寸属性，下一小节会详述。 . 颜色值放在update_colors()辅助函数里面，因为合并方块的时候需要用到。 . 现在，你可以通过下面代码来创建一个方块： . tile = Tile(pos=self.cell_pos(x, y), size=self.cell_size) self.add_widget(tile) . 这样，一个新的方块就出现在屏幕上了。上面的代码应该在Board类里面。还要把self改成Board的一个实例。 . &#32553;&#25918;&#26041;&#22359; . 另一个关于方块的问题还没解决，就是需要让方块与网格等比例缩放。我们先做一个辅助函数来一次更新所有Tile属性： . class Tile(Widget): # Other methods skipped to save space def resize(self, pos, size): self.pos = pos self.size = size self.font_size = 0.5 * self.width . 经过这个方法不是必须的，但它可以让代码更简练。 . 真正的代码将被放Board.resize()方面的最后，将由绑定的Kivy属性触发。通过计算cell_size和cell_pos的新数值，把方法应用到所有的方块上： . def resize(self, *args): # Previously-seen code omitted for board_x, board_y in all_cells(): tile = self.b[board_x][board_y] if tile: tile.resize(pos=self.cell_pos(board_x, board_y), size=self.cell_size) . 这个方法和我们前面用的自动属性绑定方法完全相反：我们用一种中心化、明确的方式来重新放缩所有部件。有些人可能会发觉这种方法更容易读，少一些Python代码的神奇变化（比如，通过Python代码你可以在属性handler里面放置断点；Kivy的.kv文件里要是出错很难调试，只能等错误出来）。 . &#23454;&#29616;&#28216;&#25103; . 现在我们已经把各个模块都做出来了，下面就按照游戏的思路来实现它。我们需要生成方块、移动方块、合并方块。 . 生成方块就是在空格里面随机产生方块，思路如下： . 找出所有的空格 | 随机选择一个空格 | 在空格位置生成一个方块 | 把方块加到网格里（Board.b），然后用add_widget()把方块显示出来 | 生成方块的Python代码如下： . # In main.py, a method of class Board: def new_tile(self, *args): empty_cells = [(x, y) for x, y in all_cells() if self.b[x][y] is None] # Step 1 x, y = random.choice(empty_cells) # Step 2 tile = Tile(pos=self.cell_pos(x, y), size=self.cell_size) # Step 3 self.b[x][y] = tile # Step 4 self.add_widget(tile) . 在游戏开始和每次移动之后都会生成方块。马上我们就来实现移动方块，现在我们可以生成方块了： . def reset(self): self.b = [[None for i in range(4)] for j in range(4)] # same as before self.new_tile() self.new_tile() # put down 2 tiles . 如果你执行代码，你就会看到有两个方块随机出现在网格里。 . . &#31227;&#21160;&#26041;&#22359; . 要让方块移动更高效，我们需要把每一个输入事件映射到一个方向矢量中。然后，Board.move()方法接受这个矢量再重新排列网格。一个方向矢量是标准的（它的长度等于1），在我们的app里，我们只要把它加到方块目前的坐标值上，就可以获得方块的新位置。 . 2048游戏允许4个方向，所有映射函数很简单： . from kivy.core.window import Keyboard key_vectors = { Keyboard.keycodes[&quot;up&quot;]: (0, 1), Keyboard.keycodes[&quot;right&quot;]: (1, 0), Keyboard.keycodes[&quot;down&quot;]: (0, -1), Keyboard.keycodes[&quot;left&quot;]: (-1, 0), } . 这里的&#39;up&#39;，&#39;right&#39;，&#39;down&#39;和&#39;left&#39;是Kviy的键盘映射keycodes代码。 . 用Window.bind()就可以监听Kivy的键盘事件了： . # In main.py, under class Board: def on_key_down(self, window, key, *args): if key in key_vectors: self.move(*key_vectors[key]) # Then, during the initialization (in GameApp.on_start()) Window.bind(on_key_down=board.on_key_down) . Board.move()方法就可以调用了。它接受方向矢量的dir_x和dir_y值，从key_vectors[key]里面获取，*args就是依次获取元组、列表的元素作为参数。 . &#25511;&#21046;&#36845;&#20195;&#22120;&#24207;&#21015; . 在实现Board.move()方法之前，我们需要做一个all_cells()生成器函数；正确的迭代顺序依赖于移动的方向。 . 比如，当向上移动的时候，我们要从最上面第一的格子开始。这样我们就可以确保所有的方块都可以紧密的排列到最上方。如果迭代的方式不对，网格里面就会看到洞，因为下面的格子没有正确的移动到最上方的空格子里。 . 正确迭代的代码如下： . def all_cells(flip_x=False, flip_y=False): for x in reversed(range(4)) if flip_x else range(4): for y in reversed(range(4)) if flip_y else range(4): yield (x, y) . &#23454;&#29616;move()&#26041;&#27861; . 这样，我们就可以实现最简单版本的Board.move()函数了。现在，我们只能移动方块，马上我们就把合并功能也加上。 . 这是移动方块的思路： . 遍历所有存在的方块 | 对每个方块都沿着指定的方向向前移动到底 | 如果方块的坐标值不再变化，再到下一个方块 | 把方块转换到新的坐标值，再到下一个方块 | Python代码实现如下： . def move(self, dir_x, dir_y): for board_x, board_y in all_cells(dir_x &gt; 0, dir_y &gt; 0): tile = self.b[board_x][board_y] if not tile: continue x, y = board_x, board_y while self.can_move(x + dir_x, y + dir_y): self.b[x][y] = None x += dir_x y += dir_y self.b[x][y] = tile if x == board_x and y == board_y: continue # nothing has happened anim = Animation(pos=self.cell_pos(x, y), duration=0.25, transition=&quot;linear&quot;) anim.start(tile) . 这里的can_move()函数我们前面已经做过。 . 这个Animation的API和浏览器里面的CSS变换效果一样。我们需要提供： . 我们想变换的属性值（这里是pos） | 变换持续时间（） | 变换类型（&#39;linear&#39;表示变换的速度不变） | . 这样，Kivy就可以将一个部件普从一个状态平滑的变换成另一个状态。 . Kivy提供了很多变换类型，具体可以参考文档。 . &#32465;&#23450;&#35302;&#25720;&#25511;&#20214; . 除了键盘绑定，然我们在增加一个触摸控件绑定。由于鼠标输入事件和Kivy的触摸功能一样，我们的代码同样可以支持鼠标操作。 . 我们需在Board类中增加一个事件handler： . from kivy.vector import Vector # A method of class Board: def on_touch_up(self, touch): v = Vector(touch.pos) - Vector(touch.opos) if v.length() &lt; 20: return if abs(v.x) &gt; abs(v.y): v.y = 0 else: v.x = 0 self.move(*v.normalize()) . 要让Board.move()运行，我们得把每一个手势都转换成一个单位矢量。代码解释如下： . if v.length() &lt; 20：检查手势移动是否足够长。如果移动距离特别短，就当成是点击或者切换，不算移动 | if abs(v.x) &gt; abs(v.y)：手势的横坐标和纵坐标比较，把较小的坐标设为0，方向就沿着较大坐标那一侧 | 把矢量标准化，然后提供给Board.move() | 最后一点充分解释了为什么你不能用自己的方式随意实现像方向这样的数学表达式。 . &#21512;&#24182;&#26041;&#22359; . 现在把同样数值方块相加合并成另一个，代码实现很容易。我们建一个新的辅助函数can_combine()，与can_move()类似，这个函数返回True如果我们可以把当前的方块与一个位置上的方块合并，如果坐标值是一样的，而且方块的数值相同。 . 这就是实现的方法。如果与can_move()对比，会发现基本一样： . def can_combine(self, board_x, board_y, number): return ( self.valid_cell(board_x, board_y) and self.b[board_x][board_y] is not None and self.b[board_x][board_y].number == number ) . 我们可以为Board.move()实现方块合并的功能了。 . 就是把下面的代码加到while self.can_move()后面： . if self.can_combine(x + dir_x, y + dir_y, tile.number): self.b[x][y] = None x += dir_x y += dir_y self.remove_widget(self.b[x][y]) self.b[x][y] = tile tile.number *= 2 tile.update_colors() . 这段代码把移动方块那部分也加进来了，不过这里用remove_widget()来移除被组合的方块，然后把新方块的数值翻倍，同时把对应的颜色也调整过来。 . 这样，我们的方块组合就完成了。现在游戏已经还不能玩，我们还要增加一些。 . &#22686;&#21152;&#26041;&#22359; . 每一轮结束之后，我们还要生成新的方块。要完成这样，生成新方块需要在方块合并序列的末尾，在上一轮方块完成移动的时候。 . 好在有一个合适的事件Animation.on_complete可以解决问题。由于我们同时运行了很多数值相等的方块的合并，我们就只需要把事件绑定第底一个Animation实例上——它们都是同时运行的，有相同的持续时间，所有在同时批量处理第一个和最后一个合并时不应该有明显的时间差。 . 这个实现和我们前面的Board.move()方法类似： . def move(self, dir_x, dir_y): if self.moving: return dir_x = int(dir_x) dir_y = int(dir_y) for board_x, board_y in all_cells(dir_x &gt; 0, dir_y &gt; 0): tile = self.b[board_x][board_y] if not tile: continue x, y = board_x, board_y while self.can_move(x + dir_x, y + dir_y): self.b[x][y] = None x += dir_x y += dir_y self.b[x][y] = tile if self.can_combine(x + dir_x, y + dir_y, tile.number): self.b[x][y] = None x += dir_x y += dir_y self.remove_widget(self.b[x][y]) self.b[x][y] = tile tile.number *= 2 if tile.number == 2048: print(&quot;You win the game&quot;) tile.update_colors() if x == board_x and y == board_y: continue # nothing has happened anim = Animation(pos=self.cell_pos(x, y), duration=0.25, transition=&quot;linear&quot;) if not self.moving: anim.on_complete = self.new_tile self.moving = True anim.start(tile) . 一旦合并结束，on_complete事件都触发，new_tile()就被调用，游戏继续。 . 这里使用一个布尔值moving是为了保证new_tile()不会在一轮被调用两次。如果不检查，就可能网格立刻被堆满。 . &#21516;&#27493;&#22238;&#21512; . 你可能已经发现，在当前实现的方块合并部分有一个bug：玩家可以在前面一轮还没结束之前启动新一轮。解决这个bug最简单的方法就是增加移动方块的持续时间，比如设置成10秒： . # This is for demonstration only anim = Animation(pos=self.cell_pos(x, y), duration=10, transition=&quot;linear&quot;) . 这种解决方法忽略了在方块已经准备生成后move()调用的顺序。要考虑这些就要增加前面用过的moving。现在，它要成为Board类的属性。另外，还有调整一些代码： . class Board(Widget): moving = False def move(self, dir_x, dir_y): if self.moving: return # ...... anim = Animation( pos=self.cell_pos(x, y), duration=0.25, transition=&quot;linear&quot; ) if not self.moving: anim.on_complete = self.new_tile self.moving = True anim.start(tile) . 别忘了在new_tile()里面把moving设置成False，否则在第一轮之后其他的方块会被移除。 . &#28216;&#25103;&#32467;&#26463; . 还有一件事就是游戏结束的处理。在本章开始的时候我们讨论过赢与输的条件，所以这里我们用同样的逻辑来实现它们。 . &#28216;&#25103;&#32988;&#21033;&#30340;&#24773;&#20917; . 测试玩家是否已经到达2048很简单，就是找出Board.move()函数里面是否出现一个合并成2048的方块： . tile.number *= 2 if tile.number == 2048: print(&quot;You win the game&quot;) . 这里把赢得游戏的UI设计忽略了，你可以做一个好看的界面来表达胜利的喜悦，自己试试看吧。 . 另外，如果要测试，建议把难道调低，可以把2048改成64，这样测试起来方便。 . &#28216;&#25103;&#22833;&#36133;&#30340;&#24773;&#20917; . 游戏失败的算法有点复杂，当然可以用不同的方式来表达。最简单的方式就是在每次移动之前遍历整个网格，查看方块是否死锁了： . def is_deadlocked(self): for x, y in all_cells(): if self.b[x][y] is None: return False # Step 1 number = self.b[x][y].number if self.can_combine(x + 1, y, number) or self.can_combine(x, y + 1, number): return False # Step 2 return True # Step 3 . 我们需要对网格中的每一个方块进行以下测试： . 如果发现空格子，这就意味着没死锁——其他的方块可以移动到这里 | 否则，如果方块还可以合并，那么游戏继续 | 如果以上测试都失败了，我们不能发现任何一个方块满足以上测试，那么游戏失败 | . 在new_tile()里面实现这些测试比较合适： . def new_tile(self, *args): empty_cells = [(x, y) for x, y in all_cells() if self.b[x][y] is None] # 生成一个新方块（忽略） if len(empty_cells) == 1 and self.is_deadlocked(): print(&quot;Game over (board is deadlocked)&quot;) self.moving = False # 看前面的“回合同步” . 前置条件len(empty_cells) == 1可以减少检查的次数，如果还有空格就不检查。需要注意这时is_deadlocked()方法可能就是返回False，因此这就是一个优化，不会影响游戏的运行。 . 这也是一个次优的，性能优先，可以继续改进的方法，代价是代码变长了。还有个优化方法就是跳过最后一行和一列，这样每次迭代时就不用检查边界，就是can_combine()做的事情。 . 但是，在这里使用效果可以忽略，因为每一轮都至少有一次检查，我们大部分时间都在等玩家完成操作。 . &#19979;&#19968;&#27493;&#35745;&#21010; . 游戏这下可以玩了，不过还有很多值得值得改进。如果你想进一步完善2048，可以参考下面的建议： . 增加更多动画——它们可以重新出更强的交互性 | 增加一个记分板，可以保持分数，然后传递到服务器端，形成高分榜 | 改造游戏规则，做成其他类似2048的游戏 | 做一个算法来提前预测游戏结果。比如提示玩家，“不管怎么玩，再玩7轮就GAME OVER了，谢谢参与” | 彻底改变规则，增加一个多玩家PK模式如果你想看更复杂的2048游戏，可以看这里。这个项目由Kivy的核心开发者Mathieu Virbel创建，整合了Google Play，最佳成绩，高分榜等等 &gt;读其他人的代码是学习编程的好方法。 . | . &#24635;&#32467; . 这一章，我们重建了2048游戏。也展现了许多其他项目里可以重用代码的实现细节: . 创建一个可缩放的面板，适应任意分辨率、任意方向的屏幕 | 通过Kivy的Animation的API来实现平滑移动 | 同时实现触摸屏手势和键盘方向键控制方向的功能 | . 可见，Kivy框架可以很好的支持游戏开发，画布渲染和动画支持在开发视频游戏是更加重要。Kivy的原型设计也很容易，虽然比JavaScript要难一点（现代浏览器是非常强大的平台，在快速原型方面基本不可能被打败）。 . 如果你不使用某个平台的系统级API，Python的跨平台能力依然闪亮。也就是说，你的游戏可以在任何平台上运行，让更多的玩家参与。 . Kivy也不会和主流的应用发布平台冲突，可以在Apple AppStore，Google Play，甚至Steam上发布。 . 当然，与成熟的游戏引擎像Unreal Engine或Unity相比，Kivy缺少很多特性和大多数交叉编译工具链。这是由于Kivy是一个一般目的的UI框架，并不是专业的游戏引擎；把不同类别的软件进行比较是不太合理的。 . 总之，Kivy在偶尔独立开发游戏时是个不错的选择。愤怒的小鸟就曾通过Python和Kivy来实现，想想咱们错过的机会多大啊。（不过也不要沮丧，这更是一种鼓励。Rivio的游戏道理也不是一番风顺的。） . 下一章我们打算用Kivy写一个街机游戏。它将以一种非常规的方式，用类似Kivy部件的概念来创建一个交互的横向卷轴模式（Side-Scrolling），源自另一块流行的、单人开发的休闲游戏，飞翔的小鸟（Flappy Bird）。 .",
            "url": "/Kivy/jupyter/kivy/android/ios/2019/07/01/kivy-ch6-2048-app.html",
            "relUrl": "/jupyter/kivy/android/ios/2019/07/01/kivy-ch6-2048-app.html",
            "date": " • Jul 1, 2019"
        }
        
    
  
    
        ,"post11": {
            "title": "Kivy指南-5-远程桌面app",
            "content": "本章做一个远程桌面app，依然和网络相关。我们用“真正的”应用层协议进行通信，解决一个复杂的问题。 . 简单介绍一下：首先我们的目的是实现一个经典的桌面应用——远程连接，允许用户通过网络操纵其他电脑。这类应用在技术支持和远程协助中使用广泛。 . 其次，介绍两个术语：主机（host machine）是远程控制者（运行远程控制服务器），客户机（client）是主机控制的系统。远程系统管理基本上就是这样的用户交互过程，主机把客户机当作代理来使用。 . 因此，关键的两个步骤就是： . 收集客户机用户的输入（如鼠标和键盘动作），并应用到主机 | 从主机向客户机发送任何输出（最常见的是截屏，还有声频、视频等） | . 远程桌面就是这两个步骤的不断重复。很多商业软件都会实现这些功能，有一些甚至允许运行视频游戏——通过图形和游戏控制器加速。我们准备实现的一些功能如下： . 用户的输入只支持鼠标点击或Tab切换 | 输出只有屏幕截图，因为通过网络抓取声音比较复杂 | 主机只支持Windows平台，任何桌面版本都行。客户端没有限制，因为Kivy app哪儿都可以运行 | . 最后一条实在遗憾，因为不同的系统截屏和模拟点击行为的API不同，我们只能选择最流行的系统来实现。其他平台的支持以后会实现，原理都一样。 . 中国用户可以忽略这条：如果没Windows，自己找虚拟机安装一个。Mac上也可以用Parallers安装，就是要换点钱。 . 本章教学大纲如下： . 用Python的Flask微框架写一个HTTP服务器 | 用PIL（Pillow）实现截屏 | 用WinAPI功能模拟Windows点击 | 做一个简单的JavaScript客户端原型，用它来测试 | 做一个基于Kivy的HTTP客户端app连接到远程桌面服务器 | . &#26381;&#21153;&#22120; . 为了方便测试和使用，我们希望用容易实现的应用层协议做服务器。我们选择HTTP，要容易实现和简单测试，需要具体两个特征： . 支持很多特性，包括服务器端和客户端。HTTP是最流行的协议，完全符合。 | 与其他协议不同，使用HTTP协议，我们可以用JavaScript轻易写出一个可以在浏览器上运行的客户端。这和本书的主题关系不大，但是依然是一个流行的做法 | . 建服务器的模块，我们用Flask，Django更流行，不过太大材小用了。要安装Flask，直接用pip安装即可： . pip install Flask . 简单高效，完全开源，文档详细，推荐学习一下。 . Flask&#26381;&#21153;&#22120; . 服务器通常就是由一系列绑定到不同URL的handler组成的。这些绑定通常叫做路由（routing）。Flask可以非常容易的实现这些功能。我们建立一个网页的服务器server.py： . from flask import Flask app = Flask(__name__) @app.route(&quot;/&quot;) def index(): return &quot;Hello, Flask&quot; if __name__ == &quot;__main__&quot;: app.run(host=&quot;0.0.0.0&quot;, port=7080, debug=True) . 在Flask里面，路由是以修饰器方式实现的，如@app.route(&#39;/&#39;)，在URL比较少的时候这么做很方便。 . &#39;/&#39;路由是服务器域名，对应一个IP地址。运行server.py后，在浏览器打开http://127.0.0.1:7080，看到Hello, Flask说明服务器ok了。 . . 这里，app.run()里面的参数0.0.0.0不是一个有效的IP地址，不能通过正常访问。服务器绑定这个IP表示我们的app会监听所有IPV4接口——也就是说，从任何一个可用的IP发出的请求都会得到相应。 . 这和默认设置（localhost，127.0.0.1）不同。localhost的IP只允许监听同一个机器传来的请求。因此，这个IP适合调试和测试用。但是，当我们发布产品后，0.0.0.0就是面向世界，开张圣听。不过，注意这不会自动绕过路由器；它可以在你的局域网工作，但是在公网工作可能需要其他配置。 . 还有，记得设置防火墙策略，因为它需要满足应用层设置的优先级。 . 端口选择 . 用哪个端口并不重要，重要的是服务器和客户端要用同一个端口，无论是一个浏览器还是一个Kivy app。 . 还要注意，几乎所有的系统中1024以下的端口一般只能由授权用户使用（root或admin）。而且很多端口已经分配了固定用途，所以建议选择1024以上的端口。 . 默认的HTTP端口是80，默认端口通常不需要指定，http://www.w3.org和http://www.w3.org:80/是一样的。 . 你可能发现Python开发实在太容易了——几行代码就可以运行一个服务器。不过，不是样样都很简单，有些事情还不能立竿见影。 . 这是Python的优势：如果你要实现一些不太复杂的功能，试试Python吧，通常都会取得好效果。 . &#26381;&#21153;&#22120;&#26032;&#21151;&#33021;&#8212;&#8212;&#25130;&#23631; . 协议和服务器实现之后，我们来做截屏和模拟点击功能。这里仅实现Windows的实现，Mac和Linux支持可以做练习。 . PIL可以实现，用PIL.ImageGrab.grab()就行，我们把截图保存为RGB格式。之后就是把图片接到Flask上，这样就可以通过HTTP传送了。 . PIL已经不再维护了，现在有Pillow实现PIL，直接用pip安装即可，具体参阅文档。 . pip install Pillow . 实现的代码如下： . from flask import send_file from PIL import ImageGrab from StringIO import StringIO # # more compatible # try: # from StringIO import StringIO # python2 # except ImportError: # from io import BytesIO as # python3 @app.route(&quot;/desktop.jpeg&quot;) def desktop(): screen = ImageGrab.grab() buf = StringIO() screen.save(buf, &quot;JPEG&quot;, quality=75) buf.seek(0) return send_file(buf, mimetype=&quot;image/jpeg&quot;) . 这里StringIO是把内容存在内存，不是磁盘上。使用API处理临时数据的时候这种“虚拟文件”很有用。本例中，我们不想要保存截屏内容，就是一个临时文件。如果连续下载文件到磁盘上效率很低，不如直接放到内存里，用完就释放。 . 代码很简单，就是用PIL.ImageGrab.grab()截屏叫screen，然后用screen.save()保存为JPEG格式，这样省流量一些，最后用MIME type形式&#39;image/jpeg&#39;发送到Flask，这样就可以直接现在在浏览器上了。 . 为了实现更好的速度，用比分辨率的图片更合适，因为每一个帧都要截图是很费流量的。 . 这里又一次充分证明了一点：验证新概念或市场研究时，快速原型是多么高效。 . buf.seek(0)是为了倒回（rewind）StringIO实例；否则，程序就到了数据的最后，不会给send_file()发送任何数据了。 . 现在就可以测试效果了，打开http://127.0.0.1:7080/desktop.jpeg就会看到当前屏幕的截图了。 . 这里的路由很有意思&quot;desktop.jpeg&quot;，URL的最后是文件曾经在服务器工具里面是一种习惯，像Personal Home Page (PHP)，一种适合做简单的网站的简单编程语言。其实这里并没有路径的概念，你实际上只要把文件的名称输入地址栏然后从服务器获得它。 . 这么做是很不安全的行为，远程连接者可以看到服务器的配置，比如&#39;/../../etc/passwd&#39;输入地址栏就可以看到密码了，之后的各种木马病毒像Trojans木马（后门）就来了。 . Python的网页服务器都经历过这些教训。你也可以这么写，但是强烈不推荐，这样太危险了。另外，Python的模块通常默认也不会使用这些配置。 . 今天，从文件系统直接获取文件的事情并不是没有，但主要是用于静态文件。另外，有时我们也会把动态网页（如/index.html，/desktop.jpeg等）也写成文件名的形式是为了让用户更容易明白这些URL的作用。 . &#27169;&#25311;&#28857;&#20987;&#34892;&#20026; . 截屏部分完成之后，我们需要实现的功能就是鼠标点击，用WinAPI可以实现，不过很麻烦，我们用Python的ctypes模块来做。 . 首先我们需要从URL或者点击的坐标。我们用GET方式来实现：/click?x=100&amp;y=200，这种方法容易在浏览器测试，不像POST和其他HTTP方式需要其他工具来测试。 . Flask支持这种URL带参数的方式： . from flask import request @app.route(&quot;/click&quot;) def click(): try: x = int(request.args.get(&quot;x&quot;)) y = int(request.args.get(&quot;y&quot;)) except TypeError: return &quot;error: expecting 2 ints, x and y&quot; . 建立原型的时候在可能出错的地方加异常处理代码是必要的，因为经常会忘记或发送了不合理的参数，所以我们要做异常处理，所有我们需要检查GET请求的参数是否可用。调试的时候如果出现错误就会显示信息，这样就知道问题出在哪里了。 . 有了点击的坐标之后，我们就要用WinAPI来调用它们。这里需要两个函数都在user32.dll：SetCursorPos()是设置鼠标光标的位置，mouse_event()模拟鼠标的点击事件，比如按下或松开按键。 . user32.dll这个32和你系统的32位或64位没关系。Win32 API首次出现在 Windows NT，比之后的AMD64 (x86_64)架构早7年多，之所以这Win32是为了和之前的Win16区分。 . mouse_event()的第一个参数是事件类型，一个C语言枚举类型（一组整型常量）。我们可以在Python里面定义这些常量，用常量2表示鼠标按下，4表示鼠标松开并不是很直观。可以这样： . import ctypes # this is the user32.dll reference user32 = ctypes.windll.user32 MOUSEEVENTF_LEFTDOWN = 2 MOUSEEVENTF_LEFTUP = 4 . Win API文档可以到Microsoft Developer Network (MSDN)去查：SetCursorPos()，mouse_event()。 限于篇幅不做详细介绍，而且也不会有到很多功能；WinAPI可谓包罗万象，内容十分丰富，感兴趣自行研究。 . 模拟点击的代码如下： . @app.route(&quot;/click&quot;) def click(): try: x = int(request.args.get(&quot;x&quot;)) y = int(request.args.get(&quot;y&quot;)) except: return &quot;error&quot; user32.SetCursorPos(x, y) user32.mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0) user32.mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0) return &quot;done&quot; . 代码很直白，就是设置鼠标位置，然后单击一下（按下，松开）。 . 现在你可以启动Flask的服务器然后试试点击操作，可以在地址栏输入http://127.0.0.1:7080/click?x=10&amp;y=10，如果左上角（10，10）这个位置有图标，图标会被选中。 . 当然也可以实现一个双击行为，如果页面刷新的足够快的话（因为打开文件时屏幕变化很大，需要截取很多图片），这可能需要在另外一个设备上运行浏览器，记得修改对应的服务器IP地址。 . JavaScript&#23458;&#25143;&#31471; . 在这一章，我们将尝试一下JavaScript远程桌面客户端，因为我们用的是HTTP协议，JavaScript非常合适。这个简单的客户端可以在浏览器运行，作为Kivy客户端桌面应用的原型。 . 如果你不熟悉JavaScript，不用担心，其语法很简单，与Python很相似。我们还要用到jQuery来处理DOM表和AJAX。 . 很多人可能不赞成在产品设计阶段使用jQuery，尤其是对那些性能要求高的应用。但是，要实现网页app的快速原型，jQuery还是很不错的，因为它用法简单，实现高效。 . 做网页app，我们得把原来的Hello, Flask替换成。 . &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Remote Desktop&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=&quot;//code.jquery.com/jquery-1.11.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // code goes here &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; . Flask要使用这个HTML，需要对index()做一点调整： . @app.route(&quot;/&quot;) def index(): return app.send_static_file(&quot;index.html&quot;) . 这和前面的desktop()函数是一样的，不过是从硬盘读取HTML文件再显示。 . &#25130;&#23631;&#30340;&#26080;&#38480;&#24490;&#29615; . 现在，让我们展示一个连续的屏幕显示方案：我们的程序每两秒请求一个截屏，然后立刻向用户显示出来。因为我们写的是网页应用，所有的复杂情况都由浏览器处理：用&lt;img&gt;标签加载图片显示到屏幕上。实现步骤如下： . 删除旧的&lt;img&gt;标签，如果有的话 | 增加一个新的&lt;img&gt;标签 | 每2秒重复一次 | 用JavaScript实现如下： . function reload_desktop() { $(&#39;img&#39;).remove() $(&#39;&lt;img&gt;&#39;, {src: &#39;/desktop.jpeg?&#39; + Date.now()}).appendTo(&#39;body&#39;) } setInterval(reload_desktop, 2000) . 代码解释如下： . $()是jQuery选择网页元素的函数，我们可以在元素上实现各种操作，如.remove()或.insert() | Date.now()返回当前时间戳，就是1970年1月1日到当前时间的毫秒数。我们用这个数据来阻止缓存，这样每次的信息就会更新了。 | . 让我们把图片的调整为适合浏览器的尺寸，去掉所有的边距。用CSS也很容易实现： . &lt;style&gt; body { margin: 0 } img { max-width: 100% } &lt;/style&gt; . 应用的截图如下所示： . . 加载的时候你会发现图片在闪烁，因为在完全加载之前就立刻显示desktop.jpeg。还有一个问题就是下载频率是固定的，我们随意设定为两秒。由于网速的原因，用户可能还没看到图片加载完成就又改变了。 . 这里只是原型，在Kivy设计的时候我们会纠正这个问题。 . &#25226;&#28857;&#20987;&#20256;&#22238;&#20027;&#26426; . 下面我们要把&lt;img&gt;截图上的点击传给服务器。对&lt;body&gt;元素使用.bind()方法可以实现。因为我们不断的增删元素，图片上绑定的内容在更新后会丢失，而重新绑定也没必要。 . function send_click(event) { var fac = this.naturalWidth / this.width $.get(&#39;/click&#39;, {x: 0|fac * event.clientX, y: 0|fac * event.clientY}) } $(&#39;body&#39;).on(&#39;click&#39;, &#39;img&#39;, send_click) . 这里我们计算了点击的真实位置：通过图片缩放比例对坐标位置进行调整。 . $$x,y_{server} = frac {width_{natural}}{width_{scaled}} times x,y_{client}$$ . JavaScript里面的0|expression表达式是Math.floor()的另外一种形式，更快更精确，只是语法有点差异。 . 然后用jQuery的$.get()函数把前面计算的结果发给服务器。由于我们打算立刻显示一个新截屏，所以就没有对服务器响应进行处理——如果我们最后一个动作有任何变化，都会立即显示出来。 . 用这个远程桌面原型，我们已经可以看到桌面，执行机器上的程序了。现在，让我们用Kivy来实现这个原型，同时做些改进，增加滚动条、去掉屏幕闪烁，让它更适用于移动设备。 . Kivy&#36828;&#31243;&#26700;&#38754;app . 我们可以重用上一章聊天app的一些功能。这里个应用很相似，都是由两个屏幕构成，一个屏幕是带服务器地址的登录界面。我们就把chat.kv文件改造成remotedesktop.kv文件，里面的ScreenManager保留。 . &#30331;&#24405;&#30028;&#38754; . 就是下面的代码，包含三个部分——标题、输入文本框、登录按钮——位于屏幕的顶部： . Screen: name: &#39;login&#39; BoxLayout: orientation: &#39;horizontal&#39; y: root.height - self.height Label: text: &#39;Server IP:&#39; size_hint: (0.4, 1) TextInput: id: server text: &#39;10.211.55.5&#39; # put your server IP here Button: text: &#39;Connect&#39; on_press: app.connect() size_hint: (0.4, 1) . 只要一个输入文本框Server IP。其实你也可以用服务器名称，但是这需要配置，直接IP省事儿。 . 虽然用IP地址不是很直观，但是我们暂时没更好的选择。要做一个自动发现的网络服务来避免IP地址，用着更舒服，但是也更复杂（需要一大堆技术来实现）。 . 这里，需要掌握基本的网络技能，比如把设备连接到路由器。这些都超出本文的范围，简单说下： . 当你所有的设备都连接到同一网络是测试更容易 | 通一台设备上使用虚拟机来测试也行。这样可以避开扫描网络、输密码、连线等等操作。 | 要看设备的IP地址，用ipconfig(Windows)或ifconfig。公网IP不会显示出来，但局域网IP会显示。 | . 登录窗口很简单，前面已经学习过，下面让我们来实现远程桌面窗口。 . &#36828;&#31243;&#26700;&#38754;&#31383;&#21475; . 这个屏幕界面应该有二维的滚动条，可以在不同屏幕上选择位置。我们还按照上一章聊天app的滚动条来实现。不同的是：这里是二维的，这次我们不想让让任何超限再触底反弹的效果以避免冲突，操作系统桌面通常不需要这些效果。 . 这个屏幕的remotedesktop.kv文件如下： . Screen: name: &#39;desktop&#39; ScrollView: effect_cls: ScrollEffect Image: id: desktop nocache: True on_touch_down: app.send_click(args[1]) size: self.texture_size size_hint: (None, None) . 在ScrollView里，我们effect_cls: ScrollEffect来禁止超限行为。如果你想要这种行为，可以不用这行。由于ScrollEffect不是默认存在的，需要导入： . #:import ScrollEffect kivy.effects.scroll.ScrollEffect . 关键点是把Image的size_hint属性设置为(None, None)；否则Kivy就会自动放缩图片来适合屏幕尺寸，这样滚动条就没用了，而且在不同比例的屏幕上，桌面会失真。设置为None表示要是手动调节。 . 之后，我们把size属性设置成self.texture_size。这样就可以把服务生成的desktop.jpeg的尺寸传递到屏幕了（这是有主机的屏幕决定的，我们不能改变）。 . 还有nocache: True属性，是让Kivy取消缓存，不要保存截图的临时文件。最后，Image的on_touch_down属性。我们想传递精确的坐标值和触摸事件的其他属性，就得用args[1]。args[0]是要点击的部件，也就是图片本身（我们只有一个Image实例，所以不需要把它传递到事件handler）。 . &#25130;&#23631;&#22312;Kivy&#37324;&#30340;&#24490;&#29615; . 现在让我们把前面这些模块集成到Python里。和JavaScript实现相反，我们不用加载图片和相关的功能，所以要写点儿代码；不过这些很容易实现，而且更容易维护。 . 为了异步加载图片，我们要用Kivy的Loader类，实现思路如下： . 当用户填好Server IP，在登录窗口点击Connect后，RemoteDesktopApp.connect()函数启动 | 它把控制传递到reload_desktop()，这个函数会从/desktop.jpeg下载图片 | 图片加载之后，Loader调用desktop_loaded()，把图片展示到屏幕上，然后调用下一个reload_desktop()。这样我们就通过异步方式实现了截屏的循环 | 下面是main.py文件实现代码： . from kivy.loader import Loader class RemoteDesktopApp(App): def connect(self): self.url = &quot;http://%s:7080/desktop.jpeg&quot; % self.root.ids.server.text self.send_url = &quot;http://%s:7080/click?&quot; % self.root.ids.server.text self.reload_desktop() . 我们保持url（服务器IP和/desktop.jpeg）和send_url（服务器IP和/click），然后传递RemoteDesktopApp.reload_desktop()函数： . def reload_desktop(self, *args): desktop = Loader.image(self.url, nocache=True) desktop.bind(on_load=self.desktop_loaded) . 前面函数就是下载图片。图片下载完之后，就把图片加载到RemoteDesktopApp.desktop_loaded()。 . 不用忘了用nocache=True禁止缓存，没有这点桌面就只会加载一次，因为URL是一样的。在JavaScript里面，我们解决这个问题是把?timestamp放在URL之后，在Python我们可以不这样做，因为Kivy支持缓存控制功能。 . 然后就可以完成桌面加载程序了： . from kivy.clock import Clock def desktop_loaded(self, desktop): if desktop.image.texture: self.root.ids.desktop.texture = desktop.image.texture Clock.schedule_once(self.reload_desktop, 1) if self.root.current == &quot;login&quot;: self.root.current = &quot;desktop&quot; . 函数接收新图片desktop，更新屏幕，然后每1秒循环一次。 . 在第一章的时钟app里面，我们讨论过Clock对象的更新问题，当时是用schedule_interval()，类似于JavaScript的setInterval()，这里我们想要持续状态，类似于JavaScript的setTimeout()功能。 . 现在屏幕更新就实现了，截图如下所示： . &#20256;&#36865;&#28857;&#20987; . 远程桌面已经完成，下面我们实现点击行为，这就需要监听图片的on_touch_down事件，把触摸的坐标值传递到send_click()函数。在remotedesktop.kv文件里面： . Screen: name: &#39;desktop&#39; ScrollView: effect_cls: ScrollEffect Image: on_touch_down: app.send_click(args[1]) # The rest of the properties unchanged . 在Python的class RemoteDesktopApp中实现send_click()函数： . def send_click(self, event): params = {&quot;x&quot;: int(event.x), &quot;y&quot;: int(self.root.ids.desktop.size[1] - event.y)} urlopen(self.send_url + urlencode(params)) . 这里需要注意的是坐标值：在Kivy里面，y轴是向上的，和数学上的概念一致，而Windows和浏览器里面都是向下的。所以我们用桌面高度event.y来转换。 . 另一个容易出错的就是Python的urllib模块，Python2和Python3的差别很大，也可以用requests模块，不过这里用标准模块。可以通过异常处理开解决版本问题： . try: # python 2 from urllib import urlencode except ImportError: # python 3 from urllib.parse import urlencode try: # python 2 from urllib2 import urlopen except ImportError: # python 3 from urllib.request import urlopen . 虽然代码不是很简洁，但是可以实现兼容性，目前只能这样。连Guido老爹（Python创始人）现在也这么写，还能说啥呢。 . &#21518;&#32493;&#20219;&#21153; . 现在我们的远程桌面app就搞定了，建议在局域网和网速快的时候使用。当然，还有很多问题需要解决，很多新特性可以加入，如果你感兴趣，下面是一些努力的方向： . 把鼠标行为作为单独事件处理，可以实现双击、拖拽等 | 考虑网络延迟。如果用户网速很慢，你可以把图片质量降低来保证流畅性，给用户一个选择 | 让服务实现跨平台，包括Mac，Linux，Android和Chrome OS | . 另外，这是一个工业级强度的任务，做这种软件很难，更不用说让它完美，具有极快的速度。Kivy帮你在UI设计、图片下载和缓存处理方面省了很多精力，但也只能做这些了。 . 所有，如果有些功能无法很快实现，请不要担心——错误和失败都是正常的，可以深入学习一些计算机间相互通信的知识。 . &#24635;&#32467; . 这就远程桌面app的所有内容。这个app可以处理一下简单任务，比如点击iTunes里面的Play按钮，或者关闭一个程序。更复杂的任务，尤其是一些运维工作时，可能需要更专业的软件。 . 我们用Flask建立了服务器实现了对图片的动态处理，主机系统的交互。我们还做了一个轻量级的JavaScript客户端实现了想要的功能，这说明我们的Kivy app并不是非主流方法。而且，在写Kivy代码之前，我们就有了服务器和客户端原型。 . 这个原型帮助我们快速实现了我们的想法，可以立刻看到实现的效果。这里不打算讨论测试驱动开发（test-driven development，TDD），它是否成熟值得商榷，也不论事件驱动编程对这个案例是否有益。但是先做好每一个部分，然后把它们组合在一起，这种分而治之的方法还是比一下子写一个整体要更有效率。 . 最后，Kivy也能很好的处理网络GUI app。比如，上一章里面与Twisted协作，实现通过网络加载内容的功能——这些都为建立多用户的网络app提供了极大帮助。 . 现在，让我们进入另一个领域：Kivy游戏开发。 .",
            "url": "/Kivy/jupyter/kivy/android/ios/2019/06/01/kivy-ch5-remote-desktop-app.html",
            "relUrl": "/jupyter/kivy/android/ios/2019/06/01/kivy-ch5-remote-desktop-app.html",
            "date": " • Jun 1, 2019"
        }
        
    
  
    
        ,"post12": {
            "title": "Kivy指南-4-Kivy网络编程",
            "content": "前面我们尝试过单一平台Android的Kivy开发，通过原生的底层API来实现。下面我们探索另外一种天生具有跨平台能力的工具来做app——网络。在这一章，我们做一个聊天app，类似于QQ，但是简单版。 . 当然这个应用不能替代QQ，不过支持类似QQ群聊天功能，方便临时性的会议建群聊天。 . 为了简化，我们不实现认证授权功能，这是为彼此都很熟悉的用户设计的。如果你想让app更安全，自己可以实现一下。 . 为了在服务器端支持最大兼容性，这个app用Telnet收发消息。虽然不是Kivy的app的图形用户界面，Telnet可以在Windows 95和MS-DOS完美运行。 . 更严谨的考证一下，其实Telnet在1973年就标准化了，因此它甚至可以在8086 CPU上运行。Windows 95和MS-DOS相比之下已经很新了。 . 本章教学大纲如下： . 用Python的Twisted框架实现服务器端。 | 在不同的抽象层面上开发两个客户端，一个是通过套接字实现命令行程序，一个是通过Twisted的事件驱动客户端实现的程序 | 用Kivy的ScreenManager更容易的实现UI | 做一个ScrollView容器实现消息的无限长度 | . 我们的应用将使用中心化的客户端-服务器架构，很多网站和应用都用这种主流的互联网方法论。与去中心化的P2P网络相比，你很快会发现这种方法是多么的容易。 . 这里没有区分互联网与局域网（local area network，LAN），但是两者在底层上没啥关系。但是，如果你要把应用发布到应用商店，你还需要准备很多其他的内容，比如设置一个安全网络服务器，配置防火墙来保证你的代码可以扩展到多核处理器和其他设备。实际上这并没有多可怕，但是仍然需要一些努力。 . &#23454;&#29616;&#32842;&#22825;&#26381;&#21153;&#22120; . 开始写客户端之前我们先把服务器端做出来。我们用Twisted框架来提高效率，通过Python来实现，这样可以避开许多常见的、底层的网络任务。 . 兼容性提示 Twisted目前仍然不能很好的不支持Python3，所以这里得使用Python2.7。其实2to3很容易移植，因为没多少不兼容的设计方式。（不过，我们完全忽视了Unicode相关的问题，因为Python2和Python3的处理方式不同。如果是中文，还是Python3方便。） . Twisted是一个事件驱动的底层的服务器框架，不像Node.js（实际上，Node.js的设计受到Twisted的影响）。与Kivy很类似，事件驱动的架构意味着我们不需要把代码构建一个无限循环，相反我们只要为app绑定大量的事件监听器就行。许多底层的网络处理，都可以通过Twisted方便的实现。 . 和其他Python包一样，用pip就可以安装Twisted： pip install -U twisted . &#21327;&#35758;&#23450;&#20041; . 现在我们来看下聊天服务器即将使用的通信协议，因为我们的app并不复杂，所以我们不用XMPP那样主流的、功能丰富的程序，我们自己实现一个简单的就行。 . 我们实现的协议层就是两条信息在客户端和服务器传递——连接服务器（进入聊天室），对其他人说话。服务器会反馈客户端传递的每件事情；服务器自己不会产生任何事件。 . 我们的协议执行原文传递，和很多其他的应用层如HTTP协议一样。这样做很合理，因为调试和实现起来都很方便。字符串协议比二进制码协议更具扩展性和前瞻性（future-proof）。缺点就是包压缩率底，占用资源多；二进制协议可以更紧凑。不过在这个app讨论这样不太重要，也可以通过压缩技术缓解这个不足（这就是为啥很多服务器都是HTTP协议）。 . 现在，让我们梳理一下每条消息在应用协议的思路： . 连接到服务器的信息只有用户现在是否在聊天室，每次就用一个单词CONNECT来检测。这个信息不需要参数化，直接用单词。 | 在聊天室说话更有趣。有两个参数：用户名和文字信息。让我们把格式定义为A:B，A就是用户名（我们要求用户名不能包含分号:字符）。 | . 根据这个思路，我们写出下面的算法（伪代码）： . if &#39;:&#39; not in message then // it&#39;s a CONNECT message add this connection to user list else // it&#39;s a chat message nickname, text := message.split on &#39;:&#39; for each user in user list if not the same user: send &quot;{nickname} said: {text}&quot; . 对同一个用户的测试就是把向用户自己传递的信息去掉。 . &#26381;&#21153;&#22120;&#20195;&#30721; . 有了Twisted的帮助，我们的伪代码可以很直接的写出Python代码。下面就是我们应用的server.py文件： . from twisted.internet import protocol, reactor transports = set() class Chat(protocol.Protocol): def dataReceived(self, data): transports.add(self.transport) if &quot;:&quot; not in data: return user, msg = data.split(&quot;:&quot;, 1) for t in transports: if t is not self.transport: t.write(&quot;{0} says: {1}&quot;.format(user, msg)) class ChatFactory(protocol.Factory): def buildProtocol(self, addr): return Chat() reactor.listenTCP(9096, ChatFactory()) reactor.run() . &#35774;&#35745;&#21407;&#29702; . 下面的操作流程可以帮助你理解上面的代码： . 最后一行reactor.run()开启ChatFactory服务器监听9096端口 | 当服务器收到请求，就调用dataReceived()响应 | dataReceived()方法就是前面伪代码的实现，会把消息发送给其他用户 | . 每个到客户端的连接构成集合transports。我们无条件的把当前的传递self.transport加入集合。 . 然后就是算法的实现。最后，聊天室内除了发消息的每个用户都会收到提示，&lt; username&gt;说了&lt;message text&gt;。 . 注意我们并没有用CONNECT来检查连接的信息。这是按照1980年Jon Postel在TCP说明书里面提出的网络稳健性（network robustness）原则设计的：保守的发送，自由的接收。 另外通过简化代码，我们还获得了更好的兼容性。在未来要发布新版本客户端时，如果我们给协议增加一个新消息，假设叫WHARRGARBL消息，名字看着就很酷。没有崩溃是因为虽然收到来一个格式错误的消息（这是由于版本不匹配），老版本的服务器会直接忽略这些消息继续工作。 这些具体的版本兼容性问题可以通过许多策略来纠正。但是，还有更多来自网络尤其是公网的难题，包括用户恶意攻击拖垮服务器等等。所以，实际中并没有服务器非常稳定这种可能。 . &#26381;&#21153;&#22120;&#27979;&#35797; . 直接运行Python文件就可以测试服务器： . python server.py . 这个命令的结果不会直接看到。服务器开始运行，等待客户请求。但是，我们还没客户端程序。那怎么测试呢？ . 这种先有服务器还是先有客户端的经典问题有很多方法可以解决——向服务器发信息，然后显示服务器反馈的信息。 . 处理字符串协议服务器的一个标准化工具就是Telnet，一般都是命令行，没有图像界面。很多操作系统都带有Telnet。在Windows系统中，打开“控制面板|程序和功能|启动或关闭Windows功能”就可以找到Telnet。 . . Telnet有两个参数：服务器地址和端口。为了连接到Telnet，你需要先启动server.py，然后再打开命令行输入： . telnet 127.0.0.1 9096 . 另外，你也可以用localhost代替127.0.0.1，在hosts文件中是默认设置。 . 现在就可以测试服务器了。你可以根据前面设计流程，向服务器发送内容进行实现测试： . CONNECT User A:Hello, world! . 没有出现任何反馈，因为我们没有让服务器向原作者反馈信息。因此，我们需要打开另外一个命令行，然后以一个新的用户登录。就可以看到User A发送的信息了。如下图所示： . . 如果你没法儿正常测试Telnet也甭灰心，这不影响咱们app的顺利完成。 如果用Windows的话，给一点小建议：最好给电脑装个Mac OS或Linux，双系统更适合研发工作，推荐使用虚拟机，切换方便。 . 这样，我们就知道服务器可以正常工作了。现在我们来做客户端系统的GUI。 . &#23631;&#24149;&#31649;&#29702;&#22120; . 现在我们用一个新概念来设计UI，叫屏幕管理器。用来设计我们的app合适。一共是两个UI状态： . 登录界面：包括服务器地址、用户名、登录按钮 | 聊天界面：包括信息显示、信息输入、发送信息按钮和端口服务器按钮 | . 从理论上说，我们的app界面就是这样。这种UI分离的设计方法涉及到，对不同UI状态里可见的与隐藏的控件的管理。这样可以快速的组合一堆部件，而不要写任何代码。 . Kivy为我们提供ScreenManager来实现UI设计。另外，ScreenManager还提供了屏幕切换的动态过程，以及大量的内置转换方式。可以完全通过Kivy语言来实现，不需要任何Python代码。 . 下面让我们来实现，首先建立chat.kv文件： . ScreenManager: Screen: name: &#39;login&#39; BoxLayout: # other UI controls -- not shown Button: text: &#39;Connect&#39; on_press: root.current = &#39;chatroom&#39; Screen: name: &#39;chatroom&#39; BoxLayout: # other UI controls -- not shown Button: text: &#39;Disconnect&#39; on_press: root.current = &#39;login&#39; . 这是程序的基本结构：我们建立ScreenManager根部件，并为每个状态建立一个Screen容器。容器里面有上面看到的布局、按钮。后面我们会继续完善。 . 代码里面看到还包括Screen的按钮。为了切换应用的状态，我们还需要设置ScreenManager的current属性。 . &#23631;&#24149;&#20999;&#25442;&#21160;&#20316; . 前面提到，屏幕可以通过切换动作的动态显示。Kivy提供了许多切换功能，在kivy.uix.screenmanager包里面： . Transition class name Visual effect . NoTransition | 没有动画，直接显示屏幕 | . SwapTransition | 滑到下一屏幕，用上、下、左（默认）、右。 | . SwapTransition | iOS屏幕切换效果 | . FadeTransition | 褪色方式切换 | . WipeTransition | 用1px的遮挡实现平滑的定向切换 | . FallOutTransition | 将旧屏幕缩小到屏幕中间，渐渐透明，再出现新屏幕 | . RiseInTransition | 与FallOutTransition完全相反，新屏幕从中间出现，放大直到遮住旧屏幕 | . 在.lv文件里面设置这些切换动作时需要注意一旦：切换需要手动导入。 . #:import RiseInTransition kivy.uix.screenmanager.RiseInTransition . 现在，你就可以配置ScreenManager了。注意这些动作都是Python类的实例，所以后面要加括号： . ScreenManager: transition: RiseInTransition() . &#30331;&#24405;&#30028;&#38754;&#24067;&#23616; . 登录界面布局和前一章的录音app类似：用一个GridLayout把各个元素按照网格排列。 . 还没用过的部件就是文本框TextInput。Kivy的文本框和按钮基本完全一样，区别就是可以输入文字。默认情况下是多行显示，因为在聊天app里面多行少见（如微信、QQ），所以要设置multiline为False。 . 在无键盘设备上运行时，Kivy会调用虚拟键盘，和原生应用一样。下面的代码就是登录界面布局： . Screen: name: &#39;login&#39; BoxLayout: orientation: &#39;vertical&#39; GridLayout: Label: text: &#39;Server:&#39; TextInput: id: server text: &#39;127.0.0.1&#39; Label: text: &#39;Nickname:&#39; TextInput: id: nickname text: &#39;Kivy&#39; Button: text: &#39;Connect&#39; on_press: root.current = &#39;chatroom&#39; . 这里，我们增加了Server和Nickname两个文本框，对应的标签和按钮。按钮的事件handler还有没有任何功能，后面会实现。 . 可以让单行的TextInput更好看点，我们让文本框里面的文字垂直居中： . &lt;TextInput&gt;: multiline: False padding: [10, 0.5 * (self.height – self.line_height)] . padding属性设置了左右的边距都是10，上面和下面的边距是文本框高度与一行文本高度之差的一半。下面就是效果图，可前面app的界面类似： . . 现在我们可以写代码来连接服务器了，不过之前我们先把聊天主界面做出来。这样我们就可以直接在上面测试了。 . &#32842;&#22825;&#30028;&#38754;&#24067;&#23616; . 聊天界面布局使用了ScrollView实现对话长度的切换，因为是第一次说这个空间，下面会详细介绍： . &lt;ChatLabel@Label&gt;: text_size: (self.width, None) # Step 1 halign: &#39;left&#39; valign: &#39;top&#39; size_hint: (1, None) # Step 2 height: self.texture_size[1] # Step 3 ScrollView: ChatLabel: text: &#39;Insert very long text with line nbreaks&#39; . 文字满屏之后，滚动条会出现，类似于在Android和iOS里面看到的。具体的设计流程如下： . 我们用text_size属性设置Label子类的宽度，把第二个参数高度设置成None，允许无限长度 | 把size_hint属性第二个参数设置为None，允许无限长度，迫使其高度与它的容器ScrollView独立。但是，它的长度会受到上一层的元素的限制，因此不会滚动。 | 设置部件的高度等于texture_size属性高度（注意索引都从0开始，因此第二个元素是texture_size[1]）。这就迫使ChatLabel比包含它的ScrollView部件大 | 当ScrollView部件发现它的子部件比它的空间大时，滚动条就出现了。这和手机上看到的一样，桌面系统也支持鼠标滚轮操作。 | &#28378;&#21160;&#27169;&#24335; . 你还可以为ScrollView设置滚动的效果来模仿原生平台的特点（不过和原生的效果还是有差别）。可以实现的效果如下： . ScrollEffect：当触及最底部的时候可以停止滚动，类似于桌面应用常见的功能 | DampedScrollEffect：这是默认的效果，类似于iOS，非常适合移动设备 | OpacityScrollEffect：与DampedScrollEffect效果类似，滚动时增加了滚动条的透明度，不会遮挡内容 | . 要使用这些效果，从kivy.effects模块导入效果，然后配置到ScrollView.effect_cls属性，与ScreenManager切换效果类似。本章app不改，就用默认效果，可以自行设置。 . 把上述内容综合起来，chat.kv文件代码如下： . Screen: name: &#39;chatroom&#39; BoxLayout: orientation: &#39;vertical&#39; Button: text: &#39;Disconnect&#39; on_press: root.current = &#39;login&#39; ScrollView: ChatLabel: id: chat_logs text: &#39;User says: foo nUser says: bar&#39; BoxLayout: height: 90 orientation: &#39;horizontal&#39; padding: 0 size_hint: (1, None) TextInput: id: message Button: text: &#39;Send&#39; size_hint: (0.3, 1) . 最后一行的size_hint属性设置了按钮的水平比例为0.3，默认的是1。这就会让发送按钮比文本框小。 . 为了把消息的背景色设置成白色的，我们可以这样： . &lt;ScrollView&gt;: canvas.before: Color: rgb: 1, 1, 1 Rectangle: pos: self.pos size: self.size . 这就在其他元素绘制之前为ScrollView铺上了白色。别忘记了调整一下&lt;ChatLabel&gt;类，把背景色设置成浅色背景： . #:import C kivy.utils.get_color_from_hex &lt;ChatLabel@Label&gt;: color: C(&#39;#101010&#39;) . 效果图如下： . 这里Disconnect按钮就是断开网络连接。这是下一章的内容，到时候你会发现，用Python实现简单网络程序的难度，与用Kivy建立简单的UI没啥区别。 . &#36830;&#25509;&#32593;&#32476; . 下面我们连接服务器来收发消息，并显示给用户。 . 首先，我们看一个纯Python实现的聊天客户端，用套接字就可以实现。不过还是推荐用高级工具，如Twisted；如果你对这类知识没有一点儿概念，可能有点小困难，坚持一下就会好，多试几次准明白。 . &#19968;&#20010;&#31616;&#21333;Python&#23458;&#25143;&#31471; . 下面我们将用readline()函数读取用户的消息，然后通过print()函数显示在命令行上。这和Telnet没啥区别——都是命令行界面显示消息——只是我们从底层的套接字开始做起。 . 这需要一些标准模块：socket，sys（sys.stdin提供输入文件接口）和select模块等待消息出现。新建一个客户端文件client.py： . import select, socket, sys . 这个程序没有其他依赖关系；所有平台的Python都支持。 . 不过Windows里面的select，由于其代码实现方式不同，不能把文件描述器调整为套接字接受的样式。所以这个客户端就不能运行了，不过这个客户端我们最后也不会用，所以不要担心，如果你用的是Windows。 . 现在，我们来连接服务然后用CONNECT对接： . s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((&quot;127.0.0.1&quot;, 9096)) s.send(&quot;CONNECT&quot;) . 然后就是等待两类消息，一类是标准输入（用户输入的文字），一类s套接字（服务器发送消息）。等待可以用select.select()实现： . rlist = (sys.stdin, s) while True: read, write, fail = select.select(rlist, (), ()) for sock in read: if sock == s: # receive message from server data = s.recv(4096) print(data) else: # send message entered by user msg = sock.readline() s.send(msg) . 然后，服务器根据收到的最新数据进行反馈，我们可以把服务器发送的信息显示到屏幕上，或者如果是用户发送的消息就发送到服务器。其实这就是Telnet做的事情，只是缺少错误异常检测部分。 . 你会发现底层的模块实现客户端并没有我们想象的困难。但是相比高级模块如Twisted，原始套接字代码还是冗长的。但是这里显示了客户端工作的原理，其他任何高级工具都是这里实现的，高级工具也不过是通过底层的套接字实现，然后加上方便使用的API而已。 . 注意这里我们没有加异常检测部分，因为代码可能增加2-3倍，感兴趣的可以练习一下。 网络是非常容易出错的；比其他IO都脆弱。因此，如果你打算做一个类似于Skype那样的商业软件，你的代码里面将充斥异常检测和测试：比如丢包，防火墙问题等等。不论你的架构设计的多么好，网络服务想获得极高的可靠性很难。 . &#29992;Twisted&#23454;&#29616; . 纯Python代码写的客户端不太适合Kivy，原因就是主循环部分（while True:）。要让这个循环与Kivy的事件循环协同运作，还得做些事情。 . 不过，Twisted的优势可以很好的弥补这一点，实现同样的网络模块可以同时作用于服务器和客户端，使得代码更统一。关键在于Twisted可以与Kivy的事件循环协同运作，首先让我们把Twisted相关模块导入： . from kivy.support import install_twisted_reactor install_twisted_reactor() from twisted.internet import reactor, protocol . 这段代码要放在main.py文件的最上面。下面我们用Twisted来实现： . ChatClient&#21644;ChatClientFactory . 用Twisted实现工作量很少，因为这个框架为网络相关的每一件事情都做了很好的接口，这些类通过简单的连接就可以完成工作。 . ClientFactory的子类ChatClientFactory可以在初始化阶段储存Kivy app的实例，这样我们就可以向它传递事件。代码如下： . class ChatClientFactory(protocol.ClientFactory): protocol = ChatClient def __init__(self, app): self.app = app . ChatClient类监听Twisted的connectionMade和dataReceived事件，然后发送到Kivy app： . class ChatClient(protocol.Protocol): def connectionMade(self): self.transport.write(&quot;CONNECT&quot;) self.factory.app.on_connect(self.transport) def dataReceived(self, data): self.factory.app.on_message(data) . 注意那个无所不在的CONNECT握手信号。 . 这和前面的套接字写法很不同，是吧？而且和前面的server.py很像。但是，我们只是把事件传递给aoo对象，并没有处理事件。 . &#21152;&#20837;UI . 要看到app的全貌，我们还要把UI也加进来。chat.kv文件如下： . Button: # Connect button, found on login screen text: &#39;Connect&#39; on_press: app.connect() Button: # Disconnect button, on chatroom screen text: &#39;Disconnect&#39; on_press: app.disconnect() TextInput: # Message input, on chatroom screen id: message on_text_validate: app.send_msg() Button: # Message send button, on chatroom screen text: &#39;Send&#39; on_press: app.send_msg() . 注意按钮不会再切换屏幕了，相反它们调用app的方法，类似于ChatClient事件处理。 . 完成这些之后，我们需要实现Kivy应用类里面的5个方法：两个是Twisted代码中的服务器生成事件（on_connect和on_message），三个是用户接口事件（connect，disconnect和send_msg）。这样才能让聊天app真正可以用。 . &#23458;&#25143;&#31471;&#30340;&#35774;&#35745;&#24605;&#36335; . 当我们简单写一些程序运行逻辑：从connect()到disconnect()。 . 在connect()方法里面，我们把Server和Nickname参数作为用户输入。Nickname参数被储存到self.nick，Twisted客户端连接到具体的服务器地址： . class ChatApp(App): def connect(self): host = self.root.ids.server.text self.nick = self.root.ids.nickname.text reactor.connectTCP(host, 9096, ChatClientFactory(self)) . 调用ChatClient.connectionMade()函数，把控件传递到on_connect()方法上。我们将用事件来储存self.conn连接，然后切换屏幕。前面提到过，按钮不再直接切换屏幕，而且通过事件handler实现： . # From here on these are methods of the ChatApp class def on_connect(self, conn): self.conn = conn self.root.current = &quot;chatroom&quot; . 现在主要部分就是收发信息。很简单，就是从TextInput发信息，把self.nick加上，发送给服务器。最后把信息显示出来，并且清空TextInput。 . def send_msg(self): msg = self.root.ids.message.text self.conn.write(&quot;%s:%s&quot; % (self.nick, msg)) self.root.ids.chat_logs.text += &quot;%s says: %s n&quot; % (self.nick, msg) self.root.ids.message.text = &quot;&quot; . 接受消息更简单，因为我们不会保持这些内容，所有就是把消息显示到屏幕上： . def on_message(self, msg): self.root.ids.chat_logs.text += msg + &quot; n&quot; . 最后一个方法就是disconnect()：关闭连接，清理所有内容回到初始界面。这样用户就可以重新连接其他服务器了。 . def disconnect(self): if self.conn: self.conn.loseConnection() del self.conn self.root.current = &quot;login&quot; self.root.ids.chat_logs.text = &quot;&quot; . 这样程序就搞定了。 . 提示： 测试的时候，server.py文件应该持续运行，但是我们的app就不能终止连接了。最终结果就是app停留在登录界面，不再调用on_connect()，用户也不能到聊天室界面。 还有，在Android上面测试的时候，确定你的服务器IP地址，不是127.0.0.1，只要局域网设备才这样，在Android设备上不一样。可以用ifconfig查询（Windows上是ipconfig）。 . &#23458;&#25143;&#31471;&#20132;&#20114; . 前面做的Telnet、两个客户端虽然实现方式不同，却可以通信，因为其底层的原理基本一致。 . 类似于互联网的处理方式：只要你用HTTP协议，相关的服务器和客户端就可以交互：网页服务器、浏览器、搜索引擎等等。 . 协议是更高级的API，与语言、系统无关，应该选一个流行的用。并不是每个网络开发者都熟悉微软2007年发布的Silverlight协议，但大家都知道1991年发布的HTTP。 . &#22686;&#24378;&#35270;&#35273;&#20307;&#39564; . 现在app已经可以运行了，我们把聊天窗口改善一下。可以用Kivy的BBCode来修饰。 . 让我们给每个用户加个颜色，这样方便用户区分所有人。我们同样使用扁平化UI的配色方式。 . 当前用户发送的信息不会从服务器发给自己，是通过客户端代码添加到对话内容里的。所以，我们要把当前用户名加一个固定的颜色。 . colors = [&quot;7F8C8D&quot;, &quot;C0392B&quot;, &quot;2C3E50&quot;, &quot;8E44AD&quot;, &quot;27AE60&quot;] class Chat(protocol.Protocol): def connectionMade(self): self.color = colors.pop() colors.insert(0, self.color) . 通过一个无限循序，我们把颜色依次加到用户名上，循环使用。如果你熟悉Python的itertools模块，你可以这么写： . import itertools colors = itertools.cycle((&quot;7F8C8D&quot;, &quot;C0392B&quot;, &quot;2C3E50&quot;, &quot;8E44AD&quot;, &quot;27AE60&quot;)) def connectionMade(self): self.color = colors.next() # next(colors) in Python 3 . 现在，我们再把颜色添加到用户名上，很简单，就是[b][color]Nickname[/ color][/b]。 . for t in transports: if t is not self.transport: t.write(&quot;[b][color={}]{}:[/color][/b] {}&quot;.format(self.color, user, msg)) . main.py里面的客户端也同时更新了。我们还要为当前发消息的用户增加一个固定的颜色： . def send_msg(self): msg = self.root.ids.message.text self.conn.write(&quot;%s:%s&quot; % (self.nick, msg)) self.root.ids.chat_logs.text += &quot;[b][color=2980B9]{}:[/color][/b] {} n&quot;.format( self.nick, msg ) . 然后，我们把聊天记录部件ChatLabel的markup属性设置为True： . &lt;ChatLabel@Label&gt;: markup: True . 这样就可以了。 . &#36716;&#20041;&#23383;&#31526;&#22788;&#29702; . 和HTML一样，用户发送的消息可以会出现转义字符。比如BBCode之类的符号。要解决这个问题，我们可以用Kivy的kivy.utils.escape_markup来解决。但是还不是很完整，我们可以稍微调整一下： . def esc_markup(msg): return msg.replace(&quot;&amp;&quot;, &quot;&amp;amp;&quot;).replace(&quot;[&quot;, &quot;&amp;bl;&quot;).replace(&quot;]&quot;, &quot;&amp;br;&quot;) . 这样所有的Kivy里面的转义字符转变成HTML字符替代，这样遇到这些字符时就会不会发生转义。在server.py文件里面，相应的代码需要改变： . t.write(&quot;[b][color={}]{}:[/color][/b] {}&quot;.format(self.color, user, esc_markup(msg))) . 在main.py里面，实现是类似的： . self.root.ids.chat_logs.text += &quot;[b][color=2980B9]{}:[/color][/b] {} n&quot;.format( self.nick, esc_markup(msg) ) . 现在bug修复了，用户可以安全的发从BBCode消息了。 . . 其实这类bug在互联网产品中很常见。类似于跨站脚本（cross-site scripting，XSS），可以造成比修改字体更恐怖的结果。 不要忘了净化所有产品的用户输入，因为用户一不小心用了命令行就麻烦了。 . &#21518;&#32493;&#20219;&#21153; . 这些都只是开始，还有很多必须的事情没做。比如用户名唯一，没有历史记录和离线消息的支持。如果网络质量不好的话，消息总会丢失。 . 但是更重要的是，这些问题都可以解决，我们已经有了产品原型。在产品开始阶段，原型是非常具有吸引力，先让轮子转起来，就有了动力；如果你因为好玩而编程，这种感觉更明显，因为你看到了一个可以使用的产品了（相反如果只是一块块代码，不能使用，那感觉很糟糕）。 . &#24635;&#32467; . 这一章我们看到了CS架构的应用开发（其实就网络编程）其实也不复杂。甚至底层的套接字代码也很容易搞定。 . 当然，涉及到网络时会遇到很多灰色地带不容易搞定。包括高时延的处理，中断连接的恢复和多节点的数据同步等（尤其是点对点或多主机时，每一个机器只有一部分数据）。 . 另一个目前比较新的网络问题就是政治方面的，政府已经开始实施互联网管制，包括出于安全的原因（比如，封杀恐怖主义网络资源）到完全无厘头（封杀教育网站像维基百科，主要的新闻网站或视频游戏网站）。这种连接问题会产生很高的间接伤害，如果CDN（content delivery network）挂了，很多使用CDN链接的网站就不能正常显示了。你懂的。 . 但是，只要踏踏实实的坚持下去，一定可以克服重重困难把优质产品发布给客户。而且，Python丰富的特性可以减轻你的负担，本章的聊天app已经充分体现了这点：很多底层的细节都可以通过Kivy和Twisted轻松搞定。 . 互联网领域有无限可能，永无止境。下一章我们继续网络相关的尝试，敬请期待。 .",
            "url": "/Kivy/jupyter/kivy/android/ios/2019/05/01/kivy-ch4-chat-app.html",
            "relUrl": "/jupyter/kivy/android/ios/2019/05/01/kivy-ch4-chat-app.html",
            "date": " • May 1, 2019"
        }
        
    
  
    
        ,"post13": {
            "title": "Kivy指南-3-Android录音app",
            "content": "在上一章，我们简要介绍过Kivy要实现跨平台应用，可能在不同的平台需要选择不同的代码，为一些用户增强体验效果，实现具体平台的任务。 . 有时，这些都很简单；比如，如果Kivy发现目标系统支持它，多点触控就会启动——不需要写任何代码，但是要考虑一些点击事件原来的功能可能会与多点触控产生冲突。 . 另外一些平台相关的任务，像代码不能在其他系统上运行，是有很多原因造成的。还记得画图app的鼠标光标吗？代码要用Pygame封装的底层SDL光标功能，如果你熟悉SDL和Pygame那就很简单。因此，为了让app可以跨平台，我们要尽量避免在系统兼容性不好的代码；因为那样可能导致程序崩溃。 . 然而，Kivy应用具有良好的平台兼容性——Mac，Windows，Linux，iOS，Android和Raspberry Pi——都没什么大问题。 . 教学大纲： . 通过Pyjnius实现Python与Java的交互 | 在Android系统设备上测试Kivy应用 | 用Python调用Android的声音API，允许我们记录和播放声频文件 | 制作一个紧凑型用户界面，类似Windows Phone | 用图标字体改进app矢量图标的显示 | . &#24179;&#21488;&#30456;&#20851;&#20195;&#30721; . 这本书绝大多数app都是平台无关代码，因为Kivy具有高度移植性。但这一次我们做一个仅支持Android平台的应用。这么做肯定会减少我们的用户，但是它能让我们接触到一些具体平台功能的处理方法。 . 这种需求可以实现，是立足于Kivy不断努力支持多个平台，使得用户在不同平台上具有类似的体验。因此，我们可以真正简单的做到一次编写，处处运行。 . 但是，要实现跨平台，你就要用每个系统支持的功能。不同系统功能的最大公约数集合包括屏幕可以显示图像，如果有声卡就获取声音，接受用户的输入等等。 . 每个Kivy应用，本质上都基于Python，还支持Python的标准模块。可以利用网络编程，支持大量的协议操作，还提供很多通用性的算法和功能。 . 还有就是在大多数平台上，纯kivy程序的IO能力会受到限制，通用计算机系统的一小部分都是这样，像智能手机和平板电脑。 . 让我们看看现代移动设备的API接口，这里以Android为例。我们把每个API分成两部分：一部分是Python/Kivy支持的，另一部分不是。 . Python/Kivy支持的特性如下： . 图形硬件加速 | 支持多点触控输入 | 播放声音 | 支持网络 | . Python/Kivy不支持的特性如下： . 调制解调器，语言电话和短信 | 内置摄像头拍照和录像 | 内置麦克录音 | 数据云存储 | 蓝牙和其他近场通信 | 位置服务和GPS | 指纹识别 | 传感器类，加速器、陀螺仪 | 屏幕亮度调节 | 振动功能 | 电池充电百分比这些不支持的列表里面，不同的Python模块已经支持，像Audiostream可以录音，Plyer可以实现很多功能。 因此，这些特性并非完全不能支持；实际上，这些功能在不同的平台上都是十分碎片化的，即使在Android系统上也没有统一的版本；因此，你写完具体平台的代码后，还是会发现没法儿移植。 . | . 从前面的比较中可以看出，Android有一堆功能，只要一部分被Python/Kivy支持。这无疑为你用Kivy开发Android应用留下了大量的自由想象空间。你会学到Python调用Android API的知识，可以让Kivy做任何事情。 . 另一个优势就是，你可以编写全新的类去支持具体特定硬件的移动设备，包括虚拟现实app，支持的陀螺仪游戏，全景拍摄相机等等。 . Pyjnius&#20171;&#32461; . 要充分利用Android功能，就要用Java写的一堆API。我们要做的录音app，类似于Android和iOS的应用，很简单的功能。不像纯Kivy程序要从头开始，Android API为我们提供一堆录音的功能。 . 下面我们就通过做录音app来演示Python-Java交互的Pyjnius模块卓越的性能，同样是Kivy开发者的项目。我们要开发的内容很简单——录音，回放功能——你会发现这种交互很简单，不需要一堆错综复杂的细节去实现这点小功能。 . Pyjnius最有趣的属性就是它并非在Android上面添加一个层来调用API，而是运行你直接通过Python运行Java。这样你就可以完全使用原生的Android API，可以参考适合Java开发的Android文档，不过不是Python文档。但是，这比没有API文档要好。 . 我们这里说Pyjnius是用来做Android开发的，其实也可以开发Java桌面应用。这是很有趣的，因为还有一个Java API的Python模块叫Jython，很慢而且不完整。Pyjnius可以让你直接使用CPython，再加上Numpy就可以让程序飞起来。 总之，让你想通过Python用Java，考虑Pyjnius吧。 . Android&#27169;&#25311;&#22120; . 这章做的app是要运行在Android上的，不能运行在我们的电脑上，因此我们需要用到Android设备，如果你没有设备，也可以安装Android模拟器。一个方便高效的Android模拟器可以让你事半功倍。 . 推荐一个模拟器，就是Genymotion，你可以下载一个免费版来用。不同的系统安装方法不同，我们就不提供教程了，自行谷歌之，还是比较简单的。 . 用虚拟机安装Android模拟器的时候，下面一些建议供参考： . 建议保持Android最新版本，向后兼容性比较差；旧版本的系统级别的调试问题没有完全解决。 | Android社区资源丰富，如果有问题就检索，你遇到的坑别人也踩过。 | Kivy Launcher app是很不错的测试工具，你可以在官方网站找到apk，建议装到手机上，方便程序调试。 | 不同的模拟器质量和兼容性层次不齐。如果你发现一次没搞定，建议你换个虚拟机或模拟器试试。 | . 下面这个截图就是Genymotion启动的模拟器，完全支持Kivy Launcher。 . Metro UI . 现在让我们用Window Phone的主屏风格来建立一个用户界面。这些不同大小的矩形彩色网格，被称为Metro UI风格，不过后来更名为Modern UI。我们的app就是要仿这个。 . 当然，我们并不是要做出这样，只是用一下风格来构建我们的界面。下面是对风格的总结： . 每个元素都是一个矩形网格 | IU元素呈现扁平化特征（第一章讨论过，表面纯色，没有阴影，也没有圆角） | 格子可以根据需要变大，方便点击 | . 看起来非常简单吧。其实用Kivy实现起来也很简单。 . &#25353;&#38062; . 现在开始吧，首先做个按钮Button类，就像我们在之前的应用里做的,这里我们重用第二章画图app的按钮： . &lt;Button&gt;: background_normal: &#39;button_normal.png&#39; background_down: &#39;button_down.png&#39; background_color: C(&#39;#95A5A6&#39;) font_size: 40 . 我们之前设计调色板时，把背景色成设置重白色。这里我们的background_color属性是一个底色，我们分配一个浅白色作为background_color。这次我们不要边框有颜色。 . 之后就是按下按钮的颜色，background_down属性我们设置成25%透明白色。再在上面加上黑色，就可以获得一个深色的背景： . &#32593;&#26684;&#32467;&#26500; . 布局有点小复杂。Kivy没有现成的Modern UI模板可用，我们要自己仿制一个GridLayout部件。它和BoxLayout部件类似，不过是二维的，所以没有orientation: &#39;horizontal&#39;或&#39;vertical&#39;属性。 . 如果没有其他需求，一个GridLayout部件就可以搞定，但是我们还想要不同尺寸的按钮。目前，GridLayout部件不支持通过网格的合并成更大的网格（HTML里面的rowspan和colspan属性更方便）。因此，我们换个思路，先用一个GridLayout部件作为根部件，用大网格，然后再在里面增加一个GridLayout部件，用小网格。 . 因为Kivy可以完美支持嵌套布局，我们可以用下面的kv代码实现recorder.kv文件： . #:import C kivy.utils.get_color_from_hex GridLayout: padding: 15 Button: background_color: C(&#39;#3498DB&#39;) text: &#39;aaa&#39; GridLayout: Button: background_color: C(&#39;#2ECC71&#39;) text: &#39;bbb1&#39; Button: background_color: C(&#39;#1ABC9C&#39;) text: &#39;bbb2&#39; Button: background_color: C(&#39;#27AE60&#39;) text: &#39;bbb3&#39; Button: background_color: C(&#39;#16A085&#39;) text: &#39;bbb4&#39; Button: background_color: C(&#39;#E74C3C&#39;) text: &#39;ccc&#39; Button: background_color: C(&#39;#95A5A6&#39;) text: &#39;ddd&#39; . 翻翻前面的章节，把main.py也做出来就可以运行了，自己试试吧。注意类的名称是RecorderApp，kv文件名大写，再加App，不清楚参考第一章命名相关内容。 . 注意嵌套的GridLayout部件是怎么和同级的大按钮放在一起的。如果你记得前面那个WP系统主平面，还得继续改进代码：四个小按钮和一个大按钮一样大。嵌套的GridLayout部件是这些小按钮的容器。 . &#21487;&#35270;&#21270;&#23646;&#24615; . 在外面的网格里，padding属性是为了让部件离屏幕的四边有一定边距。把其他GridLayout部件的可视化属性都放到一个类中： . &lt;GridLayout&gt;: cols: 2 spacing: 10 row_default_height: (0.5 * (self.width - self.spacing[0]) - self.padding[0]) row_force_default: True . 要注意的是padding和spacing属性都是列表，不是数值。spacing[0]是水平间距，之后是垂直间距。但是，我们用一个数值初始化，就像前面的代码显示的；数值可以用在两个方向。 . 嵌套网格由具有相同间距的两列组成，row_default_height属性是厚度：我们可以说，“让行高等于格子宽度”。但是下面我们手动计算想要的高度，0.5是因为有两列： . $$行高 = 0.5 × (屏幕宽度 - 所有边距和间距)$$ . 如果我们不这么做，网格里面的按钮就会垂直填充全部空间，这不是我们要的效果，尤其不是很多按钮的时候，每个就会显得巨大难看。另外，我们希望所有的按钮都是方块。 . 下面就是之前代码设计的“Modern UI”界面： . &#21487;&#32553;&#25918;&#30340;&#30690;&#37327;&#22270;&#26631; . 要做好看的应用UI，就得有图标，不只是按钮+文字。当然，我们可以在按钮上加图片，但是更好的办法是有图标字体——后面你会发现这种方法更具柔性。 . &#22270;&#26631;&#23383;&#20307; . 图标字体本质上和普通字体一样，除了它们的符号与文字无关。比如，你输入“P”就可以获得Python的logo，而不是字母P；每个字都是与字母相对于的图标。 . 使用图标字体的不足——用这些字体的代码很难读——因为文字-图标对应关系不太明显。这点可以通过常量来代替要输入符号。 . 还有一些字体不使用英文字母，改用Unicode码与图标对应，比如Emoji颜文字。使用这类图标字体的前提是目标平台支持Unicode，这方面不是每个平台都ok，尤其是移动平台。我们这里的app只用ASCII码。 . &#21512;&#29702;&#20351;&#29992;&#22270;&#26631;&#23383;&#20307; . 在网页上，字体图标解决了很多图片（栅格图）相关的问题： . 首先是图片放大后会失真——虽然有算法可以解决这类问题，但是并不完美。相反图标字体是矢量图，可以无限放大。 | 栅格图文件包含的示意图（像图标和UI元素）比矢量格式字节空间大。这就显然不能应用到JPEG格式的图片上，会使字节空间更大。 | 另外，图标字体通常就是一套字体放在一个文件上，就是说一个HTTP请求就可以遍历。普通的图片分别是单个文件，明显增加HTTP请求负担；有一些方法可以改善这点，像CSS sprites可以把多个图片合成一张图改善性能，不过使用不太广泛，而且有些问题。 | 图标字体里面，颜色可以随意变化，在CSS文件增加color: red即可。尺寸、角度和其他那些普通图片不容易搞定的属性都很容易设置，就好像在位图上操作。 | . 以上这些并不适用于Kivy开发，不过图标字体的使用已经是现代网页开发的范本了，尤其是自大量优质字体开始出现以来——现在有几百种图标字体可用。 . 最棒的两个免费字体就是Font Squirrel和Google Fonts。不用介意这些网站的字体是用来做网页开发的，大多数字体都可以离线使用。&gt;最需要注意的是字体文件格式：Kivy只能支持True Type(.ttf)文件格式。好在大多数字体都是这个格式，即使不是也可以格式转换。 . Kivy&#20013;&#20351;&#29992;&#22270;&#26631;&#23383;&#20307; . 我们的app使用由John Caserta设计的Modern Pictograms免费字体。截图如下所示： . 要把字体加入Kivy程序，我们可以用第一章时钟app的方法。这里，我们不这么做，因为图标字体字体风格完全不同。还是，通过字体名称连接字体，而不是用字体文件名（modernpics.ttf）连接。这样，你就可以重命名字体文件或者移动文件路径，而不用每次都通篇改一遍。在main.py写如下代码： . from kivy.app import App from kivy.core.text import LabelBase class RecorderApp(App): pass if __name__ == &quot;__main__&quot;: LabelBase.register(name=&quot;Modern Pictograms&quot;, fn_regular=&quot;modernpics.ttf&quot;) RecorderApp().run() . 这样recorder.kv文件就可以使用图标字体了。首先，我们把Button改进一下，方便后面改变字体。代码如下： . &lt;Button&gt;: background_normal: &#39;button_normal.png&#39; background_down: &#39;button_down.png&#39; font_size: 24 halign: &#39;center&#39; markup: True . halign: &#39;center&#39;表示我们希望每行文字都在按钮的正中间。markup: True是必须的，因为我们后面自定义按钮需要这样。 . 现在，我们来升级所有按钮。这是一个例子： . Button: background_color: C(&#39;#3498DB&#39;) text: (&#39;[font=Modern Pictograms][size=120]&#39; &#39;e[/size][/font] nNew recording&#39;) . 通常不需要为Kivy文件字符串加括号，这么做是为了显示成多行，这和一行长串是一样的。 . 注意在[font][size]表情里面的&#39;e&#39;，这就是图标代码。每个按钮用一个图标，改变一个图标就是替换recorder.kv文件里面的一个字母。具体对应关系可以在Modern Pictograms字体网站查询。 . 为了方便浏览图标字体，你需要使用字体浏览器。通常，每个系统都有类似程序。 . Windows系统使用Character Map | Mac系统使用Font Book | Linux系统由桌面环境决定，GNOME使用gnome-font-viewer | . 当然也可以网页搜索。流行字体都有详细的说明。 . 下面就是我们的界面啦： . 不错吧，可以Modern UI很像吧。 . 你可能想知道右上角的小绿图标是干嘛的。它们是为了给不同的设备设置不同的录音质量。另外三个按钮——录音，播放，删除——尚不足以呈现Modern UI的风格，因为它需要更丰富好玩的外观。 . &#22312;Android&#19978;&#27979;&#35797; . 现在，我们的app虽然没有包含任何Android平台相关的代码，但是我们也可以在Android平台上测试。能这么做的前提是Android平台上装了Kivy Launcher。 . 把app打包成Kivy Launcher支持的程序有点琐碎。我们打算增加两个文件，android.txt和icon.png，都放在main.py与recorder.kv同名文件夹里，然后拷贝到SD卡的/Kivy文件夹即可，如下图所示： 当然启动Kivy Launcher，它就会扫描文件目录的完整路径，如果没SD卡还是能找到。 . android.txt非常简单： . title=App Name author=Your Name orientation=portrait . title和author设置后会在程序列表显示出来。orientation可以是portrait（正常显示，高度&gt;宽度）和landscape（水平显示，宽度&gt;高度），由应用布局设计决定。 . icon.png文件是可选的，如果没有就是空白图标。建议找个漂亮的，程序的第一印象就是图标。注意icon.png文件名不能改变，否则Kivy Launcher找不到启动位置。 . 把之前做过的程序都放进去，你就会看到程序列表，如下所示： . 如果不是这样，建议检查一下文件路径。 . 现在就可打开程序了。这是在Android上测试Kivy程序最方便的办法——就是简单的复制文件。 . &#29992;Android&#30340;API . 已经完成了app的用户界面，下面我们来用Android的API实现录音的功能，要用到的两个Java类是MediaRecorder和MediaPlayer。 . Python和Java都是面向对象语言，看着好像差不多，但是两者对OOP理论的应用大相径庭。与Python相比，很多Java的API都在一坨坨的使用设计模式。所以，你在解决很小的任务时，也需要写一堆废话，就不用觉得奇怪。 . 在1913年的时候，Vladimir Lenin就写下了对Java架构的评论： . 只有一种办法可以粉碎这些“类”的阻力，那就是，在我们的社会中找到能够推陈出新的力量。 . 这段话没有提及之后的Python和Pyjnius，但是观点明确——即使在一百年前，过度使用类也是不受社会欢迎的。 . 幸运的是，我们的任何相对简单。要用Android API实现录音，我们只需要下面5个Java类： . android.os.Environment：这个类提供了很多有用的环境变量。我们需要用它来确定文件保存的路径。临时存放的位置就是&#39;/sdcard/&#39;或者简单的内容，但是即使不同的设备路径不一样。因此，我们别这么设置路径。 | android.media.MediaRecorder：这是我们的主力，实现了音频和视频的抓取和保存功能。 | android.media.MediaRecorder$AudioSource， android.media.MediaRecorder$AudioEncoder和android.media.MediaRecorder$OutputFormat：这些类列出了我们需要传递到MediaRecorder不同方法里面的参数。 | . Java类命名规则： 通常类名里面的&#39;$&#39;符号表示内部类。这种方法有点无厘头，因为你可以声明一个相似的类不用后面跟任何东西——&#39;$&#39;在Java变量和类名称中是可用的，与JavaScript里面的没有太多不同。但这种奇葩的命名方法让人无语。 . &#21152;&#36733;Java&#31867; . 下面的代码就是通过Pyjnius加载Java类： . from jnius import autoclass Environment = autoclass(&quot;android.os.Environment&quot;) MediaRecorder = autoclass(&quot;android.media.MediaRecorder&quot;) AudioSource = autoclass(&quot;android.media.MediaRecorder$AudioSource&quot;) OutputFormat = autoclass(&quot;android.media.MediaRecorder$OutputFormat&quot;) AudioEncoder = autoclass(&quot;android.media.MediaRecorder$AudioEncoder&quot;) . 如果你直接运行代码，可能会出现下面的错误： . ImportError: No module named jnius：如果Pyjnius没装 | jnius.JavaException: Class not found &#39;android/os/Environment&#39;：如果需要Android类没加载成功（在桌面系统上Android没装好可能会这样）。 | . 如果遇到其中任何一个错误都说明没配置好。因为代码不再是跨平台的了，让我们到Android设备或者模拟器上测试一下。这个app完全依赖Android相关的Java特性。 . 下面我们将把Java类与Python代码结合到一起。 . 记得这些类的定义文档都是Java的，不是Python。你可以看看Google官方的Android开发入门，然后把Java反应成Python代码，看着很恐怖，多试试，其实很简单。 . &#26597;&#25214;&#20445;&#25345;&#36335;&#24452; . 让我们演示一下Pyjnius这种混合语言使用API的过程。我们还可以通过Java检查SD卡是否已经挂载。 . import android.os.Environment; String path = Environment.getExternalStorageDirectory().getAbsolutePath(); . 翻译成Python就是： . Environment = autoclass(&quot;android.os.Environment&quot;) path = Environment.getExternalStorageDirectory().getAbsolutePath() . 两者是完全一样的。然后，我们可以通过log查看运行的结果。 . from kivy.logger import Logger Logger.info(&#39;App: storage path == &quot;%s&quot;&#39; % path) . 调试信息会显示下面这行日志： . [INFO] App: storage path == &quot;/storage/sdcard0&quot; . &#22312;&#35774;&#22791;&#20013;&#30475;&#26085;&#24535; . 当你在开发阶段运行Kivy应用时，日志会立刻在命令行窗口显示。当你在Kivy Launcher运行代码时，虽然不是很容易，显示日志也是非常有用的特性。 . 要看到日志，你可以在程序运行的时候到程序目录下（/Kivy/Recorder），里面会生成一个新的.kivy目录，这个目录里面有日志文件.kivy/logs。 . 如果是用Android SDK运行模拟器，可以打开开发者模式的USB调试功能，然后用adb logcat查看所有日志，里面包括Kivy日志。如果你用Android Studio 或Eclipse等IDE，你可以用logcat对日志进行过滤处理。 . 当调试程序出问题或应用不能启动的时候日志文件是很冗长的。Kivy还打印了各种关于运行环境的警告日志，像缺少库文件或功能，Python模块加载失败，或者其他提示。 . &#24405;&#38899; . 现在让我们用Android的API来逐个实现app的功能。现在的代码就是把Android的API翻译成Python。如果你对原始的Java代码感兴趣，你可以去官方网站看文档。 . 下面的代码就是MediaRecorder对象初始化： . storage_path = ( Environment.getExternalStorageDirectory().getAbsolutePath() + &quot;/kivy_recording.3gp&quot; ) recorder = MediaRecorder() def init_recorder(): recorder.setAudioSource(AudioSource.MIC) recorder.setOutputFormat(OutputFormat.THREE_GPP) recorder.setAudioEncoder(AudioEncoder.AMR_NB) recorder.setOutputFile(storage_path) recorder.prepare() . 这就是把啰七八嗦的Java代码直译成Python的代码。 . 你可以自定义里面的属性。比如AMR_NB（自适应多速率，Adaptive Multi-Rate编解码器，用来做语音优化的，广泛用于GSM和其他移动网络的设备中）改成AudioEncoder.AAC（进阶音讯编码，Advanced Audio Coding标准，类似于MP3的一种编码标准）。这么改不是很合适，因为手机的麦克风不只是录制音乐，还要录制你的声音。 . 下面就是“开始/结束录音(Begin/End)”按钮部分代码。这部分代码和第一章时钟app的思路一样： . class RecorderApp(App): is_recording = False def begin_end_recording(self): if self.is_recording: recorder.stop() recorder.reset() self.is_recording = False self.root.ids.begin_end_recording.text = ( &quot;[font=Modern Pictograms][size=120]&quot; &quot;e[/size][/font] nBegin recording&quot; ) return init_recorder() recorder.start() self.is_recording = True self.root.ids.begin_end_recording.text = ( &quot;[font=Modern Pictograms][size=120]&quot; &quot;%[/size][/font] nEnd recording&quot; ) . 很简单吧，就是首先储存状态is_recording，然后实现各个功能： . 开始或停止MediaRecorder对象； | 改变is_recording状态； | 升级按钮文字以反映当前状态。 | 程序的最后一部分就是升级recorder.kv，我们要调整一下“开始/结束录音(Begin/End)”按钮代码来调用begin_end_recording()函数： . Button: id: begin_end_recording background_color: C(&#39;#3498DB&#39;) text: (&#39;[font=Modern Pictograms][size=120]&#39; &#39;e[/size][/font] nBegin recording&#39;) on_press: app.begin_end_recording() . 这就搞定了。现在运行程序就可以向SD卡里录音了。不过在这之前请先看看下节内容。按钮的节目如下所示： . . &#37325;&#35201;&#35686;&#21578;&#8212;&#8212;&#26435;&#38480; . 默认的Kivy应用没有录音权限，android.permission.RECORD_AUDIO。如果初始化MediaRecorder实例就会失败。 . 当然有很多方法解决这个问题。首先，最容易的就是重新编译Kivy Launcher源代码，让应用获取录音权限，最新版在这里。 . 在安装.apk文件之前，请卸载原来的版本。另外如果你感受一下Android反编译，也可以用**apktool直接反编译apk文件。步骤如下： . 下载Kivy Launcher的app文件KivyLauncher.apk，用apktool文件命令：apktool d -b -s -d KivyLauncher.apk KivyLauncher . | 向AndroidManifest.xml文件里增加权限：&lt;uses-permission android:name=&quot;android.permission.RECORD_AUDIO&quot; /&gt; . | 重新打包成.apk文件：apktool b KivyLauncher KivyLauncherWithChanges.apk . | 用jarsigner工具为.apk文件签名。可以看看签名Android包的官方文档 | 这样，安装Kivy Launcher后就可以录音了。 . 你可以用同样的方法在通过Pyjnius为Python代码增加不同的权限。比如，要获得GPS API接入的权限，你的app就需要android.permission.ACCESS_FINE_LOCATION，其它Android设备权限可以看官方文档。 . &#25773;&#25918;&#22768;&#38899; . 播放声音很简单，也不需要权限，对应的API也更简练。我们就要一个类MediaPlayer： . MediaPlayer = autoclass(&quot;android.media.MediaPlayer&quot;) player = MediaPlayer() . 当用户按下播放(Play)按钮时，下面的代码就要运行。我们还为下一节的删除文件增加了reset_player()函数。代码如下： . def reset_player(): if player.isPlaying(): player.stop() player.reset() def restart_player(): reset_player() try: player.setDataSource(storage_path) player.prepare() player.start() except: player.reset() . 这些API的方法定义都可以在官方文档找到，不过意思很简单：就是复位播放器，加载声音文件，开始播放。文件的格式是自动设置的，可以让代码简单点。 . 实际上这类代码应该一直放在try ... catch里面，因为不知道什么地方就会异常。比如文件格式不对，SD卡没插好，或是读取失败，涉及到IO的问题多了。最好的办法就是小心驶得万年船（better safe than sorry）。 . &#21024;&#38500;&#25991;&#20214; . 最后一个功能是用java.io.File，和Android关系不大了，是Java标准库。Android官方文档也会包含Java核心类的解释，尽管Java比Android早几十年。代码很简单，就是最后一行： . File = autoclass(&quot;java.io.File&quot;) class RecorderApp(App): def delete_file(self): reset_player() File(storage_path).delete() . 首先，我们用reset_player()函数停止播放功能，然后把文件删掉。 . 奇葩的是，Java的File.delete()方法不会抛出异常，所以不需要用try ... catch语句去控制异常了。能省则省！ . 细心的读者会问为啥不用Python的标准库os.remove()呢。其实用Java库跟Python一样简单；不过Java更快一点。另外，可以看出Pyjnius可以很好的使用Java类。 还要注意这个函数在桌面系统上也可以运行，因为它与Android无关；你只要用Java和Pyjnius就可以了。 . 现在UI和三个主要的功能都实现了，我们的app完成了。 . &#24635;&#32467; . 凡事都有利弊，非移植性代码和可移植性代码都如是。但是，做出正确的选择实际上非常困难，因为选择原生API通常会发生在项目早期，到了后期可能觉得完全不切实际，导致项目终歇菜。 . 本章开篇已经讨论过这种方法的主要优势：对于平台相关的代码，你实际上可以做任何事。没有人为的限制；你的Python代码可以不受限制的接入原生代码的底层API。 . 但是，依赖单一平台的风险就是： . Android市场自然比Android+iOS+...市场小 | 把代码移植到新系统，要使用这些平台相关的特性时很困难 | 如果项目只在一个平台，如果有平台要求发生改变就很危险。被Google封杀比同时被AppStore和Google，以及其他市场封杀的风险大得多 | . 你可以好好想想，做一个适合你的app的决定。 . &#20877;&#35828;UI . 总之，大胆模仿其他UI模式理念（包括布局，字体，配色等）。毕加索的名言，“杰出艺术家模仿，伟大艺术家盗窃”，这正是当今网页和应用开发的精髓。 . 另外，微软用了“Modern UI”做了一堆应用，包括移动应用和桌面应用，并不是说这种设计模式就是好。众所周知，微软的操作系统才是这种设计模式被接受的基础。 . 现在放下Java吧。下一章我们用Python大名鼎鼎的Twisted网络框架做一个简单的CS模式的聊天app。 .",
            "url": "/Kivy/jupyter/kivy/android/ios/2019/04/01/kivy-ch3-sound-recorder-for-android.html",
            "relUrl": "/jupyter/kivy/android/ios/2019/04/01/kivy-ch3-sound-recorder-for-android.html",
            "date": " • Apr 1, 2019"
        }
        
    
  
    
        ,"post14": {
            "title": "Kivy指南-2-画图app",
            "content": "在第一章做时钟app时，我们用了Kivy的标准部件：布局，文本框和按钮。通过这些高层次的抽象，我们能够灵活的修改部件的外观—，可以使用一整套成熟的组件，而不仅仅是单个原始图形。这种方式并非放之四海而皆准，马上你就会看到，Kivy还提供了低层的抽象工具：画点和线。 . 我认为做画图app是自由绘画最好的方式。我们的应用会看着有点像Windows自带的画图程序。 . 不同的是，我们的画图app支持多平台，包括Andorid和iOS。我们也忽略了图像处理的功能，像矩形选框，图层，保存文件等。这些功能可以自己练习。 . 关于移动设备：Kivy完全支持iOS开发，即使你没有类似开发经验也不难。因此，建议你先在熟悉的平台上快速实现app，这样就可以省略编译的时间和一堆细节。Android开发更简单，由于Kivy Launcher可以让Kivy代码直接在Android上运行。 Kivy可以不用编译直接在Andorid上运行测试，相当给力，绝对RAD（rapid application development）。 窗口改变大小的问题，并没有广泛用于移动设备，Kivy应用在不同的移动设备和桌面系统平台使用类似的处理方式。因此，开始编写和调试都非常容易，直到版本确定的最后阶段才需要集中精力弥补这些问题。 . 我们还会学习Kivy中两个相反的功能：触摸屏的多点触控和桌面系统的鼠标点击。 . 作为移动设备的第一大法，Kivy为多点触控输入提供了一个模拟层，可以使用鼠标。可以通过右键激活功能。但是，这个多点触控模拟器并不适合真实的场景，仅适合调试用。 . 画图app最会这这样： . . &#35774;&#32622;&#30011;&#26495; . 我们的app通过root部件自动覆盖全局，整个屏幕都可以画画。到后面增加工具按钮的时候再调整。 . root部件是处于最外层，每个Kivy的app都有一个，可以根据app的需求制定任何部件作为root部件。比如上一章的时钟app，BoxLayout就是root部件；如果没其他要求，布局部件就是用来包裹其他控件的。 . 现在这个画图app，我们需要root部件具有更多的功能；用户应该可以画线条，支持多点触控。不过Kivy没有自带这些功能，所以我们自己建。 . 建立新部件很简单，只要继承Kivy的Widget类就行。如下所示： . from kivy.app import App from kivy.uix.widget import Widget class CanvasWidget(Widget): pass class PaintApp(App): def build(self): return CanvasWidget() if __name__ == &#39;__main__&#39;: PaintApp().run() . 这就是画图app的main.py，PaintApp类就是应用的起点。以后我们不会重复这些代码，只把重要的部分显示出来。 . Widget类通常作为基类，就行Python的object和Java的Object。当它按照as is方式使用时，Widget功能极少。它没有可以直接拿来用的可视化的外观和属性。Widget的子类都是很简单易用的。 . &#21046;&#20316;&#22909;&#30475;&#30340;&#22806;&#35266; . 首先，让我们做个好看的外观，虽然不是核心功能，但长相影响第一印象。下面我们改改外观，包括窗口大小，鼠标形状。 . &#21487;&#35270;&#21270;&#22806;&#35266; . 我认为任何画图软件的背景色都应该是白的。和第一章类似，我们在__name = &#39;__main__&#39;后面加上就行： . from kivy.core.window import Window from kivy.utils import get_color_from_hex Window.clearcolor = get_color_from_hex(&#39;#FFFFFF&#39;) . 你可能想把import语句放到前面，其实Kivy的一些模块导入有顺序要求，且会产生副作用，尤其是Window对象。这在好的Python程序中很少见，导入模块产生的副作用有点小问题。 . &#31383;&#21475;&#22823;&#23567; . 另一个要改的就是窗口大小，下面的改变不影响移动设备。在桌面系统上，Kivy的窗口时可以调整的，后面我们会设置禁止调整。 . 如果目标设备明确，设置窗口大小是很有用的，这样就可以决定屏幕分辨率的参数，实现最好的适配效果。 . 要改变窗口大小，就把下面的代码放到from kivy.core.window import Window上面。 . from kivy.config import Config Config.set(&#39;graphics&#39;, &#39;width&#39;, &#39;960&#39;) Config.set(&#39;graphics&#39;, &#39;height&#39;, &#39;540&#39;) # 16:9 . 如果要禁止窗口调整： . Config.set(&#39;graphics&#39;, &#39;resizable&#39;, &#39;0&#39;) . 如果没有充分理由，千万别这么做，因为把窗口调整这点小自由从用户手中拿走实在太伤感情了。如果把应用像素精确到1px，移动设备用户可能就不爽了，而Kivy布局可以建立自适应的界面。 . &#40736;&#26631;&#26679;&#24335; . 之后就是改变鼠标光标的样式。Kivy没有支持，不过可以过Pygame实现，基于SDL窗口和OpenGL内容管理模块，在Kivy的桌面平台应用开发中用途广泛。如果你这么用，移动应用大都不支持Pygame。 . 之后就是改变鼠标光标的样式。Kivy没有支持，不过可以过Pygame实现，基于SDL窗口和OpenGL内容管理模块，在Kivy的桌面平台应用开发中用途广泛。如果你这么用，移动应用大都不支持Pygame。 . 图中@是黑的，-是白的，其他字符是透明的。所以的线都是等宽的，且是8的倍数（SDL的限制）。鼠标的光标运行后是这样： . 当前的Pygame版本有个bug，pygame.cursors.compile()黑白显示颠倒。以后应该会修复。不过pygame_compile_cursor()是正确的方法，Pygame的Simple DirectMedia Layer (SDL)兼容库。 现在，我们把光标应用到app中，替换PaintApp.build方法： . from kivy.base import EventLoop class PaintApp(App): def build(self): EventLoop.ensure_window() if EventLoop.window.__class__.__name__.endswith(&#39;Pygame&#39;): try: from pygame import mouse # pygame_compile_cursor is a fixed version of # pygame.cursors.compile a, b = pygame_compile_cursor() mouse.set_cursor((24, 24), (9, 9), a, b) except: pass return CanvasWidget() . 代码很简单，注意下面四点： . EventLoop.ensure_window(): 这个函数到app窗口 ( EventLoop.window ) 准备好才执行。 | EventLoop.window.__class__.__name__.endswith(&#39;Pygame&#39;): 这个条件检查窗口名称Pygame，只是Pygame条件下才执行自定义光标。 | try ... except模块里面是Pygame的mouse.set_cursor。 | 变量a和b通过SDL构建了光标，表示异或(XOR)和与(AND)，都是SDL独有的实现方式。Pygame文档提供了全部的api说明。 现在做的这些比Kivy的模块更底层，并不常用，不过也不用害怕触及更多的细节。有很多功能只能通过底层的模块实现，因为Kivy还没达到面面俱到的程度。尤其是那些不能跨平台的功能，会涉及很多系统层的实现。 . | . Kivy/Pygame/SDL/OS的关系如下图所示： . SDL已经把系统底层的API都封装好了，兼容多个系统，Pygame再将SDL转换成Python，Kivy可以导入Pygame模块调用这些功能。 . 为什么不直接用SDL呢？可以看SDL文档。 . &#22810;&#28857;&#35302;&#25511;&#27169;&#25311;&#22120; . 让运行桌面应用时，Kivy提供了一个模拟器实现多点触控操作。实际上是一个右击行为，获取半透明的点；按住右键时可以拖拽。 . 如果你没有真实的多点触控设备，这个功能可能适合调试。但是，也会占用右键的功能。不调试的时候还是建议你禁用这个功能，避免对用户造成困扰。设置方法如下： . Config.set(&#39;input&#39;, &#39;mouse&#39;, &#39;mouse,disable_multitouch&#39;) . &#35302;&#25720;&#32472;&#30011; . 要实现用户通过触摸绘画的效果，可以在用户输入后屏幕会出现一个圆圈。 . 部件如果带on_touch_down事件，就可以实现上述功能。正在需要的是点击位置的坐标，为CanvasWidget添加一个方法获取即可： . class CanvasWidget(Widget): def on_touch_down(self, touch): print(touch.x, touch.y) . 要在屏幕上画画，我们就要实现Widget.canvas属性。Kivy的canvas属性是一个底层为OpenGL的可绘制层，不过没有底层图形API那么复杂，canvas可以持续保留我们画过的图。 . 基本图形如圆（Color），线（Line）, 矩形（Rectangle），贝塞尔曲线（Bezier），可以通过kivy.graphics导入。 . canvas&#31616;&#20171; . Canvas的API可以直接调用，也可以通过上下文关联with关键字调用。如下所示： . self.canvas.add(Line(circle=(touch.x, touch.y, 25))) . 这里的Line元素的参数是图形命令队列。 . 如果你想立刻试验代码，请先看下一节屏幕显示触摸轨迹中更完整的例子。 . 通过上下文关联with关键字调用可以让代码更简练，尤其是在同时操作多个指令时。下面的代码与之前一致： . with self.canvas: Line(circle=(touch.x, touch.y, 25)) . 需要注意的是，如前面所说，canvas上后面调用的指令不会覆盖前面调用的指令；因此，canvas是一个不断增长的数组，里面都是不断显示元素的指令，更新频率60fps，但是也不能让canvas无限增长下去。 . 例如，所见即所得的程序（如HTML5的&lt;canvas&gt;）里有一条设计规则就是通过背景色填充擦除之前的图像。在浏览器里面可以很直观的写出： . // JavaScript code for clearing the canvas canvas.rect(0, 0, width, height) canvas.fillStyle = &#39;#FFFFFF&#39; canvas.fill() . 在Kivy设计中，这种模型也是增加指令；首先获取前面所有的图形元素，然后把它们画成矩形。这个看着挺好其实不对： . # 看着和avaScript代码一样，但是错了。 with self.canvas: Color(1, 1, 1) Rectangle(pos=self.pos, size=self.size) . 和内存泄露差不多，这个bug很久没被发现，使代码冗余，性能降低。由于显卡加速的功能，包括智能手机运行速度都很快。所以很难意识到这是一个bug。为了清除Kivy的canvas，应该用canvas.clear()来清除所有指令，后面会介绍。 . &#23631;&#24149;&#26174;&#31034;&#35302;&#25720;&#36712;&#36857; . 我们马上做一个按钮来清屏；现在让我们把触摸的轨迹显示出来。让我们把print()删掉，然后增加一个方法在CanvasWidget下面： . class CanvasWidget(Widget): def on_touch_down(self, touch): with self.canvas: Color(*get_color_from_hex(&#39;#0080FF80&#39;)) Line(circle=(touch.x, touch.y, 25), width=4) . 这样就每次都会画一个空心圆在画布上。Color指令为Line取色。 . 注意hex(&#39;#0080FF80&#39;)并不是CSS颜色格式，因为它有四个组成部分，表示alpha值，即透明度。类似于rgb()与rgba()的区别。 . 可能你会觉得奇怪，我们用Line画的是圈，而不是直线。Kivy的图形元素具体很强的自定义功能，比如我们可以用Rectangle和Triangle画自定义的图片，用source参数设置即可。 . 前面的程序效果如下图所示： 画图app完整的代码如下： . # In main.py from kivy.app import App from kivy.config import Config from kivy.graphics import Color, Line from kivy.uix.widget import Widget from kivy.utils import get_color_from_hex class CanvasWidget(Widget): def on_touch_down(self, touch): with self.canvas: Color(*get_color_from_hex(&#39;#0080FF80&#39;)) Line(circle=(touch.x, touch.y, 25), width=4) class PaintApp(App): def build(self): return CanvasWidget() if __name__ == &#39;__main__&#39;: Config.set(&#39;graphics&#39;, &#39;width&#39;, &#39;400&#39;) Config.set(&#39;graphics&#39;, &#39;height&#39;, &#39;400&#39;) Config.set(&#39;input&#39;, &#39;mouse&#39;, &#39;mouse,disable_multitouch&#39;) from kivy.core.window import Window Window.clearcolor = get_color_from_hex(&#39;#FFFFFF&#39;) PaintApp().run() . 这里没有加入鼠标光标显示的部分。paint.kv文件也没有了，用build()方法返回根部件。 . 注意from kivy.core.window import Window行，是由于有些模块有副作用，所有放在后面导入。Config.set()应该放在任何有副作用模块的前面。 . 下面，我们增加一些特性，让画图app实现我们想要的功能。 . &#28165;&#23631; . 到目前为止，我们清屏的做法就是重启程序。下面我们增加一个按钮来清屏。我们用上一章时钟app的按钮即可，没什么新鲜，有意思的是位置。 . 上一章时钟app里面，我们没有讨论过位置，所有部件都放在BoxLayouts里面。现在我们的app没有任何布局，因为根部件就是CanvasWidget，我们没有实现任何子部件的位置。 . 在Kivy里面，布局部件缺失表示每一个部件都可以随意设置位置和大小（类似的UI设计工具，如Delphi，Visual Basic等等都如此）。 . 要让清屏按钮放在右上角，我们这么做： . # In paint.kv &lt;CanvasWidget&gt;: Button: text: &#39;Delete&#39; right: root.right top: root.top width: 80 height: 40 . 按钮的right和top属性与根部件的属性一致。我们还可以进行数学运行，如root.top – 20。结果很直接，right和top属性都是绝对值。 . 注意我们定义了一个&lt;CanvasWidget&gt;类却没有指定父类。这么做可以是因为我们在Python代码理论已经定义了一个同样的类。Kivy允许我们扩展所有的类，包括内部类，如&lt;Button&gt;和&lt;Label&gt;，以及自定义类。 . 这里体现了Kivy语言描述对象的可视化属性的一个好思路，类似于MVC设计方法，让内容与逻辑分离。同时，也更好的保持了所有Python程序的结构不变。这种Python代码与Kivy语言分离的思想让程序更容易维护。 . &#20256;&#36882;&#20107;&#20214; . 如果你跟着教程看到现在，准备去按清屏键。你会发现没反应，因为还没有增加事件，所有没有反馈。所有单击按钮不会有动作，相反会在画布上留下空心圈。 . 因为所有的触摸都是发生在CanvasWidget.on_touch_down上，并没有传递给其他子部件，所以清屏按钮没反应。不像HTML的DOMDOM，Kivy事件不会从嵌套的元素升级为父元素显示出来。它们走另一条路，如果事件传递到父元素没有反应，才从父元素下降到子元素。 . 最直接的方式就是这样： . # 注意：不是最优代码 def on_touch_down(self, touch): for widget in self.children: widget.on_touch_down(touch) . 实际上，Widget.on_touch_down的默认行为有很多，所有我们可以直接调用，让代码更简练。 . def on_touch_down(self, touch): if Widget.on_touch_down(self, touch): return . 如果事件被正常处理了，on_touch_down这个handler返回True。触摸按钮会返回True是因为按钮响应了，然后很快的改变其外观。这就是为了取消我们的事件处理需要做的事情，当我们画圈的时候，方法的第二个行就return。 . &#28165;&#23631; . 现在我们回到清屏按钮上。其实很简单，就是下面两行： . def clear_canvas(self): self.canvas.clear() . 别忘了把事件绑定到paint.kv文件： . Button: on_release: root.clear_canvas() . 这样就可以清屏了，同时还把按钮也清除了。因为CanvasWidget是根部件，按钮是子部件。按钮部件本身没有被删除，它的画布Button.canvas从CanvasWidget.canvas.children层级中移除了，因此不存在了。 . 要保留按钮，可以这样： . def clear_canvas(self): self.canvas.clear() self.canvas.children = [widget.canvas for widget in self.children] . 但是这么做不够好，因为不同的部件初始化和运行方式不同。更好的做法是： . 从CanvasWidget部件中删除所有子部件； | 然后清除画布； | 最后再重新增加子部件，这样它们就可以正确的初始化了。 | 这个版本有点长，但是更合理： . class CanvasWidget(Widget): def clear_canvas(self): saved = self.children[:] self.clear_widgets() self.canvas.clear() for widget in saved: self.add_widget(widget) . 解释一下saved = self.children[:]语句。[:]操作符是复制数组（就是“创建一个元素相同的数组”）。如果我们写saved = self.children，那就会从self.children和saved同时删除所有子部件。因为Python赋值是引用，与Kivy无关。 . 如果想进一步了解Python的特性，可以看看StackOverflow . 现在，我们已经可以用蓝色的圈钱画图了，如下所示。这当然并非最终版，请看下面的内容。 . &#36830;&#28857;&#25104;&#32447; . 我们的app已经可以清屏了，不过只能画圈。下面在改进一下。 . 要保持连续触控画线（按住然后拖拽），我们需增加一个监听器，on_touch_move。每次使用都会收到最新点的位置。 . 如果我们一次只有一条线，我们可以把这条线保存为self.current_line。但是，由于这是多点触控，我们就要用其他方法来保存touch变量了。 . 之所以能实现这些，是因为每个触控自始至终都访问相同的touch对象。还有一个touch.ud属性，是一个字典类型，ud就是用户数据(user data)，可以灵活的跟踪所有的触控。初始值为空字典{}。 . 下面我们要做的是： . 在on_touch_down的handler创建一个新线，然后储存到touch.ud。现在我们要用直线来代替空心圈。 | 在on_touch_move里面增加一个新点到线的末尾。我们增加的是直线元素，但是事件处理过程是每秒调用很多次实现这条线，每次都很短，最终看起来就很平滑。 | . 更先进的图形程序可以用复杂的算法让线条呈现的更真实。包括贝塞尔曲线实现线条的高分辨率的无缝连接，并且从点的速度和压力推断线的厚度。这些具体的技术我们不打算实现了，不过读者可以作为一个练习。 . 上述过程的代码如下： . from kivy.graphics import Color, Line class CanvasWidget(Widget): def on_touch_down(self, touch): if Widget.on_touch_down(self, touch): return with self.canvas: Color(*get_color_from_hex(&#39;#0080FF80&#39;)) touch.ud[&#39;current_line&#39;] = Line( points=(touch.x, touch.y), width=2) def on_touch_move(self, touch): if &#39;current_line&#39; in touch.ud: touch.ud[&#39;current_line&#39;].points += ( touch.x, touch.y) . 这样就可以画线了。之后让我们来实现颜色选择功能，不断的完善我们的画图app。 . &#35843;&#33394;&#26495; . 画图app当然不能没有调色板。调色板其实就是可选颜色列表，可以让颜色选取很简单。通过图像编辑器都有调色板，带有全真彩24位色16,777,216种。如下图所示： 但是，就是你不打算完成一个主流的图像编辑器，我们也打算限制颜色的种类。因为对那些没有色彩常识的人来说，放一堆颜色只会让人头大。而且，互联网上的UI设计用色也会逐渐统一。 . 在我们的app中，我们打算使用扁平化的UI设计风格，基于一列精心挑选的颜色。当然，你可以选自己喜欢的颜色，因人而异。 . 颜色是一门学问，尤其是具体任务的兼容性与稳定性。低对比度的组合可能用来装饰元素或者标题，但是它们不符合正文的风格；另外，高对比度的颜色，如白与黑，不容易吸引注意力。 . 因此，颜色使用的首要原则是除非你很专业，否则用别人调好的颜色。最好的起点就是操作系统的用色。一些精彩案例如下： . Tango调色板，在Linux开源环境中使用广泛。- Google在2014年GoogleIO大会上发布的Material design。 | 非官方的iOS 7颜色风格，超赞。 | . 还有很多调色板可以学习，自行Google之。 . &#25353;&#38062;&#30340;&#23376;&#31867; . 因为我使用的颜色很少，所以用单选按钮就可以了。Kivy的ToggleButton可以实现功能，不过有个限制：在一个单选组内，所有的按钮可以同时不选。也就是说，画图的时候可能没颜色。当然我们也可以设定默认颜色，但是用户可能会觉得很奇怪，所有我们不打算这么用。 . Python的OOP模式可以很好的解决这个问题，我们可以继承ToggleButton类，然后改造它的功能。之后，每次都会有一个颜色被选中了。 . 子类还会实现另外一个功能：在调色板上，我们想让每个颜色按钮有唯一颜色。我们可以用之前的技术为每个按钮分配背景色，那就要一堆代码来分配。但是，我们如果写一个背景色属性，就可以在paint.kv文件里面分配了。 . 这样就可以在paint.kv文件中使用按钮时保持调色板定义的可读性，同时在子类中实现的具体的细节——会展示OOP程序应该怎样实现。 . &#21435;&#25481;&#20840;&#19981;&#36873;&#21151;&#33021; . 首先，让我们把全不选的功能去掉。 . 首先，让我们实现一个标准的ToggleButton部件。我们之间在paint.kv文件里面增加如下代码： . BoxLayout: orientation: &#39;horizontal&#39; padding: 3 spacing: 3 x: 0 y: 0 width: root.width height: 40 ToggleButton: group: &#39;color&#39; text: &#39;Red&#39; ToggleButton: group: &#39;color&#39; text: &#39;Blue&#39; state: &#39;down&#39; . 我们用了与BoxLayout类似的方式，每个颜色按钮单独分配一个工具栏。布局部件本文的位置是绝对的，其x和y的值都是0，也就是左下角，宽度与CanvasWidget一致。 . 每个ToggleButton都属于同一color组。因此同一时间只有一个颜色可以被选中。 . &#25913;&#20889;&#26631;&#20934;&#34892;&#20026; . 要实现改写，让我们定义ToggleButton子类： . from kivy.uix.behaviors import ToggleButtonBehavior from kivy.uix.togglebutton import ToggleButton class RadioButton(ToggleButton): def _do_press(self): if self.state == &#39;normal&#39;: ToggleButtonBehavior._do_press(self) . 这样当按下按钮，状态&#39;normal&#39;就会变成&#39;down&#39;。 . 现在我们把paint.kv文件里面ToggleButton改成RadioButton，立刻就会看到不同。 . 这也是Kivy框架最吸引人的地方：小代码实现大功能。 . 要在Kivy语言中使用RadioButton，其定义需要在导入main.py文件。由于现在只有一个Python文件，这并不重要，但是一定记住：自定义的Kivy部件，和其他的Python类和函数一样，需要在使用之前被导入。 . &#24425;&#33394;&#25353;&#38062; . 现在按钮的功能正常了，我们把彩色按钮都做出来。如下图所示： 要实现这些，我们得用background_color属性。Kivy的背景色不仅可以使用单一颜色，可以用彩色；我们首先需要一个纯白色背景，然后画上想要的颜色。这样我们就只要为任意数量的彩色按钮准备两种模式（正常和按下的）即可。 . 这和第一章时钟app是一样的。除了按钮的中心区域允许着色，选中的状态有个黑边。 . &#26032;&#25353;&#38062; . 加油！我们就快完工了，在paint.kv里面加入新类ColorButton： . &lt;ColorButton@RadioButton&gt;: group: &#39;color&#39; on_release: app.canvas_widget.set_color(self.background_color) background_normal: &#39;color_button_normal.png&#39; background_down: &#39;color_button_down.png&#39; border: (3, 3, 3, 3) . 你会发现，我们把group: &#39;color&#39;移到这里避免重复代码。 . 我们还要配置on_release事件handler，作用于已经被选中的按钮。现在，每个按钮已经把自己的background_color属性传递给事件handler，剩下的事情就是把颜色分配给画布。这个事件将由CanvasWidget处理，需要通过PaintApp类显示出来。 . class PaintApp(App): def build(self): # set_color()方法后面实现 self.canvas_widget = CanvasWidget() self.canvas_widget.set_color( get_color_from_hex(&#39;#2980B9&#39;)) return self.canvas_widget . 这么配置的原因是我们不能在paint.kv文件的类定义中使用root；因为那样会指向ColorButton自身（类规则里面的根定义在paint.kv文件的顶层）。我们还可以设置默认颜色，就像代码里显示的。 . 在main.py文件里面，让我们来实现CanvasWidget的set_color()方法，可以当作是ColorButton的事件handler。代码很简单，就是把颜色作为参数： . def set_color(self, new_color): self.canvas.add(Color(*new_color)) . &#23450;&#20041;&#35843;&#33394;&#26495; . 下面我们来定义调色板。首先让我们把RadioButton从paint.kv文件中删掉。 . 为了使用CSS颜色定义方式，我们需要将适当的函数导入paint.kv文件。把下面这行代码放在paint.kv文件开头。 . #:import C kivy.utils.get_color_from_hex . 这行代码实际上和Python的代码一样： . from kivy.utils import get_color_from_hex as C . 我们使用扁平化设计的配色方式，代码如下： . BoxLayout: # ... ColorButton: background_color: C(&#39;#2980b9&#39;) state: &#39;down&#39; ColorButton: background_color: C(&#39;#16A085&#39;) ColorButton: background_color: C(&#39;#27AE60&#39;) . 很简单吧，这样就为每个ColorButton按钮定义了background_color属性。其他的属性都是继承于Python中ColorButton类的定义。 . 这样，增加任意数量的按钮都可以很好的排列了。 . &#35774;&#32622;&#32447;&#30340;&#23485;&#24230; . 最后一个，也是最简单的功能就是设置线条的宽度。如下图所示，我们可以重用前面调色板的资源和样式。 . 这个UI也是一种RadioButton子类，命名为LineWidthButton。在paint.kv文件中就是这样： . &lt;LineWidthButton@ColorButton&gt;: group: &#39;line_width&#39; on_release: app.canvas_widget.set_line_width(self.text) color: C(&#39;#2C3E50&#39;) background_color: C(&#39;#ECF0F1&#39;) . 与ColorButton不同之处在于第2、3行代码。这些按钮属于另外一组，由其他的事件handler触发。当然，这两组按钮依然很相似。 . 布局很简单，和调色板的样式一致，只是垂直摆放： . BoxLayout: orientation: &#39;vertical&#39; padding: 2 spacing: 2 x: 0 top: root.top width: 80 height: 110 LineWidthButton: text: &#39;Thin&#39; LineWidthButton: text: &#39;Normal&#39; state: &#39;down&#39; LineWidthButton: text: &#39;Thick&#39; . 注意CanvasWidget.set_line_width事件监听器会接受宽度调节按钮的text属性。这样实现是为了简化，允许我们为每一个按钮定义一个唯一的宽度值。 实际开发中，这种方法固然无可厚非。但是，当我们要把文字翻译成日语或法语的时候，这种对应关系就丢失了。 . &#25913;&#21464;&#32447;&#26465;&#23485;&#24230; . 让我们把前面做好的模块都组合起来，这样就可以控制线条的粗细了。我们把线条宽度存储在CanvasWidget.line_width变量中，与按钮的文字一一对应，然后用on_touch_down触发事件改变线条宽度。代码如下： . class CanvasWidget(Widget): line_width = 2 def on_touch_down(self, touch): # ... with self.canvas: touch.ud[&#39;current_line&#39;] = Line( points=(touch.x, touch.y), width=self.line_width) def set_line_width(self, line_width=&#39;Normal&#39;): self.line_width = { &#39;Thin&#39;: 1, &#39;Normal&#39;: 2, &#39;Thick&#39;: 4 }[line_width] . 这样就完成Kivy的画图app了，开始画图吧。 . &#24635;&#32467; . 这一章，我们重点学习了Kivy应用开发中的一些方法，包括自定义窗口，改变鼠标光标，窗口大小，背景色，通过画布指令绘制自定义的图形，正确的处理支持多平台的触摸事件，并且考虑多点触控的情况。 . 在完成画图app之后，关于Kivy的一件显而易见的事情就是这个框架具有高度的开放性和通用性。不需要一大堆死板的组件，Kivy让开发者可以通过图形基本元素和行为的运用，让自定义模块变得简单灵活。也就是说，Kivy没有自带很多开箱即用的部件，但是通过几行Python代码就可以做出需要的东西。 . 模块化的API设计方法缺乏美感，因为它限制了设计的柔性。最终的结果完全的满足你对项目的需求。客户总想要一些爆点，比如三角形按钮——当然，你还可以为它增加质地，这些都可以两三行代码搞定。（假如你想用WinAPI做一个三角形按钮。那就真掉坑里了。） . Kivy的自定义部件还可以重用。实际上，你可以把main.py的CanvasWidget模块导入其他应用。 . &#33258;&#28982;&#29992;&#25143;&#30028;&#38754; . 我们的第二个应用比第一个应用更具交互性。不仅是在按钮上，还有多点触控手势。 . 所有的窗口都支持触摸屏，对用户来说这是普遍共识，尤其在触摸屏设备上。只要用手指就可以绘画，好像在真实的画布上，即使手指很脏也可以上面画画。 . 这种界面被称为NUI(自然界面，natural user interface)。有一些有趣的特性：NUI应用可以被小朋友或者宠物使用——可以在屏幕上看到和触摸图形元素。这是一种自然、直观的界面，一种“不需要思考”的事情，与Norton Commander的反直觉截然不同。直觉不应该接受蓝屏、ASCII码的表现形式。 . 下一章，我们将建立另外一个Kivy程序，只能Android用。将Python与Android API的Java类很好的结合在一起。 .",
            "url": "/Kivy/jupyter/kivy/android/ios/2019/03/01/kivy-ch2-paint-app.html",
            "relUrl": "/jupyter/kivy/android/ios/2019/03/01/kivy-ch2-paint-app.html",
            "date": " • Mar 1, 2019"
        }
        
    
  
    
        ,"post15": {
            "title": "Kivy指南-1-时钟app",
            "content": "一个仿iOS和Android内置时钟应用的app。分两部分： . 个没有交互的数字时钟，简述Kivy的事件驱动(event-driven)方法，引入计时器的功能，持续更新。 | 交互的秒表功能，设计流畅的自适应布局。 | 学习大纲： . Kivy语言基础，DSL(domain-specific language)处理部件(widgets) | Kivy布局方式 | 自定义字体和文字样式 | 事件管理 | . app最终效果如下，只要60行代码，Python代码和kv代码各一半。 . . &#36215;&#28857; . 将kivy的helloworld稍作修改。增加一个布局容器(layout container)，BoxLayout，后面可增加更多部件。 . # %load ../0_Hello/main.py from kivy.app import App class ClockApp(App): pass if __name__ == &quot;__main__&quot;: ClockApp().run() . # clock.kv BoxLayout: orientation: &#39;vertical&#39; Label: text: &#39;00:00:00&#39; . BoxLayout容器可以包含多个子部件，水平或垂直堆放。由于kv只有一个子部件，BoxLayout就会让它充满所有空间。 . 当运行main.py文件时，Kivy自动调用clock.kv。类名是ClockApp，.kv文件名就是clock，类名小写并去掉App。 . &#26032;UI . 扁平化设计模式(flat design paradigm)如日中天，覆盖Web，移动，桌面应用领域，兴起于iOS7和Win8。互联网公司也追随，于Google I/O 2014出Material design，其他HTML5框架，如Bootstrap亦如是。 . 扁平化设计强调内容胜于外观，忽略逼真图片的阴影和细致的质地，支持纯色和简单几何图形。强调比学院派的仿真设计（skeuomorphic design）更简单的程序化创造，前者倾向于丰富视觉效果和艺术感。 . 仿真主义是用户界面设计的主流方法。认为应用程序属于真实世界的一部分，比如一个带按钮的计算器app应该被做成廉价的、物质的计算器的感觉，有助于提升用户体验（得看是谁用）。 . 如今，放弃视觉细节而转向简单、流线型界面仿佛是共识。另一方面，仅靠一堆彩色框框就想做成惊世骇俗的作品很有难度。扁平化设计成了文字排版好的代名词原因就是文字成了UI设计中重要的部分，所有我们要让文字好看。 . &#35774;&#35745;&#28789;&#24863; . 模仿Android 4.1 Jelly Bean的时钟设计。字体是Google的Roboto字体，取代了Android 4.0 Ice Cream Sandwich的Droid字体。 . . &#21152;&#36733;&#33258;&#23450;&#20041;&#23383;&#20307; . Kivy默认是Droid Sans字体，通过font_name属性可设置自定义字体。这里只有一种字体，可以直接将.ttf文件名放上。 . # clock.kv Label: font_name: &#39;Loster.ttf&#39; . 但是我们要好几种字体，一个属性就不够了。因为不同字体都是单个文件，而属性只能跟一个文件名。涉及多种字体可以用LabelBase.register方法可以接受多种字体，如下所示： . LabelBase.register( name=&quot;Roboto&quot;, fn_regular=&quot;Roboto-Regular.ttf&quot;, fn_bold=&quot;Roboto-Bold.ttf&quot;, fn_italic=&quot;Roboto-Italic.ttf&quot;, fn_bolditalic=&quot;Roboto-BoldItalic.ttf&quot;, ) . 改进之后，一个部件的font_name属性可设置多种自定义字体了。但这种方法有两个限制： . kivy只接受TrueType的.ttf字体。如果是OpenType的.otf或者网页字体如.woff，得先转换。 | 字体normal，italic，bold，bold italic四种样式有最大值。旧字体没问题，如Droid Sans。但是新字体都有4到20多种样式，其高度和其他特征也不同。Roboto至少有12种样式。 | 第二点迫使我们选择app字体时要把12种样式全放进去，这么做会增大app的体积，Roboto字体有1.7M。 . 本例中我们只要两种样式：浅色(Roboto-Thin.ttf)和加粗(Roboto-Medium.ttf) . from kivy.core.text import LabelBase LabelBase.register( name=&quot;Roboto&quot;, fn_regular=&quot;Roboto-Thin.ttf&quot;, fn_bold=&quot;Roboto-Medium.ttf&quot; ) . 下面我们来使用字体，放到Label后面即可。 . # clock.kv Label: text: &#39;00:00:00&#39; font_name: &#39;Roboto&#39; font_size: 60 . &#23383;&#20307;&#26684;&#24335; . markup语言毋庸置疑HTML。Kivy实现了另外一种BBCode的markup语言，用[]作标签。 . BBCode tag Effect on text . [b]...[/b] | Effect on text | . [i]...[/i] | Italic | . [font=Lobster]...[/font] | Change font | . [color=#FF0000]...[/color] | Set color with CSS-like syntax | . [sub]...[/sub] | Subscript (text below the line) | . [sup]...[/sup] | Superscript (text above the line) | . [ref=name]...[/ref] | Clickable zone, &lt;a href=&quot;...&quot;&gt; in HTML | . [anchor=name] | Named location, &lt;a name=&quot;...&quot;&gt; in HTML | . 由于Kivy发展很快，以上内容绝非最终版本，详情查阅kivy文档。 . 再看看图2，我们要实现小时数字加粗的效果就easy了。 . # clock.kv Label: text: &#39;[b]00[/b]:00:00&#39; markup: True . Kivy的BBCode需要将markup属性设置为True。 . 如果要整行加粗，可以直接设bold属性为True。其他斜体、颜色、字体、大小同理。 . &#25913;&#21464;&#32972;&#26223;&#33394; . 下面我们来调整窗口背景色，是Window对象的一个属性。可以在__name__ == &#39;__main__&#39;后面增加代码： . from kivy.core.window import Window from kivy.utils import get_color_from_hex Window.clearcolor = get_color_from_hex(&quot;#101216&quot;) . 函数get_color_from_hex允许使用CSS的RGB颜色值(#RRGGBB)，也可以用其他函数。 . &#26174;&#31034;&#26102;&#38388; . 大多数UI框架都是事件驱动，Kivy也不例外。这种方式相比通常的程序更简单——事件驱动的代码需要不断返回到主循环（main loop）；但是，这么做不能处理用户行为（点击鼠标，改变窗口），而且界面会冻结（freeze），Windows经常这样程序停止响应。 . 总之，不能在程序里面加无限循环实现。 . # Don&#39;t do this while True: update_time() # some function that displays time sleep(1) . 理论上可行，但UI实际会失去相应，直到系统或用户关闭进程才结束。记住Kivy内部一直运行主循环，我们可以通过事件与计算器来利用它。 . 事件驱动还意味着我们需要对不同事件作出响应，可能是用户输入，网络行为，或超时等等。 . 很多程序监听共同事件之一就是App.on_start，定义在类里面，在app初始化的时候调用。另一个常见的是on_press，当用户点击，tap，或其他按钮操作时启用。 . 通过时间和计时器，我们就可以用Kivy自带的Clock类实现想要的功能。两个方法： . Clock.schedule_once：在一段时间后运行一次 | Clock.schedule_interval：周期性的运行 | . 和JavaScript中的window.setTimeout和window.setInterval类似。其实Kivy和JS很像，即使API完全不同。 . Clock所有的计时事件都是Kivy主循环的一部分。这种方法与线程不同，这样调用一个阻塞函数可能会阻止其他事件被及时唤醒。 . &#26356;&#26032;&#23631;&#24149;&#19978;&#30340;&#26102;&#38388; . 要接入显示时间的Label部件，需要给它一个id，通过id属性来获取部件，这和Web开发类似。 . # clock.kv Label: id: time . 之后就可以通过root.ids.time来接入Label部件了。这里root就是BoxLayout。 . 给ClockApp类增加一个update_time方法来更新时间： . def update_time(self, nap): self.root.ids.time.text = strftime(&quot;[b]%H[/b]:%M:%S&quot;) . 再增加一个调度功能，让程序更新后每秒更新一次： . def on_start(self): Clock.schedule_interval(self.update_time, 1) . 运行程序看看是不是开始更新了。代码如下： . # %load main.py from kivy.app import App from kivy.clock import Clock from kivy.core.window import Window from kivy.utils import get_color_from_hex from time import strftime class ClockApp(App): def update_time(self, nap): self.root.ids.time.text = strftime(&quot;[b]%H[/b]:%M:%S&quot;) def on_start(self): Clock.schedule_interval(self.update_time, 1) if __name__ == &quot;__main__&quot;: Window.clearcolor = get_color_from_hex(&quot;#301216&quot;) ClockApp().run() . 看看python的time标准库strftime函数是如何与Kivy的BBCode组合成C语言字符串的。 . # %load clock.kv BoxLayout: orientation: &#39;vertical&#39; Label: text: &#39;[b]00[/b]:00:00&#39; markup: True id: time . &#29992;&#23646;&#24615;&#32465;&#23450;&#37096;&#20214; . 除了ID绑定部件，还可以新建一个属性，在kv文件中进行绑定。这么做更符合DRY原则，只是多几行代码。如下所示： . # In main.py from kivy.properties import ObjectProperty from kivy.uix.boxlayout import BoxLayout class ClockLayout(BoxLayout): time_prop = ObjectProperty(None) . 我们在这段代码用BoxLayout写了个新root部件类，它有一个自定义属性time_prop，将连接Label部件。 . 在clock.kv文件里，我们把属性绑定id，自定义属性和默认属性语法一致： . # %load clock.kv ClockLayout: time_prop: time Label: id: time . 这样，Python代码不需要知道id就可以连接Label部件，用新属性root.time_prop.text = &quot;demo&quot;。 . 这样做使代码的可移植性更好，消除了反射（refactor）时Python代码同步的问题。靠属性还是root.ids去连接Python代码这事儿，只是代码风格问题，不重要。后面还会介绍其他Kivy属性的用法，让数据绑定更容易。 . &#24067;&#23616;&#22522;&#30784; . Kivy提供了一堆Layout类来布局。Layout又是Widget类的子类，是个容器类。每个布局都是影响其子类位置和尺寸。 . 在这个app中，我们的UI很直接，不需要什么神奇，如下所示： . . 做这种界面就要BoxLayout，一种一维网格。在clock.kv里面已经有BoxLayout了，只有一个子部件。Kivy的布局默认充满屏幕，所以自动适应屏幕。 . 如果增加一个Layout，就会分一半屏幕，vertical和horizontal决定分割的方向。 . 我们这里就用vertical分三块，然后中间那块用horizontal分两块，Esay吧。 . &#23436;&#25104;&#24067;&#23616; . 由于中间这块是按钮，不应该比时间还大，可以增加一个height属性，然后设置size_hint属性为None。size_hint属性是一个元组(宽, 高)，影响部件的宽和高。如果你想用绝对高度和宽度，就要设置size_hint属性为None，否则高度和宽度设置无效，部件会自动计算尺寸。代码如下： . # %load clock.kv BoxLayout: orientation: &#39;vertical&#39; Label: id: time text: &#39;[b]00[/b]:00:00&#39; font_name: &#39;Roboto&#39; font_size: 60 markup: True BoxLayout: height: 90 orientation: &#39;horizontal&#39; padding: 20 spacing: 20 size_hint: (1, None) Button: text: &#39;Start&#39; font_name: &#39;Roboto&#39; font_size: 25 bold: True Button: text: &#39;Reset&#39; font_name: &#39;Roboto&#39; font_size: 25 bold: True Label: id: stopwatch text: &#39;00:00.[size=40]00[/size]&#39; font_name: &#39;Roboto&#39; font_size: 60 markup: True . 运行代码，会发现按钮没有完全填充BoxLayout，因为用了padding和spacing属性，与CSS类似。main.py代码如下： . # %load main.py from kivy.app import App from kivy.clock import Clock from kivy.core.window import Window from kivy.utils import get_color_from_hex from kivy.core.text import LabelBase from time import strftime LabelBase.register( name=&quot;Roboto&quot;, fn_regular=&quot;Roboto-Thin.ttf&quot;, fn_bold=&quot;Roboto-Medium.ttf&quot; ) class ClockApp(App): def update_time(self, nap): self.root.ids.time.text = strftime(&quot;[b]%H[/b]:%M:%S&quot;) def on_start(self): Clock.schedule_interval(self.update_time, 1) if __name__ == &quot;__main__&quot;: Window.clearcolor = get_color_from_hex(&quot;#123456&quot;) ClockApp().run() . &#20943;&#23569;&#37325;&#22797; . 之前的kv代码一堆重复，其实可以借助CSS的方法是代码更精炼，更DRY。在BoxLayout外面增加一个新定义： . # %load clock.kv &lt;Label&gt;: font_name: &#39;Roboto&#39; font_size: 60 markup: True . 这是一个类，与CSS的selector类似。每个Label都会带&lt;Label&gt;类特性。 . 这样就可以把clock.kv里面每个Label的font_name，font_size和markup属性都删掉了。如果想改变一个属性的值，就直接写上，会覆盖原来的值，与CSS完全一样。 . 定义类并没有创造一个新部件，只是一个属性集合。增加一个定义类，如果不使用就不会改变app的布局。 . &#21629;&#21517;&#31867; . 前面kv代码里类的处理有点问题，类只能有一个名字叫Label。当我们要为同一种部件加不同的属性定义类时，可以自定义类。如果直接改写Label和Button这些标准类，之后再用到通过类部件时改前改后一堆麻烦。所幸，命名类可以解决这一问题，RobotoButton是一种Button： . &lt;RobotoButton@Button&gt;: font_name: &#39;Roboto&#39; font_size: 25 bold: True . @前面是新类的名称，后面是部件类型，本质是面向对象的子类class RobotoButton(Button)，在kv代码里使用时，可以直接用命名类代替原来的Button类： . RobotoButton: text: &#39;Start&#39; . 命名类可以精简代码，而且可以改良部件。 . &#25353;&#38062;&#26679;&#24335; . UI设计的死角是可点击元素，像按钮之类，没有一个统一样式。Win8的Metro风格十分激进，点击部分完全是纯色矩形，很小甚至基本没图案。Apple使用弧度；还有一种使用圆角的趋势，尤其在CSS3风格里。轻微的阴影也开始使用。 . Kivy在这方面很灵活，不强制任何一种风格，而且提供一堆特性帮你实现任意风格。其中之一就是9-patch缩放功能。 . 9-patch scaling . 传统UI开发中，如果背景的大小不一样，一般需要为每种大小都制作一张图片，这在button中尤为明显。当然我们也可以一小块一小块水平重复的画，也可以垂直的话。在android中专门有一种叫9-patch图片（以9.png结尾）来解决背景大小不一样时，只用一张背景图片。无论横屏还是竖屏，高分辨率还是低分辨率，都能自动填充满，而且不失真。 . 缩放算法的目的就是尽可能的适应不同场合的像素要求，尤其是包含一堆文字的按钮。等比放缩图片容易实现，但是由于变形比例问题，质量不太好。 . 非等比的9-patch放大可以产生不失真的效果。其理念就是把图片分成若干静止的、可缩放的块。假设下图是个可缩放按钮。黄色部分是操作区，其他颜色都是边： . . 当红色区域被压缩时，蓝色区域大小不变。如下图所示： . . 蓝色的角是不变的，红色的边可以垂直、水平缩放。图片中唯一等比变化的部分就是黄色的操作区，通常都是用纯色，也可以加上文字。 . &#20351;&#29992;9-patch&#22270; . 本例中，我们用一个简单的1px边的纯色按钮，改下颜色就可以重用。如下所示： . . 按下去的状态就用相反的颜色，如下所示： . . 现在在clock.kv中添加9-patch图，我们需要告诉Kivy图像边的像素，因为默认是等比变化的。 . &lt;RobotoButton@Button&gt;: background_normal: &#39;button_normal.png&#39; background_down: &#39;button_down.png&#39; border: (2, 2, 2, 2) . border属性与CSS一致是顺时针：上，右，下，左。不过，不能像CSS里面直接写统一值border: 2，暂时还不行。 . 当然用Python语法border:[2] * 4是最短的。 . 前面说过，与CSS类似，后面的属性会覆盖前面同名的属性，比如新建Reset按钮，就可以在RobotoButton下修改： . RobotoButton: text: &#39;Reset&#39; background_normal: &#39;red_button_normal.png&#39; background_down: &#39;red_button_down.png&#39; . 这样按钮就搞定了，但是还不能运行，下面我们来实现秒表功能。 . &#35745;&#26102;&#21151;&#33021; . 秒表不只是显示时间，还需要暂停、复位，比普通的钟表要复杂一点。反映到程序上，就是Python的datatime模块和strftime()函数的区别。后者可以直接将现在的时间格式化，正是秒表显示所要的。 . 首先，我们要建立一个计时器。由于Kivy的Clock.schedule_interval事件handler支持时间参数，所以不通过Python的时间函数也容易实现。 . def on_start(self): Clock.schedule_interval(self.update, 0.016) def update(self, nap): pass . 时间单位是秒，就是说app每秒运行60次(60fps)为1帧，平均间隔时间为 $$ frac{1}{60} = 0.016(6)$$ . 然后就是时间持续更新： . class ClockApp(App): sw_seconds = 0 def update(self, nap): self.sw_seconds += nap . 我们先做时间显示功能，然后再实现停止功能。 . &#31186;&#34920;&#26102;&#38388;&#26684;&#24335; . 对于主时间显示，格式很简单，因为标准模块strftime提供了datetime时间转换字符串的功能。但是这个函数有一些不足： . 只接受Python的datetime时间格式（但是秒表需要秒用小数显示sw_seconds） | 没有十进制秒的转换功能 | . datetime的不足容易克服：可以将sw_seconds转换为datetime时间格式。但是有点多余，因为我们最后还是需要小数显示，所以strftime格式不行。那么我们就自己做个轮子。 . &#35745;&#31639;&#26102;&#38388; . 首先计算分、秒和分秒，divmode函数输出(商，余数)。 . minutes, seconds = divmod(self.sw_seconds, 60) . divmode函数只计算一次，普通/和%运算需要两次。如果我们每一帧画面都有大量这样的浮点数除法，就像游戏或仿真，CPU就费劲了。 . 不太同意所谓“过早优化是魔鬼”，许多差的实践导致程序性能低下，其实一开始很容易避免，而且不影响代码质量，不去做才是魔鬼。 . 要注意divmode函数结果都还是浮点数，所以要去争：int(minutes)和 int(seconds)。 . 现在就剩下分秒了，可以这样获得： . int(seconds * 100 % 100) . &#23454;&#29616;&#31186;&#34920; . 现在所有的数值都有了，让我们组合一下。Python的字符串处理有很多格式，与The Zen of Python（打开Python输入import this）的 &quot;There should be one—and preferably only one—obvious way to do it&quot;并不一致，呵呵。最简单的就是%为代表的C语言风格。 . def update_time(self, nap): self.sw_seconds += nap minutes, seconds = divmod(self.sw_seconds, 60) self.root.ids.stopwatch.text = &quot;%02d:%02d.[size=40]%02d[/size]&quot; % ( int(minutes), int(seconds), int(seconds * 100 % 100), ) . 现在有分秒了，之前用的更新频率1fps就不适用了。让我们把update_time时间间隔改为0，即每一帧都更新： . Clock.schedule_interval(self.update_time, 0) . . Warning: 目前，大多数显示都是60fps，我们的值精确到1/100s，1秒钟100次更新。但是这么做没啥意义，因为在普通硬件上，人不会识别出100fps和60fps的区别。因此，大多数情况下，代码都应该与帧率分离，由于它的效果依赖于用户的硬件，而硬件种类千差万别，没法儿预测你的app会在什么机子上运行。 运行程序会看到时间更新，但是还缺少控件，下面就是。 . &#31186;&#34920;&#25511;&#20214; . 用按钮来控制应用是最简单的。下面就是所有代码： . def start_stop(self): self.root.ids.start_stop.text = &quot;Start&quot; if self.sw_started else &quot;Stop&quot; self.sw_started = not self.sw_started def reset(self): if self.sw_started: self.root.ids.start_stop.text = &quot;Start&quot; self.sw_started = False self.sw_seconds = 0 . 第一个事件handler是Start和Stop按钮，由sw_started改变状态实现。第二个handler是Reset按钮。 . 还需要增加状态属性跟踪秒表是否在运行： . class ClockApp(App): sw_started = False sw_seconds = 0 def update_clock(self, nap): if self.sw_started: self.sw_seconds += nap . 我们改变update_clock函数只有秒表开始sw_started为True才更新，秒表开始默认为停止状态。 . 在clock.kv文件里，我们把方法绑定到on_press事件上： . RobotoButton: id: start_stop text: &#39;Start&#39; on_press: app.start_stop() RobotoButton: id: reset text: &#39;Reset&#39; on_press: app.reset() . 在Kivy语言里面，有几个上下文相关的参考： . self：引用当前部件； | root：整个程序中最外层的部件； | app：应用类的一个实例。 | . 你会发觉，按钮事件处理一点也不难。就这样，我们的app实现了秒表的交互功能，允许用户开始，停止，复位。 . &#24635;&#32467; . 这一章我们做了一个app，如果要打包并发布到Google Play或其他商店供大家用，还需要一点工作，因为涉及到具体的平台，但是最难的部分——编程——已经结束。 . 通过个app，我们学习了ivy应用开发的很多方面，并不需要太多复杂代码就搞定了。Kivy的主要特点就是短小精悍的代码，允许快速迭代。一点点旧代码就可以获得很多新特性。Kivy生命力旺盛，将长盛不衰。 . 这本书所以内容的共同基础是，无论我们的程序还是Kivy，都不是凭空产生的。一切都源自Python的cheese shop——Python Package Index (PyPI)——以及其他工具包，包括操作系统底层服务。 . 我们还更新了许多网页应用开发的资源，如CSS框架Bootstrap中的字体、颜色和阴影。当然也希望你看看Google的Material design principles——不仅只是设计资源集合，也是一个完整教程，教我们实现风格统一、界面友好的UI，同时保留app的&quot;个性&quot;和特点。 . 当然，这才刚刚开始。欲知后事如何，请听下回分解。 .",
            "url": "/Kivy/jupyter/kivy/android/ios/2019/02/01/kivy-ch1-clock-app.html",
            "relUrl": "/jupyter/kivy/android/ios/2019/02/01/kivy-ch1-clock-app.html",
            "date": " • Feb 1, 2019"
        }
        
    
  
    
        ,"post16": {
            "title": "Kivy指南-前言",
            "content": "&#21069;&#35328; . 移动应用开发几年前就是热点了，现在是个软件用户就想要移动版。桌面操作系统也受到影响，跨平台的软件成为新常态。甚至通常局限于微软桌面操作系统的游戏开发者也开始找一些Mac和Linux平台上的工作了（比如Steam，目前有Mac游戏近4000个，SteamOS+Linux游戏2000多个）。 . 这对新手和个人开发者是大利好：跨平台的支持可以增加用户，销售量自然会更好。 . 但是，写可移植的软件是非常耗费资源的过程，对小公司和个人开发者的影响比大公司更甚。 . 尤其是许多平台都有不同语言的SDK：iOS用Objective-C和Swift，Android用Java，MS用.Net，更多是C#来开发软件。 . 使用这些工具可以通过系统功能来制作相应的原生应用，但是跨平台的代码重用变得十分困难。就算你精通所有语言和相关的操作，代码的移植仍然是一件复杂的事情。 . &#19968;&#27425;&#32534;&#20889;&#65292;&#21040;&#22788;&#36816;&#34892; . 因此，统一多平台支持开发工具呼之欲出。无独有偶，1995年的Sun公司就为解决类似问题发明了Java。其口号为“Write once, run anywhere”（一次编写，到处运行，WORA），虽然Java已经20年了，很多人都在各种纪念。但是其啰嗦的代码仍然没能实现当年的豪言壮语，一些程序员的改编版本更能表达人们的感受——“write once, run away”（一次编写，到处跑偏），有一些放弃Java转向了更好的程序语言，比如Python。 . 本书主题Kivy是一个图形用户界面（graphical user interface，GUI）工具用来轻松创建跨平台的Python应用。其主要特征如下： . 兼容性：Kivy支持多平台，包括Windows，MacOS，Linux，Android和iOS，均出自一个工具 | 原生界面：Kivy填补了不同输入方式间的缝隙，允许你用相同的代码处理不同的输入方式，包括鼠标和触摸屏 | 快速图形硬件加速：OpenGL渲染让Kivy可以胜任图形需求高的应用，如视频游戏，还可以通过平滑变换改善用户体验 | 使用Python开发：Kivy的app是用Python写的，轻松简单，可移植性良好，Python的标准库和PyPI第三方丰富模块都可以使用 | . Kivy可以看作许多模块的超集：许多知名的模块如Pygame，SDL，GStreamer都是Kivy的组成部分。但是，Kivy的API更加高级、统一，方便使用。 . Kivy是开源的，其源代码在GitHub上。你可以fork一下，帮忙打补丁，也可以增加新特性。 . &#26412;&#20070;&#20869;&#23481;&#31616;&#20171; . 本书分9章。 . 第1章，时钟app对Kivy应用开发做简要介绍。包括Kivy语言、布局、部件和计时器。本章会做一个时钟app，与手机上的时钟应用类似 | 第2章，画图app对Kivy框架的部件和功能进一步挖掘。通过制作画图app学习自定义部件，在画布上画任意形状，处理多点触控事件等 | 第3章，Android录音app是用Kivy开发一个Android应用。通过Pyjnius模块实现Python与Java的交互，调用Android的API来实现Kivy用户界面 | 第4章，聊天app介绍Kivy的网络应用开发，用Python写一个简单通信协议，利用Twisted框架建立服务器-客户端模型，实现一个Kivy聊天app | 第5章，远程桌面app用另一种方式写服务器-客户端应用。这章通过HTTP协议来构建模型。首先建立命令行模式的HTTP服务器，然后再用Kivy实现远程桌面app | 第6章，2048 app是实现一个2048游戏。我们将演示Kivy更复杂的功能，用Kivy属性实现数据绑定和触摸手势处理来创建自定义部件 | 第7章，飞翔的小鸟app是另一个Kivy游戏，实现著名的Flappy Bird游戏。我们会学习纹理坐标的使用，声音效果和碰撞检测等知识 | 第8章，着色器app介绍Kivy应用中如何GLSL着色器。这一章首先介绍OpenGL原始类型的概念，如索引和顶点，然后写出可以直接在GPU上运行代码，最后实现一个满天星屏保app | 第9章，射击app延续上一章的内容，用GLSL着色器做游戏。首先实现一个可重用的粒子系统，然后通过粒子系统构建游戏角色。前面介绍过的许多内容在这个游戏中都会得到体现，如碰撞检测，触摸屏控制，声音效果等 | . &#29615;&#22659;&#35774;&#32622; . 下面简要介绍Kivy的安装方法，包括Mac，Linux和Windows系统。 . Python . Kivy同时支持Python2和Python3，2020年Python2停止维护，建议使用Python3。 . 许多平台不需要单独安装Python：比如Mac OS上自带Python2，Windows上和Kivy打包在一起，Linux（尤其是Ubuntu）支持apt-get安装。 . &#23433;&#35013;&#24182;&#36816;&#34892;Kivy . Kviy的最新稳定版本可以在官方网站找到。如下图所示： . . 下载安装包后，具体平台安装方法可以看图中第三列指令，简要介绍如下： . Mac： 打开命令行窗口 | 执行kivy | Python提示符出现后输入import kivy | 如果安装顺利会出现[INFO] Kivy v1.9.0 | | . Linux： 打开命令行窗口 | 执行python | Python提示符出现后输入import kivy | 如果安装顺利会出现[INFO] Kivy v1.9.0 | | . Windows： 双击kivy.bat文件 | 执行python | Python提示符出现后输入import kivy | 如果安装顺利会出现[INFO] Kivy v1.9.0 | | . 运行Kivy应用很简单： . Mac上用kivy main.py | Linux上用python main.py | Windows上用kivy.bat main.py（或者把main.py拖到kivy.bat上运行） | . Hello, Kivy . 下面我们演示一个Kivy app的hello world版。 . &#20195;&#30721; . 程序的入口是main.py，代码如下： . from kivy.app import App class HelloApp(App): pass if __name__ == &quot;__main__&quot;: HelloApp().run() . &#24067;&#23616; . 布局文件是应用类名的去掉App的小写部分加.kv，也就是hello.kv，代码如下所示： . Label: text: &#39;Hello, Kivy&#39; . 这里只用了一个Kivy标签部件Label，属性是text。布局文件用一种简洁、声明式的语言定义复杂的布局，后面会介绍。 . 运行程序，看到的界面如下所示： . . 下面就让我们开始Kivy之旅吧！Enjoy . . Tip: 最新源代码请参考作者Mark Vasilkov的github .",
            "url": "/Kivy/jupyter/kivy/android/ios/2019/01/01/kivy-perface.html",
            "relUrl": "/jupyter/kivy/android/ios/2019/01/01/kivy-perface.html",
            "date": " • Jan 1, 2019"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "奶爸，Pythonista，数据从业者（爬虫、ETL、EDA、Web） . 热爱生活，喜欢翻译，擅长看文档 . This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "/Kivy/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  

  
  

  
      ,"page11": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "/Kivy/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}